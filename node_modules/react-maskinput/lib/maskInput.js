'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _inputCore = require('input-core');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var KEYBOARD = {
  BACKSPACE: 8,
  DELETE: 46
};
/**
 * React-MaskInput component
 * Params:
 * `mask`: String. Format:
 *   0 — any number 0-9
 *   * — any symbol
 *   a — A-Z, a-z
 *   q — "q" letter, 2 — "2" letter etc.
 *   \a — "a" letter
 * default is undefined
 *
 * [function] `reformat`: user function, if you want use custom reformat logic. It's userfull for numeric inputs.
 * If reformat defined mask'll be ignored. Reformat function must receive object with several fields:
 * function reformat({data: data, selection: {start, end}, input}) {
 *     // realisation
 *
 *     return {
 *         [any] value: value that store and calling in input core funcitons (such as reformat). value may have any format,
 *         [String] visibleValue: value that displayed to user in input if showMask is false,
 *         [String] maskedValue: value that  displayed to user in input if showMask is true,
 *         [{[integer] start, [integer] end}] selection: {start, end} — new selection range
 *     }
 * }
 *
 * if `reformat` and `mask` is undefined, input allow to enter any values.
 *
 * You can define custom mask by passing `maskFormat`. This prop must be an array,
 * each object in array have several fields:
 * str: matched char for mask
 * regexp: validation rule as regexp
 * type: special
 *
 * `maskChar`: Character to cover unfilled editable parts of mask. Default value is ''.
 * `maskString`: String to cover unfilled editable parts of mask. Default is undefined. If maskString define maskChar ignored.
 *
 * showMask: show mask in input. It's possible only if mask have not cyclic. Default value = false
 * alwaysShowMask: show mask when input inactive
 *
 * Callbacks:
 *   onValueChange(event). event is:
 *     unformattedValue: unformatted value,
 *     value: visible value
 *   getReference: callback to get input ref
 * All other props'll passed to input directly
 */

var MaskInput = function (_Component) {
  _inherits(MaskInput, _Component);

  function MaskInput(props, context) {
    _classCallCheck(this, MaskInput);

    var _this = _possibleConstructorReturn(this, (MaskInput.__proto__ || Object.getPrototypeOf(MaskInput)).call(this, props, context));

    _this.showValue = function () {
      if (_this.state.showMask && (_this.canSetSelection || _this.props.alwaysShowMask)) {
        _this.refs.input.value = _this.input.getMaskedValue();
        return;
      }
      _this.refs.input.value = _this.input.getVisibleValue();
    };

    _this.setSelection = function () {
      if (!_this.canSetSelection) {
        return;
      }
      var selection = _this.input.getSelection();
      _this.refs.input.setSelectionRange(selection.start, selection.end);
      var raf = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function (fn) {
        return setTimeout(fn, 0);
      };
      // For android
      raf(function () {
        return _this.refs.input.setSelectionRange(selection.start, selection.end);
      });
    };

    _this.onPaste = function (e) {
      e.preventDefault();
      _this.getSelection();

      // getData value needed for IE also works in FF & Chrome
      _this.input.paste(e.clipboardData.getData('Text'));

      _this.showValue();

      // Timeout needed for IE
      setTimeout(_this.setSelection, 0);

      _this.props.onChange && _this.props.onChange(e);
    };

    _this.onChange = function (e) {
      var currentValue = void 0;
      if (_this.state.showMask && (_this.canSetSelection || _this.props.alwaysShowMask)) {
        currentValue = _this.input.getMaskedValue();
      } else {
        currentValue = _this.input.getVisibleValue();
      }

      // fix conflict by update value in mask model
      if (e.target.value !== currentValue) {
        _this.getSelection();
        _this.input.setValue(e.target.value);

        _this.showValue();

        setTimeout(_this.setSelection, 0);
      }
      _this.props.onChange && _this.props.onChange(e);
    };

    _this.onKeyPress = function (e) {
      if (e.metaKey || e.altKey || e.ctrlKey || e.key === 'Enter') {
        return;
      }

      e.preventDefault();
      _this.getSelection();
      _this.input.input(e.key || e.data || String.fromCharCode(e.which));
      _this.showValue();
      _this.setSelection();
      _this.props.onChange && _this.props.onChange(e);
    };

    _this.onKeyDown = function (e) {
      if (e.which === KEYBOARD.BACKSPACE) {
        e.preventDefault();
        _this.getSelection();
        _this.input.removePreviosOrSelected();

        _this.showValue();
        _this.setSelection();

        _this.props.onChange && _this.props.onChange(e);
      }

      if (e.which === KEYBOARD.DELETE) {
        e.preventDefault();
        _this.getSelection();
        _this.input.removeNextOrSelected();

        _this.showValue();
        _this.setSelection();

        _this.props.onChange && _this.props.onChange(e);
      }
    };

    _this.onFocus = function (e) {
      _this.canSetSelection = true;
      _this.props.onFocus && _this.props.onFocus(e);
    };

    _this.onBlur = function (e) {
      _this.canSetSelection = false;
      _this.props.onBlur && _this.props.onBlur(e);
    };

    _this.input = (0, _inputCore.createInput)({
      value: props.value || props.defaultValue || '',
      reformat: props.reformat,
      maskString: props.maskString,
      maskChar: props.maskChar || _inputCore.defaults.maskChar,
      mask: props.mask || _inputCore.defaults.mask,
      maskFormat: props.maskFormat || _inputCore.defaults.maskFormat
    });

    _this.state = {
      showMask: props.alwaysShowMask || props.showMask
    };

    _this.applyValue = function (value) {
      _this.input.setValue(value);

      if (_this.state.showMask && (_this.canSetSelection || _this.props.alwaysShowMask)) {
        _this.refs.input.value = _this.input.getMaskedValue();
        return;
      }
      _this.refs.input.value = _this.input.getVisibleValue();
    };
    return _this;
  }

  _createClass(MaskInput, [{
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      var updated = false;

      if (this.props.alwaysShowMask !== nextProps.alwaysShowMask || this.props.showMask !== nextProps.showMask) {
        this.setState({
          showMask: nextProps.alwaysShowMask || nextProps.showMask
        });
      }

      if (nextProps.reformat !== this.props.reformat) {
        this.input.setReformat(nextProps.reformat);
        updated = true;
      }

      if (nextProps.maskFormat && nextProps.maskFormat !== this.props.maskFormat) {
        this.input.setMaskFormat(nextProps.maskFormat);
        updated = true;
      }

      if (nextProps.mask !== this.props.mask) {
        this.input.setMask(nextProps.mask);
        updated = true;
      }

      if (nextProps.maskString !== this.props.maskString) {
        this.input.setMaskString(nextProps.maskString);
      }

      if (nextProps.maskChar !== this.props.maskChar) {
        this.input.setMaskChar(nextProps.maskChar);
        updated = true;
      }

      if (nextProps.value !== this.props.value) {
        this.input.setValue(nextProps.value);
        updated = true;
      }

      if (updated) {
        if (this.canSetSelection && nextProps.showMask || nextProps.alwaysShowMask) {
          this.refs.input.value = this.input.getMaskedValue();
        } else {
          this.refs.input.value = this.input.getVisibleValue();
        }
        this.setSelection();
      }
    }
  }, {
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.showValue();
      this.props.getReference && this.props.getReference(this.refs.input);
    }
  }, {
    key: 'getSelection',
    value: function getSelection() {
      this.input.setSelection({
        start: this.refs.input.selectionStart,
        end: this.refs.input.selectionEnd
      });
    }
  }, {
    key: 'keyPressPropName',
    value: function keyPressPropName() {
      if (typeof navigator !== 'undefined' && navigator.userAgent.match(/Android/i)) {
        return 'onBeforeInput';
      }
      return 'onKeyPress';
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          onChange = _props.onChange,
          onValueChange = _props.onValueChange,
          mask = _props.mask,
          direction = _props.direction,
          getReference = _props.getReference,
          showMask = _props.showMask,
          maskChar = _props.maskChar,
          alwaysShowMask = _props.alwaysShowMask,
          customMaskFormat = _props.customMaskFormat,
          maskString = _props.maskString,
          reformat = _props.reformat,
          value = _props.value,
          defaultValue = _props.defaultValue,
          inputProps = _objectWithoutProperties(_props, ['onChange', 'onValueChange', 'mask', 'direction', 'getReference', 'showMask', 'maskChar', 'alwaysShowMask', 'customMaskFormat', 'maskString', 'reformat', 'value', 'defaultValue']);

      var keyPressEvent = _defineProperty({}, this.keyPressPropName(), this.onKeyPress);

      return _react2.default.createElement('input', _extends({}, inputProps, {
        onChange: this.onChange,
        onKeyDown: this.onKeyDown,
        onPaste: this.onPaste,
        onFocus: this.onFocus,
        onBlur: this.onBlur
      }, keyPressEvent, {
        ref: 'input'
      }));
    }
  }]);

  return MaskInput;
}(_react.Component);

exports.default = MaskInput;