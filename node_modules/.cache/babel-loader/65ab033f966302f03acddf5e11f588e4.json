{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { Severity } from '@sentry/types';\nimport { addExceptionMechanism, addExceptionTypeValue, isDOMError, isDOMException, isError, isErrorEvent, isEvent, isPlainObject, SyncPromise } from '@sentry/utils';\nimport { eventFromPlainObject, eventFromStacktrace, prepareFramesForEvent } from './parsers';\nimport { computeStackTrace } from './tracekit';\n/**\n * Builds and Event from a Exception\n * @hidden\n */\nexport function eventFromException(options, exception, hint) {\n  var syntheticException = hint && hint.syntheticException || undefined;\n  var event = eventFromUnknownInput(exception, syntheticException, {\n    attachStacktrace: options.attachStacktrace\n  });\n  addExceptionMechanism(event, {\n    handled: true,\n    type: 'generic'\n  });\n  event.level = Severity.Error;\n  if (hint && hint.event_id) {\n    event.event_id = hint.event_id;\n  }\n  return SyncPromise.resolve(event);\n}\n/**\n * Builds and Event from a Message\n * @hidden\n */\nexport function eventFromMessage(options, message, level, hint) {\n  if (level === void 0) {\n    level = Severity.Info;\n  }\n  var syntheticException = hint && hint.syntheticException || undefined;\n  var event = eventFromString(message, syntheticException, {\n    attachStacktrace: options.attachStacktrace\n  });\n  event.level = level;\n  if (hint && hint.event_id) {\n    event.event_id = hint.event_id;\n  }\n  return SyncPromise.resolve(event);\n}\n/**\n * @hidden\n */\nexport function eventFromUnknownInput(exception, syntheticException, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var event;\n  if (isErrorEvent(exception) && exception.error) {\n    // If it is an ErrorEvent with `error` property, extract it to get actual Error\n    var errorEvent = exception;\n    // eslint-disable-next-line no-param-reassign\n    exception = errorEvent.error;\n    event = eventFromStacktrace(computeStackTrace(exception));\n    return event;\n  }\n  if (isDOMError(exception) || isDOMException(exception)) {\n    // If it is a DOMError or DOMException (which are legacy APIs, but still supported in some browsers)\n    // then we just extract the name, code, and message, as they don't provide anything else\n    // https://developer.mozilla.org/en-US/docs/Web/API/DOMError\n    // https://developer.mozilla.org/en-US/docs/Web/API/DOMException\n    var domException = exception;\n    var name_1 = domException.name || (isDOMError(domException) ? 'DOMError' : 'DOMException');\n    var message = domException.message ? name_1 + \": \" + domException.message : name_1;\n    event = eventFromString(message, syntheticException, options);\n    addExceptionTypeValue(event, message);\n    if ('code' in domException) {\n      event.tags = __assign(__assign({}, event.tags), {\n        'DOMException.code': \"\" + domException.code\n      });\n    }\n    return event;\n  }\n  if (isError(exception)) {\n    // we have a real Error object, do nothing\n    event = eventFromStacktrace(computeStackTrace(exception));\n    return event;\n  }\n  if (isPlainObject(exception) || isEvent(exception)) {\n    // If it is plain Object or Event, serialize it manually and extract options\n    // This will allow us to group events based on top-level keys\n    // which is much better than creating new group when any key/value change\n    var objectException = exception;\n    event = eventFromPlainObject(objectException, syntheticException, options.rejection);\n    addExceptionMechanism(event, {\n      synthetic: true\n    });\n    return event;\n  }\n  // If none of previous checks were valid, then it means that it's not:\n  // - an instance of DOMError\n  // - an instance of DOMException\n  // - an instance of Event\n  // - an instance of Error\n  // - a valid ErrorEvent (one with an error property)\n  // - a plain Object\n  //\n  // So bail out and capture it as a simple message:\n  event = eventFromString(exception, syntheticException, options);\n  addExceptionTypeValue(event, \"\" + exception, undefined);\n  addExceptionMechanism(event, {\n    synthetic: true\n  });\n  return event;\n}\n/**\n * @hidden\n */\nexport function eventFromString(input, syntheticException, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var event = {\n    message: input\n  };\n  if (options.attachStacktrace && syntheticException) {\n    var stacktrace = computeStackTrace(syntheticException);\n    var frames_1 = prepareFramesForEvent(stacktrace.stack);\n    event.stacktrace = {\n      frames: frames_1\n    };\n  }\n  return event;\n}","map":{"version":3,"sources":["../src/eventbuilder.ts"],"names":[],"mappings":"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","sourcesContent":["import { Event, EventHint, Options, Severity } from '@sentry/types';\nimport {\n  addExceptionMechanism,\n  addExceptionTypeValue,\n  isDOMError,\n  isDOMException,\n  isError,\n  isErrorEvent,\n  isEvent,\n  isPlainObject,\n  SyncPromise,\n} from '@sentry/utils';\n\nimport { eventFromPlainObject, eventFromStacktrace, prepareFramesForEvent } from './parsers';\nimport { computeStackTrace } from './tracekit';\n\n/**\n * Builds and Event from a Exception\n * @hidden\n */\nexport function eventFromException(options: Options, exception: unknown, hint?: EventHint): PromiseLike<Event> {\n  const syntheticException = (hint && hint.syntheticException) || undefined;\n  const event = eventFromUnknownInput(exception, syntheticException, {\n    attachStacktrace: options.attachStacktrace,\n  });\n  addExceptionMechanism(event, {\n    handled: true,\n    type: 'generic',\n  });\n  event.level = Severity.Error;\n  if (hint && hint.event_id) {\n    event.event_id = hint.event_id;\n  }\n  return SyncPromise.resolve(event);\n}\n\n/**\n * Builds and Event from a Message\n * @hidden\n */\nexport function eventFromMessage(\n  options: Options,\n  message: string,\n  level: Severity = Severity.Info,\n  hint?: EventHint,\n): PromiseLike<Event> {\n  const syntheticException = (hint && hint.syntheticException) || undefined;\n  const event = eventFromString(message, syntheticException, {\n    attachStacktrace: options.attachStacktrace,\n  });\n  event.level = level;\n  if (hint && hint.event_id) {\n    event.event_id = hint.event_id;\n  }\n  return SyncPromise.resolve(event);\n}\n\n/**\n * @hidden\n */\nexport function eventFromUnknownInput(\n  exception: unknown,\n  syntheticException?: Error,\n  options: {\n    rejection?: boolean;\n    attachStacktrace?: boolean;\n  } = {},\n): Event {\n  let event: Event;\n\n  if (isErrorEvent(exception as ErrorEvent) && (exception as ErrorEvent).error) {\n    // If it is an ErrorEvent with `error` property, extract it to get actual Error\n    const errorEvent = exception as ErrorEvent;\n    // eslint-disable-next-line no-param-reassign\n    exception = errorEvent.error;\n    event = eventFromStacktrace(computeStackTrace(exception as Error));\n    return event;\n  }\n  if (isDOMError(exception as DOMError) || isDOMException(exception as DOMException)) {\n    // If it is a DOMError or DOMException (which are legacy APIs, but still supported in some browsers)\n    // then we just extract the name, code, and message, as they don't provide anything else\n    // https://developer.mozilla.org/en-US/docs/Web/API/DOMError\n    // https://developer.mozilla.org/en-US/docs/Web/API/DOMException\n    const domException = exception as DOMException;\n    const name = domException.name || (isDOMError(domException) ? 'DOMError' : 'DOMException');\n    const message = domException.message ? `${name}: ${domException.message}` : name;\n\n    event = eventFromString(message, syntheticException, options);\n    addExceptionTypeValue(event, message);\n    if ('code' in domException) {\n      event.tags = { ...event.tags, 'DOMException.code': `${domException.code}` };\n    }\n\n    return event;\n  }\n  if (isError(exception as Error)) {\n    // we have a real Error object, do nothing\n    event = eventFromStacktrace(computeStackTrace(exception as Error));\n    return event;\n  }\n  if (isPlainObject(exception) || isEvent(exception)) {\n    // If it is plain Object or Event, serialize it manually and extract options\n    // This will allow us to group events based on top-level keys\n    // which is much better than creating new group when any key/value change\n    const objectException = exception as Record<string, unknown>;\n    event = eventFromPlainObject(objectException, syntheticException, options.rejection);\n    addExceptionMechanism(event, {\n      synthetic: true,\n    });\n    return event;\n  }\n\n  // If none of previous checks were valid, then it means that it's not:\n  // - an instance of DOMError\n  // - an instance of DOMException\n  // - an instance of Event\n  // - an instance of Error\n  // - a valid ErrorEvent (one with an error property)\n  // - a plain Object\n  //\n  // So bail out and capture it as a simple message:\n  event = eventFromString(exception as string, syntheticException, options);\n  addExceptionTypeValue(event, `${exception}`, undefined);\n  addExceptionMechanism(event, {\n    synthetic: true,\n  });\n\n  return event;\n}\n\n/**\n * @hidden\n */\nexport function eventFromString(\n  input: string,\n  syntheticException?: Error,\n  options: {\n    attachStacktrace?: boolean;\n  } = {},\n): Event {\n  const event: Event = {\n    message: input,\n  };\n\n  if (options.attachStacktrace && syntheticException) {\n    const stacktrace = computeStackTrace(syntheticException);\n    const frames = prepareFramesForEvent(stacktrace.stack);\n    event.stacktrace = {\n      frames,\n    };\n  }\n\n  return event;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}