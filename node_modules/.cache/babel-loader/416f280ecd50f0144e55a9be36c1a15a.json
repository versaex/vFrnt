{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\nvar $ = require('./util/preconditions');\nvar cashaddr = require('cashaddrjs');\nvar errors = require('./errors');\nvar Base58Check = require('./encoding/base58check');\nvar Networks = require('./networks');\nvar Hash = require('./crypto/hash');\nvar JSUtil = require('./util/js');\nvar PublicKey = require('./publickey');\nvar BITPAY_P2PKH_VERSION_BYTE = 28;\nvar BITPAY_P2SH_VERSION_BYTE = 40;\n\n/**\n * Instantiate an address from an address String or Buffer, a public key or script hash Buffer,\n * or an instance of {@link PublicKey} or {@link Script}.\n *\n * This is an immutable class, and if the first parameter provided to this constructor is an\n * `Address` instance, the same argument will be returned.\n *\n * An address has two key properties: `network` and `type`. The type is either\n * `Address.PayToPublicKeyHash` (value is the `'pubkeyhash'` string)\n * or `Address.PayToScriptHash` (the string `'scripthash'`). The network is an instance of {@link Network}.\n * You can quickly check whether an address is of a given kind by using the methods\n * `isPayToPublicKeyHash` and `isPayToScriptHash`\n *\n * @example\n * ```javascript\n * // validate that an input field is valid\n * var error = Address.getValidationError(input, 'testnet');\n * if (!error) {\n *   var address = Address(input, 'testnet');\n * } else {\n *   // invalid network or checksum (typo?)\n *   var message = error.messsage;\n * }\n *\n * // get an address from a public key\n * var address = Address(publicKey, 'testnet').toString();\n * ```\n *\n * @param {*} data - The encoded data in various formats\n * @param {Network|String|number=} network - The network: 'livenet' or 'testnet'\n * @param {string=} type - The type of address: 'script' or 'pubkey'\n * @returns {Address} A new valid and frozen instance of an Address\n * @constructor\n */\nfunction Address(data, network, type) {\n  /* jshint maxcomplexity: 12 */\n  /* jshint maxstatements: 20 */\n\n  if (!(this instanceof Address)) {\n    return new Address(data, network, type);\n  }\n  if (_.isArray(data) && _.isNumber(network)) {\n    return Address.createMultisig(data, network, type);\n  }\n  if (data instanceof Address) {\n    // Immutable instance\n    return data;\n  }\n  $.checkArgument(data, 'First argument is required, please include address data.', 'guide/address.html');\n  if (network && !Networks.get(network)) {\n    throw new TypeError('Second argument must be \"livenet\" or \"testnet\".');\n  }\n  if (type && type !== Address.PayToPublicKeyHash && type !== Address.PayToScriptHash) {\n    throw new TypeError('Third argument must be \"pubkeyhash\" or \"scripthash\".');\n  }\n  var info = this._classifyArguments(data, network, type);\n\n  // set defaults if not set\n  info.network = info.network || Networks.get(network) || Networks.defaultNetwork;\n  info.type = info.type || type || Address.PayToPublicKeyHash;\n  JSUtil.defineImmutable(this, {\n    hashBuffer: info.hashBuffer,\n    network: info.network,\n    type: info.type\n  });\n  return this;\n}\n\n/**\n * Internal function used to split different kinds of arguments of the constructor\n * @param {*} data - The encoded data in various formats\n * @param {Network|String|number=} network - The network: 'livenet' or 'testnet'\n * @param {string=} type - The type of address: 'script' or 'pubkey'\n * @returns {Object} An \"info\" object with \"type\", \"network\", and \"hashBuffer\"\n */\nAddress.prototype._classifyArguments = function (data, network, type) {\n  /* jshint maxcomplexity: 10 */\n  // transform and validate input data\n  if ((data instanceof Buffer || data instanceof Uint8Array) && data.length === 20) {\n    return Address._transformHash(data);\n  } else if ((data instanceof Buffer || data instanceof Uint8Array) && data.length === 21) {\n    return Address._transformBuffer(data, network, type);\n  } else if (data instanceof PublicKey) {\n    return Address._transformPublicKey(data);\n  } else if (data instanceof Script) {\n    return Address._transformScript(data, network);\n  } else if (typeof data === 'string') {\n    return Address._transformString(data, network, type, Address.DefaultFormat);\n  } else if (_.isObject(data)) {\n    return Address._transformObject(data);\n  } else {\n    throw new TypeError('First argument is an unrecognized data format.');\n  }\n};\n\n/** @static */\nAddress.LegacyFormat = 'legacy';\n/** @static */\nAddress.BitpayFormat = 'bitpay';\n/** @static */\nAddress.CashAddrFormat = 'cashaddr';\n/** @static */\nAddress.DefaultFormat = Address.LegacyFormat;\n\n/** @static */\nAddress.PayToPublicKeyHash = 'pubkeyhash';\n/** @static */\nAddress.PayToScriptHash = 'scripthash';\n\n/**\n * @param {Buffer} hash - An instance of a hash Buffer\n * @returns {Object} An object with keys: hashBuffer\n * @private\n */\nAddress._transformHash = function (hash) {\n  var info = {};\n  if (!(hash instanceof Buffer) && !(hash instanceof Uint8Array)) {\n    throw new TypeError('Address supplied is not a buffer.');\n  }\n  if (hash.length !== 20) {\n    throw new TypeError('Address hashbuffers must be exactly 20 bytes.');\n  }\n  info.hashBuffer = hash;\n  return info;\n};\n\n/**\n * Deserializes an address serialized through `Address#toObject()`\n * @param {Object} data\n * @param {string} data.hash - the hash that this address encodes\n * @param {string} data.type - either 'pubkeyhash' or 'scripthash'\n * @param {Network=} data.network - the name of the network associated\n * @return {Address}\n */\nAddress._transformObject = function (data) {\n  $.checkArgument(data.hash || data.hashBuffer, 'Must provide a `hash` or `hashBuffer` property');\n  $.checkArgument(data.type, 'Must provide a `type` property');\n  return {\n    hashBuffer: data.hash ? new Buffer(data.hash, 'hex') : data.hashBuffer,\n    network: Networks.get(data.network) || Networks.defaultNetwork,\n    type: data.type\n  };\n};\n\n/**\n * Internal function to discover the network and type based on the first data byte\n *\n * @param {Buffer} buffer - An instance of a hex encoded address Buffer\n * @returns {Object} An object with keys: network and type\n * @private\n */\nAddress._classifyFromVersion = function (buffer) {\n  var version = {};\n  var pubkeyhashNetwork = Networks.get(buffer[0], 'pubkeyhash');\n  var scripthashNetwork = Networks.get(buffer[0], 'scripthash');\n  if (pubkeyhashNetwork) {\n    version.network = pubkeyhashNetwork;\n    version.type = Address.PayToPublicKeyHash;\n  } else if (scripthashNetwork) {\n    version.network = scripthashNetwork;\n    version.type = Address.PayToScriptHash;\n  }\n  return version;\n};\n\n/**\n * Internal function to transform a bitcoin address buffer\n *\n * @param {Buffer} buffer - An instance of a hex encoded address Buffer\n * @param {string=} network - The network: 'livenet' or 'testnet'\n * @param {string=} type - The type: 'pubkeyhash' or 'scripthash'\n * @returns {Object} An object with keys: hashBuffer, network and type\n * @private\n */\nAddress._transformBuffer = function (buffer, network, type) {\n  /* jshint maxcomplexity: 9 */\n  var info = {};\n  if (!(buffer instanceof Buffer) && !(buffer instanceof Uint8Array)) {\n    throw new TypeError('Address supplied is not a buffer.');\n  }\n  if (buffer.length !== 1 + 20) {\n    throw new TypeError('Address buffers must be exactly 21 bytes.');\n  }\n  network = Networks.get(network);\n  var bufferVersion = Address._classifyFromVersion(buffer);\n  if (!bufferVersion.network || network && network !== bufferVersion.network) {\n    throw new TypeError('Address has mismatched network type.');\n  }\n  if (!bufferVersion.type || type && type !== bufferVersion.type) {\n    throw new TypeError('Address has mismatched type.');\n  }\n  info.hashBuffer = buffer.slice(1);\n  info.network = bufferVersion.network;\n  info.type = bufferVersion.type;\n  return info;\n};\n\n/**\n * Internal function to transform a {@link PublicKey}\n *\n * @param {PublicKey} pubkey - An instance of PublicKey\n * @returns {Object} An object with keys: hashBuffer, type\n * @private\n */\nAddress._transformPublicKey = function (pubkey) {\n  var info = {};\n  if (!(pubkey instanceof PublicKey)) {\n    throw new TypeError('Address must be an instance of PublicKey.');\n  }\n  info.hashBuffer = Hash.sha256ripemd160(pubkey.toBuffer());\n  info.type = Address.PayToPublicKeyHash;\n  return info;\n};\n\n/**\n * Internal function to transform a {@link Script} into a `info` object.\n *\n * @param {Script} script - An instance of Script\n * @returns {Object} An object with keys: hashBuffer, type\n * @private\n */\nAddress._transformScript = function (script, network) {\n  $.checkArgument(script instanceof Script, 'script must be a Script instance');\n  var info = script.getAddressInfo(network);\n  if (!info) {\n    throw new errors.Script.CantDeriveAddress(script);\n  }\n  return info;\n};\n\n/**\n * Creates a P2SH address from a set of public keys and a threshold.\n *\n * The addresses will be sorted lexicographically, as that is the trend in bitcoin.\n * To create an address from unsorted public keys, use the {@link Script#buildMultisigOut}\n * interface.\n *\n * @param {Array} publicKeys - a set of public keys to create an address\n * @param {number} threshold - the number of signatures needed to release the funds\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @return {Address}\n */\nAddress.createMultisig = function (publicKeys, threshold, network) {\n  network = network || publicKeys[0].network || Networks.defaultNetwork;\n  return Address.payingTo(Script.buildMultisigOut(publicKeys, threshold), network);\n};\n\n/**\n * Internal function to transform a bitcoin address string\n *\n * @param {string} data\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type: 'pubkeyhash' or 'scripthash'\n * @param {string} format - The format: 'legacy', 'bitpay' or 'cashaddr'\n * @returns {Object} An object with keys: hashBuffer, network and type\n * @private\n */\nAddress._transformString = function (data, network, type, format) {\n  if (typeof data !== 'string') {\n    throw new TypeError('data parameter supplied is not a string.');\n  }\n  data = data.trim();\n  if (format === Address.LegacyFormat) {\n    return Address._transformStringLegacy(data, network, type);\n  } else if (format === Address.BitpayFormat) {\n    return Address._transformStringBitpay(data, network, type);\n  } else if (format === Address.CashAddrFormat) {\n    return Address._transformStringCashAddr(data, network, type);\n  }\n  throw new TypeError('Unrecognized address format.');\n};\n\n/**\n * Internal function to transform a bitcoin address string in legacy format\n *\n * @param {string} data\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type: 'pubkeyhash' or 'scripthash'\n * @returns {Object} An object with keys: hashBuffer, network and type\n * @private\n */\nAddress._transformStringLegacy = function (data, network, type) {\n  var addressBuffer = Base58Check.decode(data);\n  return Address._transformBuffer(addressBuffer, network, type);\n};\n\n/**\n * Internal function to transform a bitcoin address string in Bitpay format\n *\n * @param {string} data\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type: 'pubkeyhash' or 'scripthash'\n * @returns {Object} An object with keys: hashBuffer, network and type\n * @private\n */\nAddress._transformStringBitpay = function (data, network, type) {\n  var addressBuffer = Base58Check.decode(data);\n  if (addressBuffer[0] === BITPAY_P2PKH_VERSION_BYTE) {\n    addressBuffer[0] = 0;\n  } else if (addressBuffer[0] === BITPAY_P2SH_VERSION_BYTE) {\n    addressBuffer[0] = 5;\n  }\n  return Address._transformBuffer(addressBuffer, network, type);\n};\n\n/**\n * Internal function to transform a bitcoin address string in CashAddr format\n *\n * @param {string} data\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type: 'pubkeyhash' or 'scripthash'\n * @returns {Object} An object with keys: hashBuffer, network and type\n * @private\n */\nAddress._transformStringCashAddr = function (data, network, type) {\n  if (!(typeof network === 'string')) {\n    network = network.toString();\n  }\n  var decoded = cashaddr.decode(data);\n  $.checkArgument(!network || network === 'livenet' && decoded.prefix === 'bitcoincash' || network === 'testnet' && decoded.prefix === 'bchtest', 'Invalid network.');\n  $.checkArgument(!type || type === Address.PayToPublicKeyHash && decoded.type === 'P2PKH' || type === Address.PayToScriptHash && decoded.type === 'P2SH', 'Invalid type.');\n  network = Networks.get(network || (decoded.prefix === 'bitcoincash' ? 'livenet' : 'testnet'));\n  type = type || (decoded.type === 'P2PKH' ? Address.PayToPublicKeyHash : Address.PayToScriptHash);\n  var version = new Buffer([network[type]]);\n  var hashBuffer = new Buffer(decoded.hash);\n  var addressBuffer = Buffer.concat([version, hashBuffer]);\n  return Address._transformBuffer(addressBuffer, network, type);\n};\n\n/**\n * Instantiate an address from a PublicKey instance\n *\n * @param {PublicKey} data\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromPublicKey = function (data, network) {\n  var info = Address._transformPublicKey(data);\n  network = network || Networks.defaultNetwork;\n  return new Address(info.hashBuffer, network, info.type);\n};\n\n/**\n * Instantiate an address from a ripemd160 public key hash\n *\n * @param {Buffer} hash - An instance of buffer of the hash\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromPublicKeyHash = function (hash, network) {\n  var info = Address._transformHash(hash);\n  return new Address(info.hashBuffer, network, Address.PayToPublicKeyHash);\n};\n\n/**\n * Instantiate an address from a ripemd160 script hash\n *\n * @param {Buffer} hash - An instance of buffer of the hash\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromScriptHash = function (hash, network) {\n  $.checkArgument(hash, 'hash parameter is required');\n  var info = Address._transformHash(hash);\n  return new Address(info.hashBuffer, network, Address.PayToScriptHash);\n};\n\n/**\n * Builds a p2sh address paying to script. This will hash the script and\n * use that to create the address.\n * If you want to extract an address associated with a script instead,\n * see {{Address#fromScript}}\n *\n * @param {Script} script - An instance of Script\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.payingTo = function (script, network) {\n  $.checkArgument(script, 'script is required');\n  $.checkArgument(script instanceof Script, 'script must be instance of Script');\n  return Address.fromScriptHash(Hash.sha256ripemd160(script.toBuffer()), network);\n};\n\n/**\n * Extract address from a Script. The script must be of one\n * of the following types: p2pkh input, p2pkh output, p2sh input\n * or p2sh output.\n * This will analyze the script and extract address information from it.\n * If you want to transform any script to a p2sh Address paying\n * to that script's hash instead, use {{Address#payingTo}}\n *\n * @param {Script} script - An instance of Script\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromScript = function (script, network) {\n  $.checkArgument(script instanceof Script, 'script must be a Script instance');\n  var info = Address._transformScript(script, network);\n  return new Address(info.hashBuffer, network, info.type);\n};\n\n/**\n * Instantiate an address from a buffer of the address\n *\n * @param {Buffer} buffer - An instance of buffer of the address\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type of address: 'script' or 'pubkey'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromBuffer = function (buffer, network, type) {\n  var info = Address._transformBuffer(buffer, network, type);\n  return new Address(info.hashBuffer, info.network, info.type);\n};\n\n/**\n * Instantiate an address from an address string\n *\n * @param {string} str - An string of the bitcoin address\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type of address: 'script' or 'pubkey'\n * @param {string=} format - The format: 'legacy', 'bitpay' or 'cashaddr'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromString = function (str, network, type, format) {\n  format = format || Address.DefaultFormat;\n  var info = Address._transformString(str, network, type, format);\n  return new Address(info.hashBuffer, info.network, info.type);\n};\n\n/**\n * Instantiate an address from an Object\n *\n * @param {string} json - An JSON string or Object with keys: hash, network and type\n * @returns {Address} A new valid instance of an Address\n */\nAddress.fromObject = function fromObject(obj) {\n  $.checkState(JSUtil.isHexa(obj.hash), 'Unexpected hash property, \"' + obj.hash + '\", expected to be hex.');\n  var hashBuffer = new Buffer(obj.hash, 'hex');\n  return new Address(hashBuffer, obj.network, obj.type);\n};\n\n/**\n * Will return a validation error if exists\n *\n * @example\n * ```javascript\n * // a network mismatch error\n * var error = Address.getValidationError('15vkcKf7gB23wLAnZLmbVuMiiVDc1Nm4a2', 'testnet');\n * ```\n *\n * @param {string} data - The encoded data\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string} type - The type of address: 'script' or 'pubkey'\n * @returns {null|Error} The corresponding error message\n */\nAddress.getValidationError = function (data, network, type) {\n  var error;\n  try {\n    /* jshint nonew: false */\n    new Address(data, network, type);\n  } catch (e) {\n    error = e;\n  }\n  return error;\n};\n\n/**\n * Will return a boolean if an address is valid\n *\n * @example\n * ```javascript\n * assert(Address.isValid('15vkcKf7gB23wLAnZLmbVuMiiVDc1Nm4a2', 'livenet'));\n * ```\n *\n * @param {string} data - The encoded data\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string} type - The type of address: 'script' or 'pubkey'\n * @returns {boolean} The corresponding error message\n */\nAddress.isValid = function (data, network, type) {\n  return !Address.getValidationError(data, network, type);\n};\n\n/**\n * Returns true if an address is of pay to public key hash type\n * @return boolean\n */\nAddress.prototype.isPayToPublicKeyHash = function () {\n  return this.type === Address.PayToPublicKeyHash;\n};\n\n/**\n * Returns true if an address is of pay to script hash type\n * @return boolean\n */\nAddress.prototype.isPayToScriptHash = function () {\n  return this.type === Address.PayToScriptHash;\n};\n\n/**\n * Will return a buffer representation of the address\n *\n * @returns {Buffer} Bitcoin address buffer\n */\nAddress.prototype.toBuffer = function () {\n  var version = new Buffer([this.network[this.type]]);\n  var buf = Buffer.concat([version, this.hashBuffer]);\n  return buf;\n};\n\n/**\n * @returns {Object} A plain object with the address information\n */\nAddress.prototype.toObject = Address.prototype.toJSON = function toObject() {\n  return {\n    hash: this.hashBuffer.toString('hex'),\n    type: this.type,\n    network: this.network.toString()\n  };\n};\n\n/**\n * Will return a the string representation of the address\n *\n * @param {string=} format - The format: 'legacy', 'bitpay' or 'cashaddr'\n * @returns {string} Bitcoin address\n */\nAddress.prototype.toString = function (format) {\n  format = format || Address.DefaultFormat;\n  if (format === Address.LegacyFormat) {\n    return this._toStringLegacy();\n  } else if (format === Address.BitpayFormat) {\n    return this._toStringBitpay();\n  } else if (format === Address.CashAddrFormat) {\n    return this._toStringCashAddr();\n  }\n  throw new TypeError('Unrecognized address format.');\n};\n\n/**\n * Will return a the string representation of the address in legacy format\n *\n * @returns {string} Bitcoin address\n */\nAddress.prototype._toStringLegacy = function () {\n  return Base58Check.encode(this.toBuffer());\n};\n\n/**\n * Will return a the string representation of the address in Bitpay format\n *\n * @returns {string} Bitcoin address\n */\nAddress.prototype._toStringBitpay = function () {\n  var buffer = this.toBuffer();\n  if (this.network.toString() === 'livenet') {\n    if (this.type === Address.PayToPublicKeyHash) {\n      buffer[0] = BITPAY_P2PKH_VERSION_BYTE;\n    } else if (this.type === Address.PayToScriptHash) {\n      buffer[0] = BITPAY_P2SH_VERSION_BYTE;\n    }\n  }\n  return Base58Check.encode(buffer);\n};\n\n/**\n * Will return a the string representation of the address in CashAddr format\n *\n * @returns {string} Bitcoin address\n */\nAddress.prototype._toStringCashAddr = function () {\n  var prefix = this.network.toString() === 'livenet' ? 'bitcoincash' : 'bchtest';\n  var type = this.type === Address.PayToPublicKeyHash ? 'P2PKH' : 'P2SH';\n  return cashaddr.encode(prefix, type, this.hashBuffer);\n};\n\n/**\n * Will return a string formatted for the console\n *\n * @returns {string} Bitcoin address\n */\nAddress.prototype.inspect = function () {\n  return '<Address: ' + this.toString() + ', type: ' + this.type + ', network: ' + this.network + '>';\n};\nmodule.exports = Address;\nvar Script = require('./script');","map":{"version":3,"names":["_","require","$","cashaddr","errors","Base58Check","Networks","Hash","JSUtil","PublicKey","BITPAY_P2PKH_VERSION_BYTE","BITPAY_P2SH_VERSION_BYTE","Address","data","network","type","isArray","isNumber","createMultisig","checkArgument","get","TypeError","PayToPublicKeyHash","PayToScriptHash","info","_classifyArguments","defaultNetwork","defineImmutable","hashBuffer","prototype","Buffer","Uint8Array","length","_transformHash","_transformBuffer","_transformPublicKey","Script","_transformScript","_transformString","DefaultFormat","isObject","_transformObject","LegacyFormat","BitpayFormat","CashAddrFormat","hash","_classifyFromVersion","buffer","version","pubkeyhashNetwork","scripthashNetwork","bufferVersion","slice","pubkey","sha256ripemd160","toBuffer","script","getAddressInfo","CantDeriveAddress","publicKeys","threshold","payingTo","buildMultisigOut","format","trim","_transformStringLegacy","_transformStringBitpay","_transformStringCashAddr","addressBuffer","decode","toString","decoded","prefix","concat","fromPublicKey","fromPublicKeyHash","fromScriptHash","fromScript","fromBuffer","fromString","str","fromObject","obj","checkState","isHexa","getValidationError","error","e","isValid","isPayToPublicKeyHash","isPayToScriptHash","buf","toObject","toJSON","_toStringLegacy","_toStringBitpay","_toStringCashAddr","encode","inspect","module","exports"],"sources":["C:/Users/Elton/OneDrive/Desktop/baseapp-2024/node_modules/bitcoincashjs/src/address.js"],"sourcesContent":["'use strict';\n\nvar _ = require('lodash');\nvar $ = require('./util/preconditions');\nvar cashaddr = require('cashaddrjs');\nvar errors = require('./errors');\nvar Base58Check = require('./encoding/base58check');\nvar Networks = require('./networks');\nvar Hash = require('./crypto/hash');\nvar JSUtil = require('./util/js');\nvar PublicKey = require('./publickey');\n\nvar BITPAY_P2PKH_VERSION_BYTE = 28;\nvar BITPAY_P2SH_VERSION_BYTE = 40;\n\n/**\n * Instantiate an address from an address String or Buffer, a public key or script hash Buffer,\n * or an instance of {@link PublicKey} or {@link Script}.\n *\n * This is an immutable class, and if the first parameter provided to this constructor is an\n * `Address` instance, the same argument will be returned.\n *\n * An address has two key properties: `network` and `type`. The type is either\n * `Address.PayToPublicKeyHash` (value is the `'pubkeyhash'` string)\n * or `Address.PayToScriptHash` (the string `'scripthash'`). The network is an instance of {@link Network}.\n * You can quickly check whether an address is of a given kind by using the methods\n * `isPayToPublicKeyHash` and `isPayToScriptHash`\n *\n * @example\n * ```javascript\n * // validate that an input field is valid\n * var error = Address.getValidationError(input, 'testnet');\n * if (!error) {\n *   var address = Address(input, 'testnet');\n * } else {\n *   // invalid network or checksum (typo?)\n *   var message = error.messsage;\n * }\n *\n * // get an address from a public key\n * var address = Address(publicKey, 'testnet').toString();\n * ```\n *\n * @param {*} data - The encoded data in various formats\n * @param {Network|String|number=} network - The network: 'livenet' or 'testnet'\n * @param {string=} type - The type of address: 'script' or 'pubkey'\n * @returns {Address} A new valid and frozen instance of an Address\n * @constructor\n */\nfunction Address(data, network, type) {\n  /* jshint maxcomplexity: 12 */\n  /* jshint maxstatements: 20 */\n\n  if (!(this instanceof Address)) {\n    return new Address(data, network, type);\n  }\n\n  if (_.isArray(data) && _.isNumber(network)) {\n    return Address.createMultisig(data, network, type);\n  }\n\n  if (data instanceof Address) {\n    // Immutable instance\n    return data;\n  }\n\n  $.checkArgument(data, 'First argument is required, please include address data.', 'guide/address.html');\n\n  if (network && !Networks.get(network)) {\n    throw new TypeError('Second argument must be \"livenet\" or \"testnet\".');\n  }\n\n  if (type && (type !== Address.PayToPublicKeyHash && type !== Address.PayToScriptHash)) {\n    throw new TypeError('Third argument must be \"pubkeyhash\" or \"scripthash\".');\n  }\n\n  var info = this._classifyArguments(data, network, type);\n\n  // set defaults if not set\n  info.network = info.network || Networks.get(network) || Networks.defaultNetwork;\n  info.type = info.type || type || Address.PayToPublicKeyHash;\n\n  JSUtil.defineImmutable(this, {\n    hashBuffer: info.hashBuffer,\n    network: info.network,\n    type: info.type\n  });\n\n  return this;\n}\n\n/**\n * Internal function used to split different kinds of arguments of the constructor\n * @param {*} data - The encoded data in various formats\n * @param {Network|String|number=} network - The network: 'livenet' or 'testnet'\n * @param {string=} type - The type of address: 'script' or 'pubkey'\n * @returns {Object} An \"info\" object with \"type\", \"network\", and \"hashBuffer\"\n */\nAddress.prototype._classifyArguments = function(data, network, type) {\n  /* jshint maxcomplexity: 10 */\n  // transform and validate input data\n  if ((data instanceof Buffer || data instanceof Uint8Array) && data.length === 20) {\n    return Address._transformHash(data);\n  } else if ((data instanceof Buffer || data instanceof Uint8Array) && data.length === 21) {\n    return Address._transformBuffer(data, network, type);\n  } else if (data instanceof PublicKey) {\n    return Address._transformPublicKey(data);\n  } else if (data instanceof Script) {\n    return Address._transformScript(data, network);\n  } else if (typeof(data) === 'string') {\n    return Address._transformString(data, network, type, Address.DefaultFormat);\n  } else if (_.isObject(data)) {\n    return Address._transformObject(data);\n  } else {\n    throw new TypeError('First argument is an unrecognized data format.');\n  }\n};\n\n/** @static */\nAddress.LegacyFormat = 'legacy';\n/** @static */\nAddress.BitpayFormat = 'bitpay';\n/** @static */\nAddress.CashAddrFormat = 'cashaddr';\n/** @static */\nAddress.DefaultFormat = Address.LegacyFormat;\n\n/** @static */\nAddress.PayToPublicKeyHash = 'pubkeyhash';\n/** @static */\nAddress.PayToScriptHash = 'scripthash';\n\n/**\n * @param {Buffer} hash - An instance of a hash Buffer\n * @returns {Object} An object with keys: hashBuffer\n * @private\n */\nAddress._transformHash = function(hash) {\n  var info = {};\n  if (!(hash instanceof Buffer) && !(hash instanceof Uint8Array)) {\n    throw new TypeError('Address supplied is not a buffer.');\n  }\n  if (hash.length !== 20) {\n    throw new TypeError('Address hashbuffers must be exactly 20 bytes.');\n  }\n  info.hashBuffer = hash;\n  return info;\n};\n\n/**\n * Deserializes an address serialized through `Address#toObject()`\n * @param {Object} data\n * @param {string} data.hash - the hash that this address encodes\n * @param {string} data.type - either 'pubkeyhash' or 'scripthash'\n * @param {Network=} data.network - the name of the network associated\n * @return {Address}\n */\nAddress._transformObject = function(data) {\n  $.checkArgument(data.hash || data.hashBuffer, 'Must provide a `hash` or `hashBuffer` property');\n  $.checkArgument(data.type, 'Must provide a `type` property');\n  return {\n    hashBuffer: data.hash ? new Buffer(data.hash, 'hex') : data.hashBuffer,\n    network: Networks.get(data.network) || Networks.defaultNetwork,\n    type: data.type\n  };\n};\n\n/**\n * Internal function to discover the network and type based on the first data byte\n *\n * @param {Buffer} buffer - An instance of a hex encoded address Buffer\n * @returns {Object} An object with keys: network and type\n * @private\n */\nAddress._classifyFromVersion = function(buffer) {\n  var version = {};\n\n  var pubkeyhashNetwork = Networks.get(buffer[0], 'pubkeyhash');\n  var scripthashNetwork = Networks.get(buffer[0], 'scripthash');\n\n  if (pubkeyhashNetwork) {\n    version.network = pubkeyhashNetwork;\n    version.type = Address.PayToPublicKeyHash;\n  } else if (scripthashNetwork) {\n    version.network = scripthashNetwork;\n    version.type = Address.PayToScriptHash;\n  }\n\n  return version;\n};\n\n/**\n * Internal function to transform a bitcoin address buffer\n *\n * @param {Buffer} buffer - An instance of a hex encoded address Buffer\n * @param {string=} network - The network: 'livenet' or 'testnet'\n * @param {string=} type - The type: 'pubkeyhash' or 'scripthash'\n * @returns {Object} An object with keys: hashBuffer, network and type\n * @private\n */\nAddress._transformBuffer = function(buffer, network, type) {\n  /* jshint maxcomplexity: 9 */\n  var info = {};\n  if (!(buffer instanceof Buffer) && !(buffer instanceof Uint8Array)) {\n    throw new TypeError('Address supplied is not a buffer.');\n  }\n  if (buffer.length !== 1 + 20) {\n    throw new TypeError('Address buffers must be exactly 21 bytes.');\n  }\n\n  network = Networks.get(network);\n  var bufferVersion = Address._classifyFromVersion(buffer);\n\n  if (!bufferVersion.network || (network && network !== bufferVersion.network)) {\n    throw new TypeError('Address has mismatched network type.');\n  }\n\n  if (!bufferVersion.type || (type && type !== bufferVersion.type)) {\n    throw new TypeError('Address has mismatched type.');\n  }\n\n  info.hashBuffer = buffer.slice(1);\n  info.network = bufferVersion.network;\n  info.type = bufferVersion.type;\n  return info;\n};\n\n/**\n * Internal function to transform a {@link PublicKey}\n *\n * @param {PublicKey} pubkey - An instance of PublicKey\n * @returns {Object} An object with keys: hashBuffer, type\n * @private\n */\nAddress._transformPublicKey = function(pubkey) {\n  var info = {};\n  if (!(pubkey instanceof PublicKey)) {\n    throw new TypeError('Address must be an instance of PublicKey.');\n  }\n  info.hashBuffer = Hash.sha256ripemd160(pubkey.toBuffer());\n  info.type = Address.PayToPublicKeyHash;\n  return info;\n};\n\n/**\n * Internal function to transform a {@link Script} into a `info` object.\n *\n * @param {Script} script - An instance of Script\n * @returns {Object} An object with keys: hashBuffer, type\n * @private\n */\nAddress._transformScript = function(script, network) {\n  $.checkArgument(script instanceof Script, 'script must be a Script instance');\n  var info = script.getAddressInfo(network);\n  if (!info) {\n    throw new errors.Script.CantDeriveAddress(script);\n  }\n  return info;\n};\n\n/**\n * Creates a P2SH address from a set of public keys and a threshold.\n *\n * The addresses will be sorted lexicographically, as that is the trend in bitcoin.\n * To create an address from unsorted public keys, use the {@link Script#buildMultisigOut}\n * interface.\n *\n * @param {Array} publicKeys - a set of public keys to create an address\n * @param {number} threshold - the number of signatures needed to release the funds\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @return {Address}\n */\nAddress.createMultisig = function(publicKeys, threshold, network) {\n  network = network || publicKeys[0].network || Networks.defaultNetwork;\n  return Address.payingTo(Script.buildMultisigOut(publicKeys, threshold), network);\n};\n\n/**\n * Internal function to transform a bitcoin address string\n *\n * @param {string} data\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type: 'pubkeyhash' or 'scripthash'\n * @param {string} format - The format: 'legacy', 'bitpay' or 'cashaddr'\n * @returns {Object} An object with keys: hashBuffer, network and type\n * @private\n */\nAddress._transformString = function(data, network, type, format) {\n  if (typeof(data) !== 'string') {\n    throw new TypeError('data parameter supplied is not a string.');\n  }\n  data = data.trim();\n  if (format === Address.LegacyFormat) {\n    return Address._transformStringLegacy(data, network, type);\n  }\n  else if (format === Address.BitpayFormat) {\n    return Address._transformStringBitpay(data, network, type);\n  }\n  else if (format === Address.CashAddrFormat) {\n    return Address._transformStringCashAddr(data, network, type);\n  }\n  throw new TypeError('Unrecognized address format.');\n};\n\n/**\n * Internal function to transform a bitcoin address string in legacy format\n *\n * @param {string} data\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type: 'pubkeyhash' or 'scripthash'\n * @returns {Object} An object with keys: hashBuffer, network and type\n * @private\n */\nAddress._transformStringLegacy = function(data, network, type) {\n  var addressBuffer = Base58Check.decode(data);\n  return Address._transformBuffer(addressBuffer, network, type);\n};\n\n/**\n * Internal function to transform a bitcoin address string in Bitpay format\n *\n * @param {string} data\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type: 'pubkeyhash' or 'scripthash'\n * @returns {Object} An object with keys: hashBuffer, network and type\n * @private\n */\nAddress._transformStringBitpay = function(data, network, type) {\n  var addressBuffer = Base58Check.decode(data);\n  if (addressBuffer[0] === BITPAY_P2PKH_VERSION_BYTE) {\n    addressBuffer[0] = 0;\n  }\n  else if (addressBuffer[0] === BITPAY_P2SH_VERSION_BYTE) {\n    addressBuffer[0] = 5;\n  }\n  return Address._transformBuffer(addressBuffer, network, type);\n};\n\n/**\n * Internal function to transform a bitcoin address string in CashAddr format\n *\n * @param {string} data\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type: 'pubkeyhash' or 'scripthash'\n * @returns {Object} An object with keys: hashBuffer, network and type\n * @private\n */\nAddress._transformStringCashAddr = function(data, network, type) {\n  if (!(typeof network === 'string')) {\n    network = network.toString();\n  }\n  var decoded = cashaddr.decode(data);\n  $.checkArgument(\n      !network ||\n          (network === 'livenet' && decoded.prefix === 'bitcoincash') ||\n          (network === 'testnet' && decoded.prefix === 'bchtest'),\n      'Invalid network.'\n  );\n  $.checkArgument(\n    !type ||\n        (type === Address.PayToPublicKeyHash && decoded.type === 'P2PKH') ||\n        (type === Address.PayToScriptHash && decoded.type === 'P2SH'),\n    'Invalid type.'\n  );\n  network = Networks.get(network ||\n      (decoded.prefix === 'bitcoincash' ? 'livenet' : 'testnet')\n  );\n  type = type ||\n      (decoded.type === 'P2PKH' ? Address.PayToPublicKeyHash : Address.PayToScriptHash);\n  var version = new Buffer([network[type]]);\n  var hashBuffer = new Buffer(decoded.hash);\n  var addressBuffer = Buffer.concat([version, hashBuffer]);\n  return Address._transformBuffer(addressBuffer, network, type);\n};\n\n/**\n * Instantiate an address from a PublicKey instance\n *\n * @param {PublicKey} data\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromPublicKey = function(data, network) {\n  var info = Address._transformPublicKey(data);\n  network = network || Networks.defaultNetwork;\n  return new Address(info.hashBuffer, network, info.type);\n};\n\n/**\n * Instantiate an address from a ripemd160 public key hash\n *\n * @param {Buffer} hash - An instance of buffer of the hash\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromPublicKeyHash = function(hash, network) {\n  var info = Address._transformHash(hash);\n  return new Address(info.hashBuffer, network, Address.PayToPublicKeyHash);\n};\n\n/**\n * Instantiate an address from a ripemd160 script hash\n *\n * @param {Buffer} hash - An instance of buffer of the hash\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromScriptHash = function(hash, network) {\n  $.checkArgument(hash, 'hash parameter is required');\n  var info = Address._transformHash(hash);\n  return new Address(info.hashBuffer, network, Address.PayToScriptHash);\n};\n\n/**\n * Builds a p2sh address paying to script. This will hash the script and\n * use that to create the address.\n * If you want to extract an address associated with a script instead,\n * see {{Address#fromScript}}\n *\n * @param {Script} script - An instance of Script\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.payingTo = function(script, network) {\n  $.checkArgument(script, 'script is required');\n  $.checkArgument(script instanceof Script, 'script must be instance of Script');\n\n  return Address.fromScriptHash(Hash.sha256ripemd160(script.toBuffer()), network);\n};\n\n/**\n * Extract address from a Script. The script must be of one\n * of the following types: p2pkh input, p2pkh output, p2sh input\n * or p2sh output.\n * This will analyze the script and extract address information from it.\n * If you want to transform any script to a p2sh Address paying\n * to that script's hash instead, use {{Address#payingTo}}\n *\n * @param {Script} script - An instance of Script\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromScript = function(script, network) {\n  $.checkArgument(script instanceof Script, 'script must be a Script instance');\n  var info = Address._transformScript(script, network);\n  return new Address(info.hashBuffer, network, info.type);\n};\n\n/**\n * Instantiate an address from a buffer of the address\n *\n * @param {Buffer} buffer - An instance of buffer of the address\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type of address: 'script' or 'pubkey'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromBuffer = function(buffer, network, type) {\n  var info = Address._transformBuffer(buffer, network, type);\n  return new Address(info.hashBuffer, info.network, info.type);\n};\n\n/**\n * Instantiate an address from an address string\n *\n * @param {string} str - An string of the bitcoin address\n * @param {String|Network=} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string=} type - The type of address: 'script' or 'pubkey'\n * @param {string=} format - The format: 'legacy', 'bitpay' or 'cashaddr'\n * @returns {Address} A new valid and frozen instance of an Address\n */\nAddress.fromString = function(str, network, type, format) {\n  format = format || Address.DefaultFormat;\n  var info = Address._transformString(str, network, type, format);\n  return new Address(info.hashBuffer, info.network, info.type);\n};\n\n/**\n * Instantiate an address from an Object\n *\n * @param {string} json - An JSON string or Object with keys: hash, network and type\n * @returns {Address} A new valid instance of an Address\n */\nAddress.fromObject = function fromObject(obj) {\n  $.checkState(\n    JSUtil.isHexa(obj.hash),\n    'Unexpected hash property, \"' + obj.hash + '\", expected to be hex.'\n  );\n  var hashBuffer = new Buffer(obj.hash, 'hex');\n  return new Address(hashBuffer, obj.network, obj.type);\n};\n\n/**\n * Will return a validation error if exists\n *\n * @example\n * ```javascript\n * // a network mismatch error\n * var error = Address.getValidationError('15vkcKf7gB23wLAnZLmbVuMiiVDc1Nm4a2', 'testnet');\n * ```\n *\n * @param {string} data - The encoded data\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string} type - The type of address: 'script' or 'pubkey'\n * @returns {null|Error} The corresponding error message\n */\nAddress.getValidationError = function(data, network, type) {\n  var error;\n  try {\n    /* jshint nonew: false */\n    new Address(data, network, type);\n  } catch (e) {\n    error = e;\n  }\n  return error;\n};\n\n/**\n * Will return a boolean if an address is valid\n *\n * @example\n * ```javascript\n * assert(Address.isValid('15vkcKf7gB23wLAnZLmbVuMiiVDc1Nm4a2', 'livenet'));\n * ```\n *\n * @param {string} data - The encoded data\n * @param {String|Network} network - either a Network instance, 'livenet', or 'testnet'\n * @param {string} type - The type of address: 'script' or 'pubkey'\n * @returns {boolean} The corresponding error message\n */\nAddress.isValid = function(data, network, type) {\n  return !Address.getValidationError(data, network, type);\n};\n\n/**\n * Returns true if an address is of pay to public key hash type\n * @return boolean\n */\nAddress.prototype.isPayToPublicKeyHash = function() {\n  return this.type === Address.PayToPublicKeyHash;\n};\n\n/**\n * Returns true if an address is of pay to script hash type\n * @return boolean\n */\nAddress.prototype.isPayToScriptHash = function() {\n  return this.type === Address.PayToScriptHash;\n};\n\n/**\n * Will return a buffer representation of the address\n *\n * @returns {Buffer} Bitcoin address buffer\n */\nAddress.prototype.toBuffer = function() {\n  var version = new Buffer([this.network[this.type]]);\n  var buf = Buffer.concat([version, this.hashBuffer]);\n  return buf;\n};\n\n/**\n * @returns {Object} A plain object with the address information\n */\nAddress.prototype.toObject = Address.prototype.toJSON = function toObject() {\n  return {\n    hash: this.hashBuffer.toString('hex'),\n    type: this.type,\n    network: this.network.toString()\n  };\n};\n\n/**\n * Will return a the string representation of the address\n *\n * @param {string=} format - The format: 'legacy', 'bitpay' or 'cashaddr'\n * @returns {string} Bitcoin address\n */\nAddress.prototype.toString = function(format) {\n  format = format || Address.DefaultFormat;\n  if (format === Address.LegacyFormat) {\n    return this._toStringLegacy();\n  }\n  else if (format === Address.BitpayFormat) {\n    return this._toStringBitpay();\n  }\n  else if (format === Address.CashAddrFormat) {\n    return this._toStringCashAddr();\n  }\n  throw new TypeError('Unrecognized address format.');\n};\n\n/**\n * Will return a the string representation of the address in legacy format\n *\n * @returns {string} Bitcoin address\n */\nAddress.prototype._toStringLegacy = function() {\n  return Base58Check.encode(this.toBuffer());\n}\n\n/**\n * Will return a the string representation of the address in Bitpay format\n *\n * @returns {string} Bitcoin address\n */\nAddress.prototype._toStringBitpay = function() {\n  var buffer = this.toBuffer();\n  if (this.network.toString() === 'livenet') {\n    if (this.type === Address.PayToPublicKeyHash) {\n      buffer[0] = BITPAY_P2PKH_VERSION_BYTE;\n    }\n    else if (this.type === Address.PayToScriptHash) {\n      buffer[0] = BITPAY_P2SH_VERSION_BYTE;\n    }\n  }\n  return Base58Check.encode(buffer);\n}\n\n/**\n * Will return a the string representation of the address in CashAddr format\n *\n * @returns {string} Bitcoin address\n */\nAddress.prototype._toStringCashAddr = function() {\n  var prefix = this.network.toString() === 'livenet' ? 'bitcoincash' : 'bchtest';\n  var type = this.type === Address.PayToPublicKeyHash ? 'P2PKH' : 'P2SH';\n  return cashaddr.encode(prefix, type, this.hashBuffer);\n}\n\n/**\n * Will return a string formatted for the console\n *\n * @returns {string} Bitcoin address\n */\nAddress.prototype.inspect = function() {\n  return '<Address: ' + this.toString() + ', type: ' + this.type + ', network: ' + this.network + '>';\n};\n\nmodule.exports = Address;\n\nvar Script = require('./script');\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}