{"ast":null,"code":"'use strict';\n\nvar BN = require('bn.js');\nvar $ = require('../util/preconditions');\nvar _ = require('lodash');\nvar reversebuf = function reversebuf(buf) {\n  var buf2 = new Buffer(buf.length);\n  for (var i = 0; i < buf.length; i++) {\n    buf2[i] = buf[buf.length - 1 - i];\n  }\n  return buf2;\n};\nBN.Zero = new BN(0);\nBN.One = new BN(1);\nBN.Minus1 = new BN(-1);\nBN.fromNumber = function (n) {\n  $.checkArgument(_.isNumber(n));\n  return new BN(n);\n};\nBN.fromString = function (str, base) {\n  $.checkArgument(_.isString(str));\n  return new BN(str, base);\n};\nBN.fromBuffer = function (buf, opts) {\n  if (typeof opts !== 'undefined' && opts.endian === 'little') {\n    buf = reversebuf(buf);\n  }\n  var hex = buf.toString('hex');\n  var bn = new BN(hex, 16);\n  return bn;\n};\n\n/**\n * Instantiate a BigNumber from a \"signed magnitude buffer\"\n * (a buffer where the most significant bit represents the sign (0 = positive, -1 = negative))\n */\nBN.fromSM = function (buf, opts) {\n  var ret;\n  if (buf.length === 0) {\n    return BN.fromBuffer(new Buffer([0]));\n  }\n  var endian = 'big';\n  if (opts) {\n    endian = opts.endian;\n  }\n  if (endian === 'little') {\n    buf = reversebuf(buf);\n  }\n  if (buf[0] & 0x80) {\n    buf[0] = buf[0] & 0x7f;\n    ret = BN.fromBuffer(buf);\n    ret.neg().copy(ret);\n  } else {\n    ret = BN.fromBuffer(buf);\n  }\n  return ret;\n};\nBN.prototype.toNumber = function () {\n  return parseInt(this.toString(10), 10);\n};\nBN.prototype.toBuffer = function (opts) {\n  var buf, hex;\n  if (opts && opts.size) {\n    hex = this.toString(16, 2);\n    var natlen = hex.length / 2;\n    buf = new Buffer(hex, 'hex');\n    if (natlen === opts.size) {\n      buf = buf;\n    } else if (natlen > opts.size) {\n      buf = BN.trim(buf, natlen);\n    } else if (natlen < opts.size) {\n      buf = BN.pad(buf, natlen, opts.size);\n    }\n  } else {\n    hex = this.toString(16, 2);\n    buf = new Buffer(hex, 'hex');\n  }\n  if (typeof opts !== 'undefined' && opts.endian === 'little') {\n    buf = reversebuf(buf);\n  }\n  return buf;\n};\nBN.prototype.toSMBigEndian = function () {\n  var buf;\n  if (this.cmp(BN.Zero) === -1) {\n    buf = this.neg().toBuffer();\n    if (buf[0] & 0x80) {\n      buf = Buffer.concat([new Buffer([0x80]), buf]);\n    } else {\n      buf[0] = buf[0] | 0x80;\n    }\n  } else {\n    buf = this.toBuffer();\n    if (buf[0] & 0x80) {\n      buf = Buffer.concat([new Buffer([0x00]), buf]);\n    }\n  }\n  if (buf.length === 1 & buf[0] === 0) {\n    buf = new Buffer([]);\n  }\n  return buf;\n};\nBN.prototype.toSM = function (opts) {\n  var endian = opts ? opts.endian : 'big';\n  var buf = this.toSMBigEndian();\n  if (endian === 'little') {\n    buf = reversebuf(buf);\n  }\n  return buf;\n};\n\n/**\n * Create a BN from a \"ScriptNum\":\n * This is analogous to the constructor for CScriptNum in bitcoind. Many ops in\n * bitcoind's script interpreter use CScriptNum, which is not really a proper\n * bignum. Instead, an error is thrown if trying to input a number bigger than\n * 4 bytes. We copy that behavior here. A third argument, `size`, is provided to\n * extend the hard limit of 4 bytes, as some usages require more than 4 bytes.\n */\nBN.fromScriptNumBuffer = function (buf, fRequireMinimal, size) {\n  var nMaxNumSize = size || 4;\n  $.checkArgument(buf.length <= nMaxNumSize, new Error('script number overflow'));\n  if (fRequireMinimal && buf.length > 0) {\n    // Check that the number is encoded with the minimum possible\n    // number of bytes.\n    //\n    // If the most-significant-byte - excluding the sign bit - is zero\n    // then we're not minimal. Note how this test also rejects the\n    // negative-zero encoding, 0x80.\n    if ((buf[buf.length - 1] & 0x7f) === 0) {\n      // One exception: if there's more than one byte and the most\n      // significant bit of the second-most-significant-byte is set\n      // it would conflict with the sign bit. An example of this case\n      // is +-255, which encode to 0xff00 and 0xff80 respectively.\n      // (big-endian).\n      if (buf.length <= 1 || (buf[buf.length - 2] & 0x80) === 0) {\n        throw new Error('non-minimally encoded script number');\n      }\n    }\n  }\n  return BN.fromSM(buf, {\n    endian: 'little'\n  });\n};\n\n/**\n * The corollary to the above, with the notable exception that we do not throw\n * an error if the output is larger than four bytes. (Which can happen if\n * performing a numerical operation that results in an overflow to more than 4\n * bytes).\n */\nBN.prototype.toScriptNumBuffer = function () {\n  return this.toSM({\n    endian: 'little'\n  });\n};\nBN.prototype.gt = function (b) {\n  return this.cmp(b) > 0;\n};\nBN.prototype.gte = function (b) {\n  return this.cmp(b) >= 0;\n};\nBN.prototype.lt = function (b) {\n  return this.cmp(b) < 0;\n};\nBN.trim = function (buf, natlen) {\n  return buf.slice(natlen - buf.length, buf.length);\n};\nBN.pad = function (buf, natlen, size) {\n  var rbuf = new Buffer(size);\n  for (var i = 0; i < buf.length; i++) {\n    rbuf[rbuf.length - 1 - i] = buf[buf.length - 1 - i];\n  }\n  for (i = 0; i < size - natlen; i++) {\n    rbuf[i] = 0;\n  }\n  return rbuf;\n};\nmodule.exports = BN;","map":{"version":3,"names":["BN","require","$","_","reversebuf","buf","buf2","Buffer","length","i","Zero","One","Minus1","fromNumber","n","checkArgument","isNumber","fromString","str","base","isString","fromBuffer","opts","endian","hex","toString","bn","fromSM","ret","neg","copy","prototype","toNumber","parseInt","toBuffer","size","natlen","trim","pad","toSMBigEndian","cmp","concat","toSM","fromScriptNumBuffer","fRequireMinimal","nMaxNumSize","Error","toScriptNumBuffer","gt","b","gte","lt","slice","rbuf","module","exports"],"sources":["C:/Users/Elton/OneDrive/Desktop/baseapp-2024/node_modules/bitcoincashjs/src/crypto/bn.js"],"sourcesContent":["'use strict';\n\nvar BN = require('bn.js');\nvar $ = require('../util/preconditions');\nvar _ = require('lodash');\n\nvar reversebuf = function(buf) {\n  var buf2 = new Buffer(buf.length);\n  for (var i = 0; i < buf.length; i++) {\n    buf2[i] = buf[buf.length - 1 - i];\n  }\n  return buf2;\n};\n\nBN.Zero = new BN(0);\nBN.One = new BN(1);\nBN.Minus1 = new BN(-1);\n\nBN.fromNumber = function(n) {\n  $.checkArgument(_.isNumber(n));\n  return new BN(n);\n};\n\nBN.fromString = function(str, base) {\n  $.checkArgument(_.isString(str));\n  return new BN(str, base);\n};\n\nBN.fromBuffer = function(buf, opts) {\n  if (typeof opts !== 'undefined' && opts.endian === 'little') {\n    buf = reversebuf(buf);\n  }\n  var hex = buf.toString('hex');\n  var bn = new BN(hex, 16);\n  return bn;\n};\n\n/**\n * Instantiate a BigNumber from a \"signed magnitude buffer\"\n * (a buffer where the most significant bit represents the sign (0 = positive, -1 = negative))\n */\nBN.fromSM = function(buf, opts) {\n  var ret;\n  if (buf.length === 0) {\n    return BN.fromBuffer(new Buffer([0]));\n  }\n\n  var endian = 'big';\n  if (opts) {\n    endian = opts.endian;\n  }\n  if (endian === 'little') {\n    buf = reversebuf(buf);\n  }\n\n  if (buf[0] & 0x80) {\n    buf[0] = buf[0] & 0x7f;\n    ret = BN.fromBuffer(buf);\n    ret.neg().copy(ret);\n  } else {\n    ret = BN.fromBuffer(buf);\n  }\n  return ret;\n};\n\n\nBN.prototype.toNumber = function() {\n  return parseInt(this.toString(10), 10);\n};\n\nBN.prototype.toBuffer = function(opts) {\n  var buf, hex;\n  if (opts && opts.size) {\n    hex = this.toString(16, 2);\n    var natlen = hex.length / 2;\n    buf = new Buffer(hex, 'hex');\n\n    if (natlen === opts.size) {\n      buf = buf;\n    } else if (natlen > opts.size) {\n      buf = BN.trim(buf, natlen);\n    } else if (natlen < opts.size) {\n      buf = BN.pad(buf, natlen, opts.size);\n    }\n  } else {\n    hex = this.toString(16, 2);\n    buf = new Buffer(hex, 'hex');\n  }\n\n  if (typeof opts !== 'undefined' && opts.endian === 'little') {\n    buf = reversebuf(buf);\n  }\n\n  return buf;\n};\n\nBN.prototype.toSMBigEndian = function() {\n  var buf;\n  if (this.cmp(BN.Zero) === -1) {\n    buf = this.neg().toBuffer();\n    if (buf[0] & 0x80) {\n      buf = Buffer.concat([new Buffer([0x80]), buf]);\n    } else {\n      buf[0] = buf[0] | 0x80;\n    }\n  } else {\n    buf = this.toBuffer();\n    if (buf[0] & 0x80) {\n      buf = Buffer.concat([new Buffer([0x00]), buf]);\n    }\n  }\n\n  if (buf.length === 1 & buf[0] === 0) {\n    buf = new Buffer([]);\n  }\n  return buf;\n};\n\nBN.prototype.toSM = function(opts) {\n  var endian = opts ? opts.endian : 'big';\n  var buf = this.toSMBigEndian();\n\n  if (endian === 'little') {\n    buf = reversebuf(buf);\n  }\n  return buf;\n};\n\n/**\n * Create a BN from a \"ScriptNum\":\n * This is analogous to the constructor for CScriptNum in bitcoind. Many ops in\n * bitcoind's script interpreter use CScriptNum, which is not really a proper\n * bignum. Instead, an error is thrown if trying to input a number bigger than\n * 4 bytes. We copy that behavior here. A third argument, `size`, is provided to\n * extend the hard limit of 4 bytes, as some usages require more than 4 bytes.\n */\nBN.fromScriptNumBuffer = function(buf, fRequireMinimal, size) {\n  var nMaxNumSize = size || 4;\n  $.checkArgument(buf.length <= nMaxNumSize, new Error('script number overflow'));\n  if (fRequireMinimal && buf.length > 0) {\n    // Check that the number is encoded with the minimum possible\n    // number of bytes.\n    //\n    // If the most-significant-byte - excluding the sign bit - is zero\n    // then we're not minimal. Note how this test also rejects the\n    // negative-zero encoding, 0x80.\n    if ((buf[buf.length - 1] & 0x7f) === 0) {\n      // One exception: if there's more than one byte and the most\n      // significant bit of the second-most-significant-byte is set\n      // it would conflict with the sign bit. An example of this case\n      // is +-255, which encode to 0xff00 and 0xff80 respectively.\n      // (big-endian).\n      if (buf.length <= 1 || (buf[buf.length - 2] & 0x80) === 0) {\n        throw new Error('non-minimally encoded script number');\n      }\n    }\n  }\n  return BN.fromSM(buf, {\n    endian: 'little'\n  });\n};\n\n/**\n * The corollary to the above, with the notable exception that we do not throw\n * an error if the output is larger than four bytes. (Which can happen if\n * performing a numerical operation that results in an overflow to more than 4\n * bytes).\n */\nBN.prototype.toScriptNumBuffer = function() {\n  return this.toSM({\n    endian: 'little'\n  });\n};\n\nBN.prototype.gt = function(b) {\n  return this.cmp(b) > 0;\n};\n\nBN.prototype.gte = function(b) {\n  return this.cmp(b) >= 0;\n};\n\nBN.prototype.lt = function(b) {\n  return this.cmp(b) < 0;\n};\n\nBN.trim = function(buf, natlen) {\n  return buf.slice(natlen - buf.length, buf.length);\n};\n\nBN.pad = function(buf, natlen, size) {\n  var rbuf = new Buffer(size);\n  for (var i = 0; i < buf.length; i++) {\n    rbuf[rbuf.length - 1 - i] = buf[buf.length - 1 - i];\n  }\n  for (i = 0; i < size - natlen; i++) {\n    rbuf[i] = 0;\n  }\n  return rbuf;\n};\n\nmodule.exports = BN;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}