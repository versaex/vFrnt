{"ast":null,"code":"'use strict';\n\nvar BN = require('./bn');\nvar BufferUtil = require('../util/buffer');\nvar ec = require('elliptic').curves.secp256k1;\nvar ecPoint = ec.curve.point.bind(ec.curve);\nvar ecPointFromX = ec.curve.pointFromX.bind(ec.curve);\n\n/**\n *\n * Instantiate a valid secp256k1 Point from the X and Y coordinates.\n *\n * @param {BN|String} x - The X coordinate\n * @param {BN|String} y - The Y coordinate\n * @link https://github.com/indutny/elliptic\n * @augments elliptic.curve.point\n * @throws {Error} A validation error if exists\n * @returns {Point} An instance of Point\n * @constructor\n */\nvar Point = function Point(x, y, isRed) {\n  var point = ecPoint(x, y, isRed);\n  point.validate();\n  return point;\n};\nPoint.prototype = Object.getPrototypeOf(ec.curve.point());\n\n/**\n *\n * Instantiate a valid secp256k1 Point from only the X coordinate\n *\n * @param {boolean} odd - If the Y coordinate is odd\n * @param {BN|String} x - The X coordinate\n * @throws {Error} A validation error if exists\n * @returns {Point} An instance of Point\n */\nPoint.fromX = function fromX(odd, x) {\n  var point = ecPointFromX(odd, x);\n  point.validate();\n  return point;\n};\n\n/**\n *\n * Will return a secp256k1 ECDSA base point.\n *\n * @link https://en.bitcoin.it/wiki/Secp256k1\n * @returns {Point} An instance of the base point.\n */\nPoint.getG = function getG() {\n  return ec.curve.g;\n};\n\n/**\n *\n * Will return the max of range of valid private keys as governed by the secp256k1 ECDSA standard.\n *\n * @link https://en.bitcoin.it/wiki/Private_key#Range_of_valid_ECDSA_private_keys\n * @returns {BN} A BN instance of the number of points on the curve\n */\nPoint.getN = function getN() {\n  return new BN(ec.curve.n.toArray());\n};\nPoint.prototype._getX = Point.prototype.getX;\n\n/**\n *\n * Will return the X coordinate of the Point\n *\n * @returns {BN} A BN instance of the X coordinate\n */\nPoint.prototype.getX = function getX() {\n  return new BN(this._getX().toArray());\n};\nPoint.prototype._getY = Point.prototype.getY;\n\n/**\n *\n * Will return the Y coordinate of the Point\n *\n * @returns {BN} A BN instance of the Y coordinate\n */\nPoint.prototype.getY = function getY() {\n  return new BN(this._getY().toArray());\n};\n\n/**\n *\n * Will determine if the point is valid\n *\n * @link https://www.iacr.org/archive/pkc2003/25670211/25670211.pdf\n * @param {Point} An instance of Point\n * @throws {Error} A validation error if exists\n * @returns {Point} An instance of the same Point\n */\nPoint.prototype.validate = function validate() {\n  if (this.isInfinity()) {\n    throw new Error('Point cannot be equal to Infinity');\n  }\n  if (this.getX().cmp(BN.Zero) === 0 || this.getY().cmp(BN.Zero) === 0) {\n    throw new Error('Invalid x,y value for curve, cannot equal 0.');\n  }\n  var p2 = ecPointFromX(this.getY().isOdd(), this.getX());\n  if (p2.y.cmp(this.y) !== 0) {\n    throw new Error('Invalid y value for curve.');\n  }\n  var xValidRange = this.getX().gt(BN.Minus1) && this.getX().lt(Point.getN());\n  var yValidRange = this.getY().gt(BN.Minus1) && this.getY().lt(Point.getN());\n  if (!xValidRange || !yValidRange) {\n    throw new Error('Point does not lie on the curve');\n  }\n\n  //todo: needs test case\n  if (!this.mul(Point.getN()).isInfinity()) {\n    throw new Error('Point times N must be infinity');\n  }\n  return this;\n};\nPoint.pointToCompressed = function pointToCompressed(point) {\n  var xbuf = point.getX().toBuffer({\n    size: 32\n  });\n  var ybuf = point.getY().toBuffer({\n    size: 32\n  });\n  var prefix;\n  var odd = ybuf[ybuf.length - 1] % 2;\n  if (odd) {\n    prefix = new Buffer([0x03]);\n  } else {\n    prefix = new Buffer([0x02]);\n  }\n  return BufferUtil.concat([prefix, xbuf]);\n};\nmodule.exports = Point;","map":{"version":3,"names":["BN","require","BufferUtil","ec","curves","secp256k1","ecPoint","curve","point","bind","ecPointFromX","pointFromX","Point","x","y","isRed","validate","prototype","Object","getPrototypeOf","fromX","odd","getG","g","getN","n","toArray","_getX","getX","_getY","getY","isInfinity","Error","cmp","Zero","p2","isOdd","xValidRange","gt","Minus1","lt","yValidRange","mul","pointToCompressed","xbuf","toBuffer","size","ybuf","prefix","length","Buffer","concat","module","exports"],"sources":["C:/Users/Elton/OneDrive/Desktop/baseapp-2024/node_modules/bitcoincashjs/src/crypto/point.js"],"sourcesContent":["'use strict';\n\nvar BN = require('./bn');\nvar BufferUtil = require('../util/buffer');\nvar ec = require('elliptic').curves.secp256k1;\nvar ecPoint = ec.curve.point.bind(ec.curve);\nvar ecPointFromX = ec.curve.pointFromX.bind(ec.curve);\n\n/**\n *\n * Instantiate a valid secp256k1 Point from the X and Y coordinates.\n *\n * @param {BN|String} x - The X coordinate\n * @param {BN|String} y - The Y coordinate\n * @link https://github.com/indutny/elliptic\n * @augments elliptic.curve.point\n * @throws {Error} A validation error if exists\n * @returns {Point} An instance of Point\n * @constructor\n */\nvar Point = function Point(x, y, isRed) {\n  var point = ecPoint(x, y, isRed);\n  point.validate();\n  return point;\n};\n\nPoint.prototype = Object.getPrototypeOf(ec.curve.point());\n\n/**\n *\n * Instantiate a valid secp256k1 Point from only the X coordinate\n *\n * @param {boolean} odd - If the Y coordinate is odd\n * @param {BN|String} x - The X coordinate\n * @throws {Error} A validation error if exists\n * @returns {Point} An instance of Point\n */\nPoint.fromX = function fromX(odd, x){\n  var point = ecPointFromX(odd, x);\n  point.validate();\n  return point;\n};\n\n/**\n *\n * Will return a secp256k1 ECDSA base point.\n *\n * @link https://en.bitcoin.it/wiki/Secp256k1\n * @returns {Point} An instance of the base point.\n */\nPoint.getG = function getG() {\n  return ec.curve.g;\n};\n\n/**\n *\n * Will return the max of range of valid private keys as governed by the secp256k1 ECDSA standard.\n *\n * @link https://en.bitcoin.it/wiki/Private_key#Range_of_valid_ECDSA_private_keys\n * @returns {BN} A BN instance of the number of points on the curve\n */\nPoint.getN = function getN() {\n  return new BN(ec.curve.n.toArray());\n};\n\nPoint.prototype._getX = Point.prototype.getX;\n\n/**\n *\n * Will return the X coordinate of the Point\n *\n * @returns {BN} A BN instance of the X coordinate\n */\nPoint.prototype.getX = function getX() {\n  return new BN(this._getX().toArray());\n};\n\nPoint.prototype._getY = Point.prototype.getY;\n\n/**\n *\n * Will return the Y coordinate of the Point\n *\n * @returns {BN} A BN instance of the Y coordinate\n */\nPoint.prototype.getY = function getY() {\n  return new BN(this._getY().toArray());\n};\n\n/**\n *\n * Will determine if the point is valid\n *\n * @link https://www.iacr.org/archive/pkc2003/25670211/25670211.pdf\n * @param {Point} An instance of Point\n * @throws {Error} A validation error if exists\n * @returns {Point} An instance of the same Point\n */\nPoint.prototype.validate = function validate() {\n\n  if (this.isInfinity()){\n    throw new Error('Point cannot be equal to Infinity');\n  }\n\n  if (this.getX().cmp(BN.Zero) === 0 || this.getY().cmp(BN.Zero) === 0){\n    throw new Error('Invalid x,y value for curve, cannot equal 0.');\n  }\n\n  var p2 = ecPointFromX(this.getY().isOdd(), this.getX());\n\n  if (p2.y.cmp(this.y) !== 0) {\n    throw new Error('Invalid y value for curve.');\n  }\n\n  var xValidRange = (this.getX().gt(BN.Minus1) && this.getX().lt(Point.getN()));\n  var yValidRange = (this.getY().gt(BN.Minus1) && this.getY().lt(Point.getN()));\n\n  if ( !xValidRange || !yValidRange ) {\n    throw new Error('Point does not lie on the curve');\n  }\n\n  //todo: needs test case\n  if (!(this.mul(Point.getN()).isInfinity())) {\n    throw new Error('Point times N must be infinity');\n  }\n\n  return this;\n\n};\n\nPoint.pointToCompressed = function pointToCompressed(point) {\n  var xbuf = point.getX().toBuffer({size: 32});\n  var ybuf = point.getY().toBuffer({size: 32});\n\n  var prefix;\n  var odd = ybuf[ybuf.length - 1] % 2;\n  if (odd) {\n    prefix = new Buffer([0x03]);\n  } else {\n    prefix = new Buffer([0x02]);\n  }\n  return BufferUtil.concat([prefix, xbuf]);\n};\n\nmodule.exports = Point;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}