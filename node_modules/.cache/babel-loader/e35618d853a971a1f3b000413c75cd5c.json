{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\nvar Script = require('./script');\nvar Opcode = require('../opcode');\nvar BN = require('../crypto/bn');\nvar Hash = require('../crypto/hash');\nvar Signature = require('../crypto/signature');\nvar PublicKey = require('../publickey');\n\n/**\n * Bitcoin transactions contain scripts. Each input has a script called the\n * scriptSig, and each output has a script called the scriptPubkey. To validate\n * an input, the input's script is concatenated with the referenced output script,\n * and the result is executed. If at the end of execution the stack contains a\n * \"true\" value, then the transaction is valid.\n *\n * The primary way to use this class is via the verify function.\n * e.g., Interpreter().verify( ... );\n */\nvar Interpreter = function Interpreter(obj) {\n  if (!(this instanceof Interpreter)) {\n    return new Interpreter(obj);\n  }\n  if (obj) {\n    this.initialize();\n    this.set(obj);\n  } else {\n    this.initialize();\n  }\n};\n\n/**\n * Verifies a Script by executing it and returns true if it is valid.\n * This function needs to be provided with the scriptSig and the scriptPubkey\n * separately.\n * @param {Script} scriptSig - the script's first part (corresponding to the tx input)\n * @param {Script} scriptPubkey - the script's last part (corresponding to the tx output)\n * @param {Transaction=} tx - the Transaction containing the scriptSig in one input (used\n *    to check signature validity for some opcodes like OP_CHECKSIG)\n * @param {number} nin - index of the transaction input containing the scriptSig verified.\n * @param {number} flags - evaluation flags. See Interpreter.SCRIPT_* constants\n *\n * Translated from bitcoind's VerifyScript\n */\nInterpreter.prototype.verify = function (scriptSig, scriptPubkey, tx, nin, flags) {\n  var Transaction = require('../transaction');\n  if (_.isUndefined(tx)) {\n    tx = new Transaction();\n  }\n  if (_.isUndefined(nin)) {\n    nin = 0;\n  }\n  if (_.isUndefined(flags)) {\n    flags = 0;\n  }\n  this.set({\n    script: scriptSig,\n    tx: tx,\n    nin: nin,\n    flags: flags\n  });\n  var stackCopy;\n  if ((flags & Interpreter.SCRIPT_VERIFY_SIGPUSHONLY) !== 0 && !scriptSig.isPushOnly()) {\n    this.errstr = 'SCRIPT_ERR_SIG_PUSHONLY';\n    return false;\n  }\n\n  // evaluate scriptSig\n  if (!this.evaluate()) {\n    return false;\n  }\n  if (flags & Interpreter.SCRIPT_VERIFY_P2SH) {\n    stackCopy = this.stack.slice();\n  }\n  var stack = this.stack;\n  this.initialize();\n  this.set({\n    script: scriptPubkey,\n    stack: stack,\n    tx: tx,\n    nin: nin,\n    flags: flags\n  });\n\n  // evaluate scriptPubkey\n  if (!this.evaluate()) {\n    return false;\n  }\n  if (this.stack.length === 0) {\n    this.errstr = 'SCRIPT_ERR_EVAL_FALSE_NO_RESULT';\n    return false;\n  }\n  var buf = this.stack[this.stack.length - 1];\n  if (!Interpreter.castToBool(buf)) {\n    this.errstr = 'SCRIPT_ERR_EVAL_FALSE_IN_STACK';\n    return false;\n  }\n\n  // Additional validation for spend-to-script-hash transactions:\n  if (flags & Interpreter.SCRIPT_VERIFY_P2SH && scriptPubkey.isScriptHashOut()) {\n    // scriptSig must be literals-only or validation fails\n    if (!scriptSig.isPushOnly()) {\n      this.errstr = 'SCRIPT_ERR_SIG_PUSHONLY';\n      return false;\n    }\n\n    // stackCopy cannot be empty here, because if it was the\n    // P2SH  HASH <> EQUAL  scriptPubKey would be evaluated with\n    // an empty stack and the EvalScript above would return false.\n    if (stackCopy.length === 0) {\n      throw new Error('internal error - stack copy empty');\n    }\n    var redeemScriptSerialized = stackCopy[stackCopy.length - 1];\n    var redeemScript = Script.fromBuffer(redeemScriptSerialized);\n    stackCopy.pop();\n    this.initialize();\n    this.set({\n      script: redeemScript,\n      stack: stackCopy,\n      tx: tx,\n      nin: nin,\n      flags: flags\n    });\n\n    // evaluate redeemScript\n    if (!this.evaluate()) {\n      return false;\n    }\n    if (stackCopy.length === 0) {\n      this.errstr = 'SCRIPT_ERR_EVAL_FALSE_NO_P2SH_STACK';\n      return false;\n    }\n    if (!Interpreter.castToBool(stackCopy[stackCopy.length - 1])) {\n      this.errstr = 'SCRIPT_ERR_EVAL_FALSE_IN_P2SH_STACK';\n      return false;\n    } else {\n      return true;\n    }\n  }\n  return true;\n};\nmodule.exports = Interpreter;\nInterpreter.prototype.initialize = function (obj) {\n  this.stack = [];\n  this.altstack = [];\n  this.pc = 0;\n  this.pbegincodehash = 0;\n  this.nOpCount = 0;\n  this.vfExec = [];\n  this.errstr = '';\n  this.flags = 0;\n};\nInterpreter.prototype.set = function (obj) {\n  this.script = obj.script || this.script;\n  this.tx = obj.tx || this.tx;\n  this.nin = typeof obj.nin !== 'undefined' ? obj.nin : this.nin;\n  this.stack = obj.stack || this.stack;\n  this.altstack = obj.altack || this.altstack;\n  this.pc = typeof obj.pc !== 'undefined' ? obj.pc : this.pc;\n  this.pbegincodehash = typeof obj.pbegincodehash !== 'undefined' ? obj.pbegincodehash : this.pbegincodehash;\n  this.nOpCount = typeof obj.nOpCount !== 'undefined' ? obj.nOpCount : this.nOpCount;\n  this.vfExec = obj.vfExec || this.vfExec;\n  this.errstr = obj.errstr || this.errstr;\n  this.flags = typeof obj.flags !== 'undefined' ? obj.flags : this.flags;\n};\nInterpreter.true = new Buffer([1]);\nInterpreter.false = new Buffer([]);\nInterpreter.MAX_SCRIPT_ELEMENT_SIZE = 520;\nInterpreter.LOCKTIME_THRESHOLD = 500000000;\nInterpreter.LOCKTIME_THRESHOLD_BN = new BN(Interpreter.LOCKTIME_THRESHOLD);\n\n// flags taken from bitcoind\n// bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104\nInterpreter.SCRIPT_VERIFY_NONE = 0;\n\n// Evaluate P2SH subscripts (softfork safe, BIP16).\nInterpreter.SCRIPT_VERIFY_P2SH = 1 << 0;\n\n// Passing a non-strict-DER signature or one with undefined hashtype to a checksig operation causes script failure.\n// Passing a pubkey that is not (0x04 + 64 bytes) or (0x02 or 0x03 + 32 bytes) to checksig causes that pubkey to be\n// skipped (not softfork safe: this flag can widen the validity of OP_CHECKSIG OP_NOT).\nInterpreter.SCRIPT_VERIFY_STRICTENC = 1 << 1;\n\n// Passing a non-strict-DER signature to a checksig operation causes script failure (softfork safe, BIP62 rule 1)\nInterpreter.SCRIPT_VERIFY_DERSIG = 1 << 2;\n\n// Passing a non-strict-DER signature or one with S > order/2 to a checksig operation causes script failure\n// (softfork safe, BIP62 rule 5).\nInterpreter.SCRIPT_VERIFY_LOW_S = 1 << 3;\n\n// verify dummy stack item consumed by CHECKMULTISIG is of zero-length (softfork safe, BIP62 rule 7).\nInterpreter.SCRIPT_VERIFY_NULLDUMMY = 1 << 4;\n\n// Using a non-push operator in the scriptSig causes script failure (softfork safe, BIP62 rule 2).\nInterpreter.SCRIPT_VERIFY_SIGPUSHONLY = 1 << 5;\n\n// Require minimal encodings for all push operations (OP_0... OP_16, OP_1NEGATE where possible, direct\n// pushes up to 75 bytes, OP_PUSHDATA up to 255 bytes, OP_PUSHDATA2 for anything larger). Evaluating\n// any other push causes the script to fail (BIP62 rule 3).\n// In addition, whenever a stack element is interpreted as a number, it must be of minimal length (BIP62 rule 4).\n// (softfork safe)\nInterpreter.SCRIPT_VERIFY_MINIMALDATA = 1 << 6;\n\n// Discourage use of NOPs reserved for upgrades (NOP1-10)\n//\n// Provided so that nodes can avoid accepting or mining transactions\n// containing executed NOP's whose meaning may change after a soft-fork,\n// thus rendering the script invalid; with this flag set executing\n// discouraged NOPs fails the script. This verification flag will never be\n// a mandatory flag applied to scripts in a block. NOPs that are not\n// executed, e.g.  within an unexecuted IF ENDIF block, are *not* rejected.\nInterpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS = 1 << 7;\n\n// CLTV See BIP65 for details.\nInterpreter.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY = 1 << 9;\nInterpreter.castToBool = function (buf) {\n  for (var i = 0; i < buf.length; i++) {\n    if (buf[i] !== 0) {\n      // can be negative zero\n      if (i === buf.length - 1 && buf[i] === 0x80) {\n        return false;\n      }\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Translated from bitcoind's CheckSignatureEncoding\n */\nInterpreter.prototype.checkSignatureEncoding = function (buf) {\n  var sig;\n  if ((this.flags & (Interpreter.SCRIPT_VERIFY_DERSIG | Interpreter.SCRIPT_VERIFY_LOW_S | Interpreter.SCRIPT_VERIFY_STRICTENC)) !== 0 && !Signature.isTxDER(buf)) {\n    this.errstr = 'SCRIPT_ERR_SIG_DER_INVALID_FORMAT';\n    return false;\n  } else if ((this.flags & Interpreter.SCRIPT_VERIFY_LOW_S) !== 0) {\n    sig = Signature.fromTxFormat(buf);\n    if (!sig.hasLowS()) {\n      this.errstr = 'SCRIPT_ERR_SIG_DER_HIGH_S';\n      return false;\n    }\n  } else if ((this.flags & Interpreter.SCRIPT_VERIFY_STRICTENC) !== 0) {\n    sig = Signature.fromTxFormat(buf);\n    if (!sig.hasDefinedHashtype()) {\n      this.errstr = 'SCRIPT_ERR_SIG_HASHTYPE';\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Translated from bitcoind's CheckPubKeyEncoding\n */\nInterpreter.prototype.checkPubkeyEncoding = function (buf) {\n  if ((this.flags & Interpreter.SCRIPT_VERIFY_STRICTENC) !== 0 && !PublicKey.isValid(buf)) {\n    this.errstr = 'SCRIPT_ERR_PUBKEYTYPE';\n    return false;\n  }\n  return true;\n};\n\n/**\n * Based on bitcoind's EvalScript function, with the inner loop moved to\n * Interpreter.prototype.step()\n * bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104\n */\nInterpreter.prototype.evaluate = function () {\n  if (this.script.toBuffer().length > 10000) {\n    this.errstr = 'SCRIPT_ERR_SCRIPT_SIZE';\n    return false;\n  }\n  try {\n    while (this.pc < this.script.chunks.length) {\n      var fSuccess = this.step();\n      if (!fSuccess) {\n        return false;\n      }\n    }\n\n    // Size limits\n    if (this.stack.length + this.altstack.length > 1000) {\n      this.errstr = 'SCRIPT_ERR_STACK_SIZE';\n      return false;\n    }\n  } catch (e) {\n    this.errstr = 'SCRIPT_ERR_UNKNOWN_ERROR: ' + e;\n    return false;\n  }\n  if (this.vfExec.length > 0) {\n    this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n    return false;\n  }\n  return true;\n};\n\n/**\n * Checks a locktime parameter with the transaction's locktime.\n * There are two times of nLockTime: lock-by-blockheight and lock-by-blocktime,\n * distinguished by whether nLockTime < LOCKTIME_THRESHOLD = 500000000\n *\n * See the corresponding code on bitcoin core:\n * https://github.com/bitcoin/bitcoin/blob/ffd75adce01a78b3461b3ff05bcc2b530a9ce994/src/script/interpreter.cpp#L1129\n *\n * @param {BN} nLockTime the locktime read from the script\n * @return {boolean} true if the transaction's locktime is less than or equal to\n *                   the transaction's locktime\n */\nInterpreter.prototype.checkLockTime = function (nLockTime) {\n  // We want to compare apples to apples, so fail the script\n  // unless the type of nLockTime being tested is the same as\n  // the nLockTime in the transaction.\n  if (!(this.tx.nLockTime < Interpreter.LOCKTIME_THRESHOLD && nLockTime.lt(Interpreter.LOCKTIME_THRESHOLD_BN) || this.tx.nLockTime >= Interpreter.LOCKTIME_THRESHOLD && nLockTime.gte(Interpreter.LOCKTIME_THRESHOLD_BN))) {\n    return false;\n  }\n\n  // Now that we know we're comparing apples-to-apples, the\n  // comparison is a simple numeric one.\n  if (nLockTime.gt(new BN(this.tx.nLockTime))) {\n    return false;\n  }\n\n  // Finally the nLockTime feature can be disabled and thus\n  // CHECKLOCKTIMEVERIFY bypassed if every txin has been\n  // finalized by setting nSequence to maxint. The\n  // transaction would be allowed into the blockchain, making\n  // the opcode ineffective.\n  //\n  // Testing if this vin is not final is sufficient to\n  // prevent this condition. Alternatively we could test all\n  // inputs, but testing just this input minimizes the data\n  // required to prove correct CHECKLOCKTIMEVERIFY execution.\n  if (!this.tx.inputs[this.nin].isFinal()) {\n    return false;\n  }\n  return true;\n};\n\n/** \n * Based on the inner loop of bitcoind's EvalScript function\n * bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104\n */\nInterpreter.prototype.step = function () {\n  var fRequireMinimal = (this.flags & Interpreter.SCRIPT_VERIFY_MINIMALDATA) !== 0;\n\n  //bool fExec = !count(vfExec.begin(), vfExec.end(), false);\n  var fExec = this.vfExec.indexOf(false) === -1;\n  var buf, buf1, buf2, spliced, n, x1, x2, bn, bn1, bn2, bufSig, bufPubkey, subscript;\n  var sig, pubkey;\n  var fValue, fSuccess;\n\n  // Read instruction\n  var chunk = this.script.chunks[this.pc];\n  this.pc++;\n  var opcodenum = chunk.opcodenum;\n  if (_.isUndefined(opcodenum)) {\n    this.errstr = 'SCRIPT_ERR_UNDEFINED_OPCODE';\n    return false;\n  }\n  if (chunk.buf && chunk.buf.length > Interpreter.MAX_SCRIPT_ELEMENT_SIZE) {\n    this.errstr = 'SCRIPT_ERR_PUSH_SIZE';\n    return false;\n  }\n\n  // Note how Opcode.OP_RESERVED does not count towards the opcode limit.\n  if (opcodenum > Opcode.OP_16 && ++this.nOpCount > 201) {\n    this.errstr = 'SCRIPT_ERR_OP_COUNT';\n    return false;\n  }\n  if (opcodenum === Opcode.OP_CAT || opcodenum === Opcode.OP_SUBSTR || opcodenum === Opcode.OP_LEFT || opcodenum === Opcode.OP_RIGHT || opcodenum === Opcode.OP_INVERT || opcodenum === Opcode.OP_AND || opcodenum === Opcode.OP_OR || opcodenum === Opcode.OP_XOR || opcodenum === Opcode.OP_2MUL || opcodenum === Opcode.OP_2DIV || opcodenum === Opcode.OP_MUL || opcodenum === Opcode.OP_DIV || opcodenum === Opcode.OP_MOD || opcodenum === Opcode.OP_LSHIFT || opcodenum === Opcode.OP_RSHIFT) {\n    this.errstr = 'SCRIPT_ERR_DISABLED_OPCODE';\n    return false;\n  }\n  if (fExec && 0 <= opcodenum && opcodenum <= Opcode.OP_PUSHDATA4) {\n    if (fRequireMinimal && !this.script.checkMinimalPush(this.pc - 1)) {\n      this.errstr = 'SCRIPT_ERR_MINIMALDATA';\n      return false;\n    }\n    if (!chunk.buf) {\n      this.stack.push(Interpreter.false);\n    } else if (chunk.len !== chunk.buf.length) {\n      throw new Error('Length of push value not equal to length of data');\n    } else {\n      this.stack.push(chunk.buf);\n    }\n  } else if (fExec || Opcode.OP_IF <= opcodenum && opcodenum <= Opcode.OP_ENDIF) {\n    switch (opcodenum) {\n      // Push value\n      case Opcode.OP_1NEGATE:\n      case Opcode.OP_1:\n      case Opcode.OP_2:\n      case Opcode.OP_3:\n      case Opcode.OP_4:\n      case Opcode.OP_5:\n      case Opcode.OP_6:\n      case Opcode.OP_7:\n      case Opcode.OP_8:\n      case Opcode.OP_9:\n      case Opcode.OP_10:\n      case Opcode.OP_11:\n      case Opcode.OP_12:\n      case Opcode.OP_13:\n      case Opcode.OP_14:\n      case Opcode.OP_15:\n      case Opcode.OP_16:\n        {\n          // ( -- value)\n          // ScriptNum bn((int)opcode - (int)(Opcode.OP_1 - 1));\n          n = opcodenum - (Opcode.OP_1 - 1);\n          buf = new BN(n).toScriptNumBuffer();\n          this.stack.push(buf);\n          // The result of these opcodes should always be the minimal way to push the data\n          // they push, so no need for a CheckMinimalPush here.\n        }\n\n        break;\n\n      //\n      // Control\n      //\n      case Opcode.OP_NOP:\n        break;\n      case Opcode.OP_NOP2:\n      case Opcode.OP_CHECKLOCKTIMEVERIFY:\n        if (!(this.flags & Interpreter.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY)) {\n          // not enabled; treat as a NOP2\n          if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {\n            this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS';\n            return false;\n          }\n          break;\n        }\n        if (this.stack.length < 1) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n        // Note that elsewhere numeric opcodes are limited to\n        // operands in the range -2**31+1 to 2**31-1, however it is\n        // legal for opcodes to produce results exceeding that\n        // range. This limitation is implemented by CScriptNum's\n        // default 4-byte limit.\n        //\n        // If we kept to that limit we'd have a year 2038 problem,\n        // even though the nLockTime field in transactions\n        // themselves is uint32 which only becomes meaningless\n        // after the year 2106.\n        //\n        // Thus as a special case we tell CScriptNum to accept up\n        // to 5-byte bignums, which are good until 2**39-1, well\n        // beyond the 2**32-1 limit of the nLockTime field itself.\n        var nLockTime = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal, 5);\n\n        // In the rare event that the argument may be < 0 due to\n        // some arithmetic being done first, you can always use\n        // 0 MAX CHECKLOCKTIMEVERIFY.\n        if (nLockTime.lt(new BN(0))) {\n          this.errstr = 'SCRIPT_ERR_NEGATIVE_LOCKTIME';\n          return false;\n        }\n\n        // Actually compare the specified lock time with the transaction.\n        if (!this.checkLockTime(nLockTime)) {\n          this.errstr = 'SCRIPT_ERR_UNSATISFIED_LOCKTIME';\n          return false;\n        }\n        break;\n      case Opcode.OP_NOP1:\n      case Opcode.OP_NOP3:\n      case Opcode.OP_NOP4:\n      case Opcode.OP_NOP5:\n      case Opcode.OP_NOP6:\n      case Opcode.OP_NOP7:\n      case Opcode.OP_NOP8:\n      case Opcode.OP_NOP9:\n      case Opcode.OP_NOP10:\n        {\n          if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {\n            this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS';\n            return false;\n          }\n        }\n        break;\n      case Opcode.OP_IF:\n      case Opcode.OP_NOTIF:\n        {\n          // <expression> if [statements] [else [statements]] endif\n          // bool fValue = false;\n          fValue = false;\n          if (fExec) {\n            if (this.stack.length < 1) {\n              this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n              return false;\n            }\n            buf = this.stack.pop();\n            fValue = Interpreter.castToBool(buf);\n            if (opcodenum === Opcode.OP_NOTIF) {\n              fValue = !fValue;\n            }\n          }\n          this.vfExec.push(fValue);\n        }\n        break;\n      case Opcode.OP_ELSE:\n        {\n          if (this.vfExec.length === 0) {\n            this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n            return false;\n          }\n          this.vfExec[this.vfExec.length - 1] = !this.vfExec[this.vfExec.length - 1];\n        }\n        break;\n      case Opcode.OP_ENDIF:\n        {\n          if (this.vfExec.length === 0) {\n            this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n            return false;\n          }\n          this.vfExec.pop();\n        }\n        break;\n      case Opcode.OP_VERIFY:\n        {\n          // (true -- ) or\n          // (false -- false) and return\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf = this.stack[this.stack.length - 1];\n          fValue = Interpreter.castToBool(buf);\n          if (fValue) {\n            this.stack.pop();\n          } else {\n            this.errstr = 'SCRIPT_ERR_VERIFY';\n            return false;\n          }\n        }\n        break;\n      case Opcode.OP_RETURN:\n        {\n          this.errstr = 'SCRIPT_ERR_OP_RETURN';\n          return false;\n        }\n        break;\n\n      //\n      // Stack ops\n      //\n      case Opcode.OP_TOALTSTACK:\n        {\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.altstack.push(this.stack.pop());\n        }\n        break;\n      case Opcode.OP_FROMALTSTACK:\n        {\n          if (this.altstack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_ALTSTACK_OPERATION';\n            return false;\n          }\n          this.stack.push(this.altstack.pop());\n        }\n        break;\n      case Opcode.OP_2DROP:\n        {\n          // (x1 x2 -- )\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.stack.pop();\n          this.stack.pop();\n        }\n        break;\n      case Opcode.OP_2DUP:\n        {\n          // (x1 x2 -- x1 x2 x1 x2)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf1 = this.stack[this.stack.length - 2];\n          buf2 = this.stack[this.stack.length - 1];\n          this.stack.push(buf1);\n          this.stack.push(buf2);\n        }\n        break;\n      case Opcode.OP_3DUP:\n        {\n          // (x1 x2 x3 -- x1 x2 x3 x1 x2 x3)\n          if (this.stack.length < 3) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf1 = this.stack[this.stack.length - 3];\n          buf2 = this.stack[this.stack.length - 2];\n          var buf3 = this.stack[this.stack.length - 1];\n          this.stack.push(buf1);\n          this.stack.push(buf2);\n          this.stack.push(buf3);\n        }\n        break;\n      case Opcode.OP_2OVER:\n        {\n          // (x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2)\n          if (this.stack.length < 4) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf1 = this.stack[this.stack.length - 4];\n          buf2 = this.stack[this.stack.length - 3];\n          this.stack.push(buf1);\n          this.stack.push(buf2);\n        }\n        break;\n      case Opcode.OP_2ROT:\n        {\n          // (x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2)\n          if (this.stack.length < 6) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          spliced = this.stack.splice(this.stack.length - 6, 2);\n          this.stack.push(spliced[0]);\n          this.stack.push(spliced[1]);\n        }\n        break;\n      case Opcode.OP_2SWAP:\n        {\n          // (x1 x2 x3 x4 -- x3 x4 x1 x2)\n          if (this.stack.length < 4) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          spliced = this.stack.splice(this.stack.length - 4, 2);\n          this.stack.push(spliced[0]);\n          this.stack.push(spliced[1]);\n        }\n        break;\n      case Opcode.OP_IFDUP:\n        {\n          // (x - 0 | x x)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf = this.stack[this.stack.length - 1];\n          fValue = Interpreter.castToBool(buf);\n          if (fValue) {\n            this.stack.push(buf);\n          }\n        }\n        break;\n      case Opcode.OP_DEPTH:\n        {\n          // -- stacksize\n          buf = new BN(this.stack.length).toScriptNumBuffer();\n          this.stack.push(buf);\n        }\n        break;\n      case Opcode.OP_DROP:\n        {\n          // (x -- )\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.stack.pop();\n        }\n        break;\n      case Opcode.OP_DUP:\n        {\n          // (x -- x x)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.stack.push(this.stack[this.stack.length - 1]);\n        }\n        break;\n      case Opcode.OP_NIP:\n        {\n          // (x1 x2 -- x2)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.stack.splice(this.stack.length - 2, 1);\n        }\n        break;\n      case Opcode.OP_OVER:\n        {\n          // (x1 x2 -- x1 x2 x1)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.stack.push(this.stack[this.stack.length - 2]);\n        }\n        break;\n      case Opcode.OP_PICK:\n      case Opcode.OP_ROLL:\n        {\n          // (xn ... x2 x1 x0 n - xn ... x2 x1 x0 xn)\n          // (xn ... x2 x1 x0 n - ... x2 x1 x0 xn)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf = this.stack[this.stack.length - 1];\n          bn = BN.fromScriptNumBuffer(buf, fRequireMinimal);\n          n = bn.toNumber();\n          this.stack.pop();\n          if (n < 0 || n >= this.stack.length) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf = this.stack[this.stack.length - n - 1];\n          if (opcodenum === Opcode.OP_ROLL) {\n            this.stack.splice(this.stack.length - n - 1, 1);\n          }\n          this.stack.push(buf);\n        }\n        break;\n      case Opcode.OP_ROT:\n        {\n          // (x1 x2 x3 -- x2 x3 x1)\n          //  x2 x1 x3  after first swap\n          //  x2 x3 x1  after second swap\n          if (this.stack.length < 3) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          x1 = this.stack[this.stack.length - 3];\n          x2 = this.stack[this.stack.length - 2];\n          var x3 = this.stack[this.stack.length - 1];\n          this.stack[this.stack.length - 3] = x2;\n          this.stack[this.stack.length - 2] = x3;\n          this.stack[this.stack.length - 1] = x1;\n        }\n        break;\n      case Opcode.OP_SWAP:\n        {\n          // (x1 x2 -- x2 x1)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          x1 = this.stack[this.stack.length - 2];\n          x2 = this.stack[this.stack.length - 1];\n          this.stack[this.stack.length - 2] = x2;\n          this.stack[this.stack.length - 1] = x1;\n        }\n        break;\n      case Opcode.OP_TUCK:\n        {\n          // (x1 x2 -- x2 x1 x2)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.stack.splice(this.stack.length - 2, 0, this.stack[this.stack.length - 1]);\n        }\n        break;\n      case Opcode.OP_SIZE:\n        {\n          // (in -- in size)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          bn = new BN(this.stack[this.stack.length - 1].length);\n          this.stack.push(bn.toScriptNumBuffer());\n        }\n        break;\n\n      //\n      // Bitwise logic\n      //\n      case Opcode.OP_EQUAL:\n      case Opcode.OP_EQUALVERIFY:\n        //case Opcode.OP_NOTEQUAL: // use Opcode.OP_NUMNOTEQUAL\n        {\n          // (x1 x2 - bool)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf1 = this.stack[this.stack.length - 2];\n          buf2 = this.stack[this.stack.length - 1];\n          var fEqual = buf1.toString('hex') === buf2.toString('hex');\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.push(fEqual ? Interpreter.true : Interpreter.false);\n          if (opcodenum === Opcode.OP_EQUALVERIFY) {\n            if (fEqual) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_EQUALVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n\n      //\n      // Numeric\n      //\n      case Opcode.OP_1ADD:\n      case Opcode.OP_1SUB:\n      case Opcode.OP_NEGATE:\n      case Opcode.OP_ABS:\n      case Opcode.OP_NOT:\n      case Opcode.OP_0NOTEQUAL:\n        {\n          // (in -- out)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf = this.stack[this.stack.length - 1];\n          bn = BN.fromScriptNumBuffer(buf, fRequireMinimal);\n          switch (opcodenum) {\n            case Opcode.OP_1ADD:\n              bn = bn.add(BN.One);\n              break;\n            case Opcode.OP_1SUB:\n              bn = bn.sub(BN.One);\n              break;\n            case Opcode.OP_NEGATE:\n              bn = bn.neg();\n              break;\n            case Opcode.OP_ABS:\n              if (bn.cmp(BN.Zero) < 0) {\n                bn = bn.neg();\n              }\n              break;\n            case Opcode.OP_NOT:\n              bn = new BN((bn.cmp(BN.Zero) === 0) + 0);\n              break;\n            case Opcode.OP_0NOTEQUAL:\n              bn = new BN((bn.cmp(BN.Zero) !== 0) + 0);\n              break;\n            //default:      assert(!'invalid opcode'); break; // TODO: does this ever occur?\n          }\n\n          this.stack.pop();\n          this.stack.push(bn.toScriptNumBuffer());\n        }\n        break;\n      case Opcode.OP_ADD:\n      case Opcode.OP_SUB:\n      case Opcode.OP_BOOLAND:\n      case Opcode.OP_BOOLOR:\n      case Opcode.OP_NUMEQUAL:\n      case Opcode.OP_NUMEQUALVERIFY:\n      case Opcode.OP_NUMNOTEQUAL:\n      case Opcode.OP_LESSTHAN:\n      case Opcode.OP_GREATERTHAN:\n      case Opcode.OP_LESSTHANOREQUAL:\n      case Opcode.OP_GREATERTHANOREQUAL:\n      case Opcode.OP_MIN:\n      case Opcode.OP_MAX:\n        {\n          // (x1 x2 -- out)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          bn1 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 2], fRequireMinimal);\n          bn2 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal);\n          bn = new BN(0);\n          switch (opcodenum) {\n            case Opcode.OP_ADD:\n              bn = bn1.add(bn2);\n              break;\n            case Opcode.OP_SUB:\n              bn = bn1.sub(bn2);\n              break;\n\n            // case Opcode.OP_BOOLAND:       bn = (bn1 != bnZero && bn2 != bnZero); break;\n            case Opcode.OP_BOOLAND:\n              bn = new BN((bn1.cmp(BN.Zero) !== 0 && bn2.cmp(BN.Zero) !== 0) + 0);\n              break;\n            // case Opcode.OP_BOOLOR:        bn = (bn1 != bnZero || bn2 != bnZero); break;\n            case Opcode.OP_BOOLOR:\n              bn = new BN((bn1.cmp(BN.Zero) !== 0 || bn2.cmp(BN.Zero) !== 0) + 0);\n              break;\n            // case Opcode.OP_NUMEQUAL:      bn = (bn1 == bn2); break;\n            case Opcode.OP_NUMEQUAL:\n              bn = new BN((bn1.cmp(bn2) === 0) + 0);\n              break;\n            // case Opcode.OP_NUMEQUALVERIFY:    bn = (bn1 == bn2); break;\n            case Opcode.OP_NUMEQUALVERIFY:\n              bn = new BN((bn1.cmp(bn2) === 0) + 0);\n              break;\n            // case Opcode.OP_NUMNOTEQUAL:     bn = (bn1 != bn2); break;\n            case Opcode.OP_NUMNOTEQUAL:\n              bn = new BN((bn1.cmp(bn2) !== 0) + 0);\n              break;\n            // case Opcode.OP_LESSTHAN:      bn = (bn1 < bn2); break;\n            case Opcode.OP_LESSTHAN:\n              bn = new BN((bn1.cmp(bn2) < 0) + 0);\n              break;\n            // case Opcode.OP_GREATERTHAN:     bn = (bn1 > bn2); break;\n            case Opcode.OP_GREATERTHAN:\n              bn = new BN((bn1.cmp(bn2) > 0) + 0);\n              break;\n            // case Opcode.OP_LESSTHANOREQUAL:   bn = (bn1 <= bn2); break;\n            case Opcode.OP_LESSTHANOREQUAL:\n              bn = new BN((bn1.cmp(bn2) <= 0) + 0);\n              break;\n            // case Opcode.OP_GREATERTHANOREQUAL:  bn = (bn1 >= bn2); break;\n            case Opcode.OP_GREATERTHANOREQUAL:\n              bn = new BN((bn1.cmp(bn2) >= 0) + 0);\n              break;\n            case Opcode.OP_MIN:\n              bn = bn1.cmp(bn2) < 0 ? bn1 : bn2;\n              break;\n            case Opcode.OP_MAX:\n              bn = bn1.cmp(bn2) > 0 ? bn1 : bn2;\n              break;\n            // default:           assert(!'invalid opcode'); break; //TODO: does this ever occur?\n          }\n\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.push(bn.toScriptNumBuffer());\n          if (opcodenum === Opcode.OP_NUMEQUALVERIFY) {\n            // if (CastToBool(stacktop(-1)))\n            if (Interpreter.castToBool(this.stack[this.stack.length - 1])) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_NUMEQUALVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n      case Opcode.OP_WITHIN:\n        {\n          // (x min max -- out)\n          if (this.stack.length < 3) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          bn1 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 3], fRequireMinimal);\n          bn2 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 2], fRequireMinimal);\n          var bn3 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal);\n          //bool fValue = (bn2 <= bn1 && bn1 < bn3);\n          fValue = bn2.cmp(bn1) <= 0 && bn1.cmp(bn3) < 0;\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.push(fValue ? Interpreter.true : Interpreter.false);\n        }\n        break;\n\n      //\n      // Crypto\n      //\n      case Opcode.OP_RIPEMD160:\n      case Opcode.OP_SHA1:\n      case Opcode.OP_SHA256:\n      case Opcode.OP_HASH160:\n      case Opcode.OP_HASH256:\n        {\n          // (in -- hash)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf = this.stack[this.stack.length - 1];\n          //valtype vchHash((opcode == Opcode.OP_RIPEMD160 ||\n          //                 opcode == Opcode.OP_SHA1 || opcode == Opcode.OP_HASH160) ? 20 : 32);\n          var bufHash;\n          if (opcodenum === Opcode.OP_RIPEMD160) {\n            bufHash = Hash.ripemd160(buf);\n          } else if (opcodenum === Opcode.OP_SHA1) {\n            bufHash = Hash.sha1(buf);\n          } else if (opcodenum === Opcode.OP_SHA256) {\n            bufHash = Hash.sha256(buf);\n          } else if (opcodenum === Opcode.OP_HASH160) {\n            bufHash = Hash.sha256ripemd160(buf);\n          } else if (opcodenum === Opcode.OP_HASH256) {\n            bufHash = Hash.sha256sha256(buf);\n          }\n          this.stack.pop();\n          this.stack.push(bufHash);\n        }\n        break;\n      case Opcode.OP_CODESEPARATOR:\n        {\n          // Hash starts after the code separator\n          this.pbegincodehash = this.pc;\n        }\n        break;\n      case Opcode.OP_CHECKSIG:\n      case Opcode.OP_CHECKSIGVERIFY:\n        {\n          // (sig pubkey -- bool)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          bufSig = this.stack[this.stack.length - 2];\n          bufPubkey = this.stack[this.stack.length - 1];\n\n          // Subset of script starting at the most recent codeseparator\n          // CScript scriptCode(pbegincodehash, pend);\n          subscript = new Script().set({\n            chunks: this.script.chunks.slice(this.pbegincodehash)\n          });\n\n          // Drop the signature, since there's no way for a signature to sign itself\n          var tmpScript = new Script().add(bufSig);\n          subscript.findAndDelete(tmpScript);\n          if (!this.checkSignatureEncoding(bufSig) || !this.checkPubkeyEncoding(bufPubkey)) {\n            return false;\n          }\n          try {\n            sig = Signature.fromTxFormat(bufSig);\n            pubkey = PublicKey.fromBuffer(bufPubkey, false);\n            fSuccess = this.tx.verifySignature(sig, pubkey, this.nin, subscript);\n          } catch (e) {\n            //invalid sig or pubkey\n            fSuccess = false;\n          }\n          this.stack.pop();\n          this.stack.pop();\n          // stack.push_back(fSuccess ? vchTrue : vchFalse);\n          this.stack.push(fSuccess ? Interpreter.true : Interpreter.false);\n          if (opcodenum === Opcode.OP_CHECKSIGVERIFY) {\n            if (fSuccess) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_CHECKSIGVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n      case Opcode.OP_CHECKMULTISIG:\n      case Opcode.OP_CHECKMULTISIGVERIFY:\n        {\n          // ([sig ...] num_of_signatures [pubkey ...] num_of_pubkeys -- bool)\n\n          var i = 1;\n          if (this.stack.length < i) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          var nKeysCount = BN.fromScriptNumBuffer(this.stack[this.stack.length - i], fRequireMinimal).toNumber();\n          if (nKeysCount < 0 || nKeysCount > 20) {\n            this.errstr = 'SCRIPT_ERR_PUBKEY_COUNT';\n            return false;\n          }\n          this.nOpCount += nKeysCount;\n          if (this.nOpCount > 201) {\n            this.errstr = 'SCRIPT_ERR_OP_COUNT';\n            return false;\n          }\n          // int ikey = ++i;\n          var ikey = ++i;\n          i += nKeysCount;\n          if (this.stack.length < i) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          var nSigsCount = BN.fromScriptNumBuffer(this.stack[this.stack.length - i], fRequireMinimal).toNumber();\n          if (nSigsCount < 0 || nSigsCount > nKeysCount) {\n            this.errstr = 'SCRIPT_ERR_SIG_COUNT';\n            return false;\n          }\n          // int isig = ++i;\n          var isig = ++i;\n          i += nSigsCount;\n          if (this.stack.length < i) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          // Subset of script starting at the most recent codeseparator\n          subscript = new Script().set({\n            chunks: this.script.chunks.slice(this.pbegincodehash)\n          });\n\n          // Drop the signatures, since there's no way for a signature to sign itself\n          for (var k = 0; k < nSigsCount; k++) {\n            bufSig = this.stack[this.stack.length - isig - k];\n            subscript.findAndDelete(new Script().add(bufSig));\n          }\n          fSuccess = true;\n          while (fSuccess && nSigsCount > 0) {\n            // valtype& vchSig  = stacktop(-isig);\n            bufSig = this.stack[this.stack.length - isig];\n            // valtype& vchPubKey = stacktop(-ikey);\n            bufPubkey = this.stack[this.stack.length - ikey];\n            if (!this.checkSignatureEncoding(bufSig) || !this.checkPubkeyEncoding(bufPubkey)) {\n              return false;\n            }\n            var fOk;\n            try {\n              sig = Signature.fromTxFormat(bufSig);\n              pubkey = PublicKey.fromBuffer(bufPubkey, false);\n              fOk = this.tx.verifySignature(sig, pubkey, this.nin, subscript);\n            } catch (e) {\n              //invalid sig or pubkey\n              fOk = false;\n            }\n            if (fOk) {\n              isig++;\n              nSigsCount--;\n            }\n            ikey++;\n            nKeysCount--;\n\n            // If there are more signatures left than keys left,\n            // then too many signatures have failed\n            if (nSigsCount > nKeysCount) {\n              fSuccess = false;\n            }\n          }\n\n          // Clean up stack of actual arguments\n          while (i-- > 1) {\n            this.stack.pop();\n          }\n\n          // A bug causes CHECKMULTISIG to consume one extra argument\n          // whose contents were not checked in any way.\n          //\n          // Unfortunately this is a potential source of mutability,\n          // so optionally verify it is exactly equal to zero prior\n          // to removing it from the stack.\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          if (this.flags & Interpreter.SCRIPT_VERIFY_NULLDUMMY && this.stack[this.stack.length - 1].length) {\n            this.errstr = 'SCRIPT_ERR_SIG_NULLDUMMY';\n            return false;\n          }\n          this.stack.pop();\n          this.stack.push(fSuccess ? Interpreter.true : Interpreter.false);\n          if (opcodenum === Opcode.OP_CHECKMULTISIGVERIFY) {\n            if (fSuccess) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_CHECKMULTISIGVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n      default:\n        this.errstr = 'SCRIPT_ERR_BAD_OPCODE';\n        return false;\n    }\n  }\n  return true;\n};","map":{"version":3,"names":["_","require","Script","Opcode","BN","Hash","Signature","PublicKey","Interpreter","obj","initialize","set","prototype","verify","scriptSig","scriptPubkey","tx","nin","flags","Transaction","isUndefined","script","stackCopy","SCRIPT_VERIFY_SIGPUSHONLY","isPushOnly","errstr","evaluate","SCRIPT_VERIFY_P2SH","stack","slice","length","buf","castToBool","isScriptHashOut","Error","redeemScriptSerialized","redeemScript","fromBuffer","pop","module","exports","altstack","pc","pbegincodehash","nOpCount","vfExec","altack","true","Buffer","false","MAX_SCRIPT_ELEMENT_SIZE","LOCKTIME_THRESHOLD","LOCKTIME_THRESHOLD_BN","SCRIPT_VERIFY_NONE","SCRIPT_VERIFY_STRICTENC","SCRIPT_VERIFY_DERSIG","SCRIPT_VERIFY_LOW_S","SCRIPT_VERIFY_NULLDUMMY","SCRIPT_VERIFY_MINIMALDATA","SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS","SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY","i","checkSignatureEncoding","sig","isTxDER","fromTxFormat","hasLowS","hasDefinedHashtype","checkPubkeyEncoding","isValid","toBuffer","chunks","fSuccess","step","e","checkLockTime","nLockTime","lt","gte","gt","inputs","isFinal","fRequireMinimal","fExec","indexOf","buf1","buf2","spliced","n","x1","x2","bn","bn1","bn2","bufSig","bufPubkey","subscript","pubkey","fValue","chunk","opcodenum","OP_16","OP_CAT","OP_SUBSTR","OP_LEFT","OP_RIGHT","OP_INVERT","OP_AND","OP_OR","OP_XOR","OP_2MUL","OP_2DIV","OP_MUL","OP_DIV","OP_MOD","OP_LSHIFT","OP_RSHIFT","OP_PUSHDATA4","checkMinimalPush","push","len","OP_IF","OP_ENDIF","OP_1NEGATE","OP_1","OP_2","OP_3","OP_4","OP_5","OP_6","OP_7","OP_8","OP_9","OP_10","OP_11","OP_12","OP_13","OP_14","OP_15","toScriptNumBuffer","OP_NOP","OP_NOP2","OP_CHECKLOCKTIMEVERIFY","fromScriptNumBuffer","OP_NOP1","OP_NOP3","OP_NOP4","OP_NOP5","OP_NOP6","OP_NOP7","OP_NOP8","OP_NOP9","OP_NOP10","OP_NOTIF","OP_ELSE","OP_VERIFY","OP_RETURN","OP_TOALTSTACK","OP_FROMALTSTACK","OP_2DROP","OP_2DUP","OP_3DUP","buf3","OP_2OVER","OP_2ROT","splice","OP_2SWAP","OP_IFDUP","OP_DEPTH","OP_DROP","OP_DUP","OP_NIP","OP_OVER","OP_PICK","OP_ROLL","toNumber","OP_ROT","x3","OP_SWAP","OP_TUCK","OP_SIZE","OP_EQUAL","OP_EQUALVERIFY","fEqual","toString","OP_1ADD","OP_1SUB","OP_NEGATE","OP_ABS","OP_NOT","OP_0NOTEQUAL","add","One","sub","neg","cmp","Zero","OP_ADD","OP_SUB","OP_BOOLAND","OP_BOOLOR","OP_NUMEQUAL","OP_NUMEQUALVERIFY","OP_NUMNOTEQUAL","OP_LESSTHAN","OP_GREATERTHAN","OP_LESSTHANOREQUAL","OP_GREATERTHANOREQUAL","OP_MIN","OP_MAX","OP_WITHIN","bn3","OP_RIPEMD160","OP_SHA1","OP_SHA256","OP_HASH160","OP_HASH256","bufHash","ripemd160","sha1","sha256","sha256ripemd160","sha256sha256","OP_CODESEPARATOR","OP_CHECKSIG","OP_CHECKSIGVERIFY","tmpScript","findAndDelete","verifySignature","OP_CHECKMULTISIG","OP_CHECKMULTISIGVERIFY","nKeysCount","ikey","nSigsCount","isig","k","fOk"],"sources":["C:/Users/Elton/OneDrive/Desktop/baseapp-2024/node_modules/bitcoincashjs/src/script/interpreter.js"],"sourcesContent":["'use strict';\n\nvar _ = require('lodash');\n\nvar Script = require('./script');\nvar Opcode = require('../opcode');\nvar BN = require('../crypto/bn');\nvar Hash = require('../crypto/hash');\nvar Signature = require('../crypto/signature');\nvar PublicKey = require('../publickey');\n\n/**\n * Bitcoin transactions contain scripts. Each input has a script called the\n * scriptSig, and each output has a script called the scriptPubkey. To validate\n * an input, the input's script is concatenated with the referenced output script,\n * and the result is executed. If at the end of execution the stack contains a\n * \"true\" value, then the transaction is valid.\n *\n * The primary way to use this class is via the verify function.\n * e.g., Interpreter().verify( ... );\n */\nvar Interpreter = function Interpreter(obj) {\n  if (!(this instanceof Interpreter)) {\n    return new Interpreter(obj);\n  }\n  if (obj) {\n    this.initialize();\n    this.set(obj);\n  } else {\n    this.initialize();\n  }\n};\n\n/**\n * Verifies a Script by executing it and returns true if it is valid.\n * This function needs to be provided with the scriptSig and the scriptPubkey\n * separately.\n * @param {Script} scriptSig - the script's first part (corresponding to the tx input)\n * @param {Script} scriptPubkey - the script's last part (corresponding to the tx output)\n * @param {Transaction=} tx - the Transaction containing the scriptSig in one input (used\n *    to check signature validity for some opcodes like OP_CHECKSIG)\n * @param {number} nin - index of the transaction input containing the scriptSig verified.\n * @param {number} flags - evaluation flags. See Interpreter.SCRIPT_* constants\n *\n * Translated from bitcoind's VerifyScript\n */\nInterpreter.prototype.verify = function(scriptSig, scriptPubkey, tx, nin, flags) {\n  var Transaction = require('../transaction');\n  if (_.isUndefined(tx)) {\n    tx = new Transaction();\n  }\n  if (_.isUndefined(nin)) {\n    nin = 0;\n  }\n  if (_.isUndefined(flags)) {\n    flags = 0;\n  }\n  this.set({\n    script: scriptSig,\n    tx: tx,\n    nin: nin,\n    flags: flags\n  });\n  var stackCopy;\n\n  if ((flags & Interpreter.SCRIPT_VERIFY_SIGPUSHONLY) !== 0 && !scriptSig.isPushOnly()) {\n    this.errstr = 'SCRIPT_ERR_SIG_PUSHONLY';\n    return false;\n  }\n\n  // evaluate scriptSig\n  if (!this.evaluate()) {\n    return false;\n  }\n\n  if (flags & Interpreter.SCRIPT_VERIFY_P2SH) {\n    stackCopy = this.stack.slice();\n  }\n\n  var stack = this.stack;\n  this.initialize();\n  this.set({\n    script: scriptPubkey,\n    stack: stack,\n    tx: tx,\n    nin: nin,\n    flags: flags\n  });\n\n  // evaluate scriptPubkey\n  if (!this.evaluate()) {\n    return false;\n  }\n\n  if (this.stack.length === 0) {\n    this.errstr = 'SCRIPT_ERR_EVAL_FALSE_NO_RESULT';\n    return false;\n  }\n\n  var buf = this.stack[this.stack.length - 1];\n  if (!Interpreter.castToBool(buf)) {\n    this.errstr = 'SCRIPT_ERR_EVAL_FALSE_IN_STACK';\n    return false;\n  }\n\n  // Additional validation for spend-to-script-hash transactions:\n  if ((flags & Interpreter.SCRIPT_VERIFY_P2SH) && scriptPubkey.isScriptHashOut()) {\n    // scriptSig must be literals-only or validation fails\n    if (!scriptSig.isPushOnly()) {\n      this.errstr = 'SCRIPT_ERR_SIG_PUSHONLY';\n      return false;\n    }\n\n    // stackCopy cannot be empty here, because if it was the\n    // P2SH  HASH <> EQUAL  scriptPubKey would be evaluated with\n    // an empty stack and the EvalScript above would return false.\n    if (stackCopy.length === 0) {\n      throw new Error('internal error - stack copy empty');\n    }\n\n    var redeemScriptSerialized = stackCopy[stackCopy.length - 1];\n    var redeemScript = Script.fromBuffer(redeemScriptSerialized);\n    stackCopy.pop();\n\n    this.initialize();\n    this.set({\n      script: redeemScript,\n      stack: stackCopy,\n      tx: tx,\n      nin: nin,\n      flags: flags\n    });\n\n    // evaluate redeemScript\n    if (!this.evaluate()) {\n      return false;\n    }\n\n    if (stackCopy.length === 0) {\n      this.errstr = 'SCRIPT_ERR_EVAL_FALSE_NO_P2SH_STACK';\n      return false;\n    }\n\n    if (!Interpreter.castToBool(stackCopy[stackCopy.length - 1])) {\n      this.errstr = 'SCRIPT_ERR_EVAL_FALSE_IN_P2SH_STACK';\n      return false;\n    } else {\n      return true;\n    }\n  }\n\n  return true;\n};\n\nmodule.exports = Interpreter;\n\nInterpreter.prototype.initialize = function(obj) {\n  this.stack = [];\n  this.altstack = [];\n  this.pc = 0;\n  this.pbegincodehash = 0;\n  this.nOpCount = 0;\n  this.vfExec = [];\n  this.errstr = '';\n  this.flags = 0;\n};\n\nInterpreter.prototype.set = function(obj) {\n  this.script = obj.script || this.script;\n  this.tx = obj.tx || this.tx;\n  this.nin = typeof obj.nin !== 'undefined' ? obj.nin : this.nin;\n  this.stack = obj.stack || this.stack;\n  this.altstack = obj.altack || this.altstack;\n  this.pc = typeof obj.pc !== 'undefined' ? obj.pc : this.pc;\n  this.pbegincodehash = typeof obj.pbegincodehash !== 'undefined' ? obj.pbegincodehash : this.pbegincodehash;\n  this.nOpCount = typeof obj.nOpCount !== 'undefined' ? obj.nOpCount : this.nOpCount;\n  this.vfExec = obj.vfExec || this.vfExec;\n  this.errstr = obj.errstr || this.errstr;\n  this.flags = typeof obj.flags !== 'undefined' ? obj.flags : this.flags;\n};\n\nInterpreter.true = new Buffer([1]);\nInterpreter.false = new Buffer([]);\n\nInterpreter.MAX_SCRIPT_ELEMENT_SIZE = 520;\n\nInterpreter.LOCKTIME_THRESHOLD = 500000000;\nInterpreter.LOCKTIME_THRESHOLD_BN = new BN(Interpreter.LOCKTIME_THRESHOLD);\n\n// flags taken from bitcoind\n// bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104\nInterpreter.SCRIPT_VERIFY_NONE = 0;\n\n// Evaluate P2SH subscripts (softfork safe, BIP16).\nInterpreter.SCRIPT_VERIFY_P2SH = (1 << 0);\n\n// Passing a non-strict-DER signature or one with undefined hashtype to a checksig operation causes script failure.\n// Passing a pubkey that is not (0x04 + 64 bytes) or (0x02 or 0x03 + 32 bytes) to checksig causes that pubkey to be\n// skipped (not softfork safe: this flag can widen the validity of OP_CHECKSIG OP_NOT).\nInterpreter.SCRIPT_VERIFY_STRICTENC = (1 << 1);\n\n// Passing a non-strict-DER signature to a checksig operation causes script failure (softfork safe, BIP62 rule 1)\nInterpreter.SCRIPT_VERIFY_DERSIG = (1 << 2);\n\n// Passing a non-strict-DER signature or one with S > order/2 to a checksig operation causes script failure\n// (softfork safe, BIP62 rule 5).\nInterpreter.SCRIPT_VERIFY_LOW_S = (1 << 3);\n\n// verify dummy stack item consumed by CHECKMULTISIG is of zero-length (softfork safe, BIP62 rule 7).\nInterpreter.SCRIPT_VERIFY_NULLDUMMY = (1 << 4);\n\n// Using a non-push operator in the scriptSig causes script failure (softfork safe, BIP62 rule 2).\nInterpreter.SCRIPT_VERIFY_SIGPUSHONLY = (1 << 5);\n\n// Require minimal encodings for all push operations (OP_0... OP_16, OP_1NEGATE where possible, direct\n// pushes up to 75 bytes, OP_PUSHDATA up to 255 bytes, OP_PUSHDATA2 for anything larger). Evaluating\n// any other push causes the script to fail (BIP62 rule 3).\n// In addition, whenever a stack element is interpreted as a number, it must be of minimal length (BIP62 rule 4).\n// (softfork safe)\nInterpreter.SCRIPT_VERIFY_MINIMALDATA = (1 << 6);\n\n// Discourage use of NOPs reserved for upgrades (NOP1-10)\n//\n// Provided so that nodes can avoid accepting or mining transactions\n// containing executed NOP's whose meaning may change after a soft-fork,\n// thus rendering the script invalid; with this flag set executing\n// discouraged NOPs fails the script. This verification flag will never be\n// a mandatory flag applied to scripts in a block. NOPs that are not\n// executed, e.g.  within an unexecuted IF ENDIF block, are *not* rejected.\nInterpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS = (1 << 7);\n\n// CLTV See BIP65 for details.\nInterpreter.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY = (1 << 9);\n\nInterpreter.castToBool = function(buf) {\n  for (var i = 0; i < buf.length; i++) {\n    if (buf[i] !== 0) {\n      // can be negative zero\n      if (i === buf.length - 1 && buf[i] === 0x80) {\n        return false;\n      }\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Translated from bitcoind's CheckSignatureEncoding\n */\nInterpreter.prototype.checkSignatureEncoding = function(buf) {\n  var sig;\n  if ((this.flags & (Interpreter.SCRIPT_VERIFY_DERSIG | Interpreter.SCRIPT_VERIFY_LOW_S | Interpreter.SCRIPT_VERIFY_STRICTENC)) !== 0 && !Signature.isTxDER(buf)) {\n    this.errstr = 'SCRIPT_ERR_SIG_DER_INVALID_FORMAT';\n    return false;\n  } else if ((this.flags & Interpreter.SCRIPT_VERIFY_LOW_S) !== 0) {\n    sig = Signature.fromTxFormat(buf);\n    if (!sig.hasLowS()) {\n      this.errstr = 'SCRIPT_ERR_SIG_DER_HIGH_S';\n      return false;\n    }\n  } else if ((this.flags & Interpreter.SCRIPT_VERIFY_STRICTENC) !== 0) {\n    sig = Signature.fromTxFormat(buf);\n    if (!sig.hasDefinedHashtype()) {\n      this.errstr = 'SCRIPT_ERR_SIG_HASHTYPE';\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Translated from bitcoind's CheckPubKeyEncoding\n */\nInterpreter.prototype.checkPubkeyEncoding = function(buf) {\n  if ((this.flags & Interpreter.SCRIPT_VERIFY_STRICTENC) !== 0 && !PublicKey.isValid(buf)) {\n    this.errstr = 'SCRIPT_ERR_PUBKEYTYPE';\n    return false;\n  }\n  return true;\n};\n\n/**\n * Based on bitcoind's EvalScript function, with the inner loop moved to\n * Interpreter.prototype.step()\n * bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104\n */\nInterpreter.prototype.evaluate = function() {\n  if (this.script.toBuffer().length > 10000) {\n    this.errstr = 'SCRIPT_ERR_SCRIPT_SIZE';\n    return false;\n  }\n\n  try {\n    while (this.pc < this.script.chunks.length) {\n      var fSuccess = this.step();\n      if (!fSuccess) {\n        return false;\n      }\n    }\n\n    // Size limits\n    if (this.stack.length + this.altstack.length > 1000) {\n      this.errstr = 'SCRIPT_ERR_STACK_SIZE';\n      return false;\n    }\n  } catch (e) {\n    this.errstr = 'SCRIPT_ERR_UNKNOWN_ERROR: ' + e;\n    return false;\n  }\n\n  if (this.vfExec.length > 0) {\n    this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n    return false;\n  }\n\n  return true;\n};\n\n/**\n * Checks a locktime parameter with the transaction's locktime.\n * There are two times of nLockTime: lock-by-blockheight and lock-by-blocktime,\n * distinguished by whether nLockTime < LOCKTIME_THRESHOLD = 500000000\n *\n * See the corresponding code on bitcoin core:\n * https://github.com/bitcoin/bitcoin/blob/ffd75adce01a78b3461b3ff05bcc2b530a9ce994/src/script/interpreter.cpp#L1129\n *\n * @param {BN} nLockTime the locktime read from the script\n * @return {boolean} true if the transaction's locktime is less than or equal to\n *                   the transaction's locktime\n */\nInterpreter.prototype.checkLockTime = function(nLockTime) {\n\n  // We want to compare apples to apples, so fail the script\n  // unless the type of nLockTime being tested is the same as\n  // the nLockTime in the transaction.\n  if (!(\n    (this.tx.nLockTime <  Interpreter.LOCKTIME_THRESHOLD && nLockTime.lt(Interpreter.LOCKTIME_THRESHOLD_BN)) ||\n    (this.tx.nLockTime >= Interpreter.LOCKTIME_THRESHOLD && nLockTime.gte(Interpreter.LOCKTIME_THRESHOLD_BN))\n  )) {\n    return false;\n  }\n\n  // Now that we know we're comparing apples-to-apples, the\n  // comparison is a simple numeric one.\n  if (nLockTime.gt(new BN(this.tx.nLockTime))) {\n    return false;\n  }\n\n  // Finally the nLockTime feature can be disabled and thus\n  // CHECKLOCKTIMEVERIFY bypassed if every txin has been\n  // finalized by setting nSequence to maxint. The\n  // transaction would be allowed into the blockchain, making\n  // the opcode ineffective.\n  //\n  // Testing if this vin is not final is sufficient to\n  // prevent this condition. Alternatively we could test all\n  // inputs, but testing just this input minimizes the data\n  // required to prove correct CHECKLOCKTIMEVERIFY execution.\n  if (!this.tx.inputs[this.nin].isFinal()) {\n    return false;\n  }\n\n  return true;\n}\n\n/** \n * Based on the inner loop of bitcoind's EvalScript function\n * bitcoind commit: b5d1b1092998bc95313856d535c632ea5a8f9104\n */\nInterpreter.prototype.step = function() {\n\n  var fRequireMinimal = (this.flags & Interpreter.SCRIPT_VERIFY_MINIMALDATA) !== 0;\n\n  //bool fExec = !count(vfExec.begin(), vfExec.end(), false);\n  var fExec = (this.vfExec.indexOf(false) === -1);\n  var buf, buf1, buf2, spliced, n, x1, x2, bn, bn1, bn2, bufSig, bufPubkey, subscript;\n  var sig, pubkey;\n  var fValue, fSuccess;\n\n  // Read instruction\n  var chunk = this.script.chunks[this.pc];\n  this.pc++;\n  var opcodenum = chunk.opcodenum;\n  if (_.isUndefined(opcodenum)) {\n    this.errstr = 'SCRIPT_ERR_UNDEFINED_OPCODE';\n    return false;\n  }\n  if (chunk.buf && chunk.buf.length > Interpreter.MAX_SCRIPT_ELEMENT_SIZE) {\n    this.errstr = 'SCRIPT_ERR_PUSH_SIZE';\n    return false;\n  }\n\n  // Note how Opcode.OP_RESERVED does not count towards the opcode limit.\n  if (opcodenum > Opcode.OP_16 && ++(this.nOpCount) > 201) {\n    this.errstr = 'SCRIPT_ERR_OP_COUNT';\n    return false;\n  }\n\n\n  if (opcodenum === Opcode.OP_CAT ||\n    opcodenum === Opcode.OP_SUBSTR ||\n    opcodenum === Opcode.OP_LEFT ||\n    opcodenum === Opcode.OP_RIGHT ||\n    opcodenum === Opcode.OP_INVERT ||\n    opcodenum === Opcode.OP_AND ||\n    opcodenum === Opcode.OP_OR ||\n    opcodenum === Opcode.OP_XOR ||\n    opcodenum === Opcode.OP_2MUL ||\n    opcodenum === Opcode.OP_2DIV ||\n    opcodenum === Opcode.OP_MUL ||\n    opcodenum === Opcode.OP_DIV ||\n    opcodenum === Opcode.OP_MOD ||\n    opcodenum === Opcode.OP_LSHIFT ||\n    opcodenum === Opcode.OP_RSHIFT) {\n    this.errstr = 'SCRIPT_ERR_DISABLED_OPCODE';\n    return false;\n  }\n\n  if (fExec && 0 <= opcodenum && opcodenum <= Opcode.OP_PUSHDATA4) {\n    if (fRequireMinimal && !this.script.checkMinimalPush(this.pc - 1)) {\n      this.errstr = 'SCRIPT_ERR_MINIMALDATA';\n      return false;\n    }\n    if (!chunk.buf) {\n      this.stack.push(Interpreter.false);\n    } else if (chunk.len !== chunk.buf.length) {\n      throw new Error('Length of push value not equal to length of data');\n    } else {\n      this.stack.push(chunk.buf);\n    }\n  } else if (fExec || (Opcode.OP_IF <= opcodenum && opcodenum <= Opcode.OP_ENDIF)) {\n    switch (opcodenum) {\n      // Push value\n      case Opcode.OP_1NEGATE:\n      case Opcode.OP_1:\n      case Opcode.OP_2:\n      case Opcode.OP_3:\n      case Opcode.OP_4:\n      case Opcode.OP_5:\n      case Opcode.OP_6:\n      case Opcode.OP_7:\n      case Opcode.OP_8:\n      case Opcode.OP_9:\n      case Opcode.OP_10:\n      case Opcode.OP_11:\n      case Opcode.OP_12:\n      case Opcode.OP_13:\n      case Opcode.OP_14:\n      case Opcode.OP_15:\n      case Opcode.OP_16:\n        {\n          // ( -- value)\n          // ScriptNum bn((int)opcode - (int)(Opcode.OP_1 - 1));\n          n = opcodenum - (Opcode.OP_1 - 1);\n          buf = new BN(n).toScriptNumBuffer();\n          this.stack.push(buf);\n          // The result of these opcodes should always be the minimal way to push the data\n          // they push, so no need for a CheckMinimalPush here.\n        }\n        break;\n\n\n        //\n        // Control\n        //\n      case Opcode.OP_NOP:\n        break;\n\n      case Opcode.OP_NOP2:\n      case Opcode.OP_CHECKLOCKTIMEVERIFY:\n\n        if (!(this.flags & Interpreter.SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY)) {\n          // not enabled; treat as a NOP2\n          if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {\n            this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS';\n            return false;\n          }\n          break;\n        }\n\n        if (this.stack.length < 1) {\n          this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n          return false;\n        }\n\n        // Note that elsewhere numeric opcodes are limited to\n        // operands in the range -2**31+1 to 2**31-1, however it is\n        // legal for opcodes to produce results exceeding that\n        // range. This limitation is implemented by CScriptNum's\n        // default 4-byte limit.\n        //\n        // If we kept to that limit we'd have a year 2038 problem,\n        // even though the nLockTime field in transactions\n        // themselves is uint32 which only becomes meaningless\n        // after the year 2106.\n        //\n        // Thus as a special case we tell CScriptNum to accept up\n        // to 5-byte bignums, which are good until 2**39-1, well\n        // beyond the 2**32-1 limit of the nLockTime field itself.\n        var nLockTime = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal, 5);\n\n        // In the rare event that the argument may be < 0 due to\n        // some arithmetic being done first, you can always use\n        // 0 MAX CHECKLOCKTIMEVERIFY.\n        if (nLockTime.lt(new BN(0))) {\n          this.errstr = 'SCRIPT_ERR_NEGATIVE_LOCKTIME';\n          return false;\n        }\n\n        // Actually compare the specified lock time with the transaction.\n        if (!this.checkLockTime(nLockTime)) {\n          this.errstr = 'SCRIPT_ERR_UNSATISFIED_LOCKTIME';\n          return false;\n        }\n        break;\n\n      case Opcode.OP_NOP1:\n      case Opcode.OP_NOP3:\n      case Opcode.OP_NOP4:\n      case Opcode.OP_NOP5:\n      case Opcode.OP_NOP6:\n      case Opcode.OP_NOP7:\n      case Opcode.OP_NOP8:\n      case Opcode.OP_NOP9:\n      case Opcode.OP_NOP10:\n        {\n          if (this.flags & Interpreter.SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS) {\n            this.errstr = 'SCRIPT_ERR_DISCOURAGE_UPGRADABLE_NOPS';\n            return false;\n          }\n        }\n        break;\n\n      case Opcode.OP_IF:\n      case Opcode.OP_NOTIF:\n        {\n          // <expression> if [statements] [else [statements]] endif\n          // bool fValue = false;\n          fValue = false;\n          if (fExec) {\n            if (this.stack.length < 1) {\n              this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n              return false;\n            }\n            buf = this.stack.pop();\n            fValue = Interpreter.castToBool(buf);\n            if (opcodenum === Opcode.OP_NOTIF) {\n              fValue = !fValue;\n            }\n          }\n          this.vfExec.push(fValue);\n        }\n        break;\n\n      case Opcode.OP_ELSE:\n        {\n          if (this.vfExec.length === 0) {\n            this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n            return false;\n          }\n          this.vfExec[this.vfExec.length - 1] = !this.vfExec[this.vfExec.length - 1];\n        }\n        break;\n\n      case Opcode.OP_ENDIF:\n        {\n          if (this.vfExec.length === 0) {\n            this.errstr = 'SCRIPT_ERR_UNBALANCED_CONDITIONAL';\n            return false;\n          }\n          this.vfExec.pop();\n        }\n        break;\n\n      case Opcode.OP_VERIFY:\n        {\n          // (true -- ) or\n          // (false -- false) and return\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf = this.stack[this.stack.length - 1];\n          fValue = Interpreter.castToBool(buf);\n          if (fValue) {\n            this.stack.pop();\n          } else {\n            this.errstr = 'SCRIPT_ERR_VERIFY';\n            return false;\n          }\n        }\n        break;\n\n      case Opcode.OP_RETURN:\n        {\n          this.errstr = 'SCRIPT_ERR_OP_RETURN';\n          return false;\n        }\n        break;\n\n\n        //\n        // Stack ops\n        //\n      case Opcode.OP_TOALTSTACK:\n        {\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.altstack.push(this.stack.pop());\n        }\n        break;\n\n      case Opcode.OP_FROMALTSTACK:\n        {\n          if (this.altstack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_ALTSTACK_OPERATION';\n            return false;\n          }\n          this.stack.push(this.altstack.pop());\n        }\n        break;\n\n      case Opcode.OP_2DROP:\n        {\n          // (x1 x2 -- )\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.stack.pop();\n          this.stack.pop();\n        }\n        break;\n\n      case Opcode.OP_2DUP:\n        {\n          // (x1 x2 -- x1 x2 x1 x2)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf1 = this.stack[this.stack.length - 2];\n          buf2 = this.stack[this.stack.length - 1];\n          this.stack.push(buf1);\n          this.stack.push(buf2);\n        }\n        break;\n\n      case Opcode.OP_3DUP:\n        {\n          // (x1 x2 x3 -- x1 x2 x3 x1 x2 x3)\n          if (this.stack.length < 3) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf1 = this.stack[this.stack.length - 3];\n          buf2 = this.stack[this.stack.length - 2];\n          var buf3 = this.stack[this.stack.length - 1];\n          this.stack.push(buf1);\n          this.stack.push(buf2);\n          this.stack.push(buf3);\n        }\n        break;\n\n      case Opcode.OP_2OVER:\n        {\n          // (x1 x2 x3 x4 -- x1 x2 x3 x4 x1 x2)\n          if (this.stack.length < 4) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf1 = this.stack[this.stack.length - 4];\n          buf2 = this.stack[this.stack.length - 3];\n          this.stack.push(buf1);\n          this.stack.push(buf2);\n        }\n        break;\n\n      case Opcode.OP_2ROT:\n        {\n          // (x1 x2 x3 x4 x5 x6 -- x3 x4 x5 x6 x1 x2)\n          if (this.stack.length < 6) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          spliced = this.stack.splice(this.stack.length - 6, 2);\n          this.stack.push(spliced[0]);\n          this.stack.push(spliced[1]);\n        }\n        break;\n\n      case Opcode.OP_2SWAP:\n        {\n          // (x1 x2 x3 x4 -- x3 x4 x1 x2)\n          if (this.stack.length < 4) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          spliced = this.stack.splice(this.stack.length - 4, 2);\n          this.stack.push(spliced[0]);\n          this.stack.push(spliced[1]);\n        }\n        break;\n\n      case Opcode.OP_IFDUP:\n        {\n          // (x - 0 | x x)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf = this.stack[this.stack.length - 1];\n          fValue = Interpreter.castToBool(buf);\n          if (fValue) {\n            this.stack.push(buf);\n          }\n        }\n        break;\n\n      case Opcode.OP_DEPTH:\n        {\n          // -- stacksize\n          buf = new BN(this.stack.length).toScriptNumBuffer();\n          this.stack.push(buf);\n        }\n        break;\n\n      case Opcode.OP_DROP:\n        {\n          // (x -- )\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.stack.pop();\n        }\n        break;\n\n      case Opcode.OP_DUP:\n        {\n          // (x -- x x)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.stack.push(this.stack[this.stack.length - 1]);\n        }\n        break;\n\n      case Opcode.OP_NIP:\n        {\n          // (x1 x2 -- x2)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.stack.splice(this.stack.length - 2, 1);\n        }\n        break;\n\n      case Opcode.OP_OVER:\n        {\n          // (x1 x2 -- x1 x2 x1)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.stack.push(this.stack[this.stack.length - 2]);\n        }\n        break;\n\n      case Opcode.OP_PICK:\n      case Opcode.OP_ROLL:\n        {\n          // (xn ... x2 x1 x0 n - xn ... x2 x1 x0 xn)\n          // (xn ... x2 x1 x0 n - ... x2 x1 x0 xn)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf = this.stack[this.stack.length - 1];\n          bn = BN.fromScriptNumBuffer(buf, fRequireMinimal);\n          n = bn.toNumber();\n          this.stack.pop();\n          if (n < 0 || n >= this.stack.length) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf = this.stack[this.stack.length - n - 1];\n          if (opcodenum === Opcode.OP_ROLL) {\n            this.stack.splice(this.stack.length - n - 1, 1);\n          }\n          this.stack.push(buf);\n        }\n        break;\n\n      case Opcode.OP_ROT:\n        {\n          // (x1 x2 x3 -- x2 x3 x1)\n          //  x2 x1 x3  after first swap\n          //  x2 x3 x1  after second swap\n          if (this.stack.length < 3) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          x1 = this.stack[this.stack.length - 3];\n          x2 = this.stack[this.stack.length - 2];\n          var x3 = this.stack[this.stack.length - 1];\n          this.stack[this.stack.length - 3] = x2;\n          this.stack[this.stack.length - 2] = x3;\n          this.stack[this.stack.length - 1] = x1;\n        }\n        break;\n\n      case Opcode.OP_SWAP:\n        {\n          // (x1 x2 -- x2 x1)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          x1 = this.stack[this.stack.length - 2];\n          x2 = this.stack[this.stack.length - 1];\n          this.stack[this.stack.length - 2] = x2;\n          this.stack[this.stack.length - 1] = x1;\n        }\n        break;\n\n      case Opcode.OP_TUCK:\n        {\n          // (x1 x2 -- x2 x1 x2)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          this.stack.splice(this.stack.length - 2, 0, this.stack[this.stack.length - 1]);\n        }\n        break;\n\n\n      case Opcode.OP_SIZE:\n        {\n          // (in -- in size)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          bn = new BN(this.stack[this.stack.length - 1].length);\n          this.stack.push(bn.toScriptNumBuffer());\n        }\n        break;\n\n\n        //\n        // Bitwise logic\n        //\n      case Opcode.OP_EQUAL:\n      case Opcode.OP_EQUALVERIFY:\n        //case Opcode.OP_NOTEQUAL: // use Opcode.OP_NUMNOTEQUAL\n        {\n          // (x1 x2 - bool)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf1 = this.stack[this.stack.length - 2];\n          buf2 = this.stack[this.stack.length - 1];\n          var fEqual = buf1.toString('hex') === buf2.toString('hex');\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.push(fEqual ? Interpreter.true : Interpreter.false);\n          if (opcodenum === Opcode.OP_EQUALVERIFY) {\n            if (fEqual) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_EQUALVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n\n\n        //\n        // Numeric\n        //\n      case Opcode.OP_1ADD:\n      case Opcode.OP_1SUB:\n      case Opcode.OP_NEGATE:\n      case Opcode.OP_ABS:\n      case Opcode.OP_NOT:\n      case Opcode.OP_0NOTEQUAL:\n        {\n          // (in -- out)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf = this.stack[this.stack.length - 1];\n          bn = BN.fromScriptNumBuffer(buf, fRequireMinimal);\n          switch (opcodenum) {\n            case Opcode.OP_1ADD:\n              bn = bn.add(BN.One);\n              break;\n            case Opcode.OP_1SUB:\n              bn = bn.sub(BN.One);\n              break;\n            case Opcode.OP_NEGATE:\n              bn = bn.neg();\n              break;\n            case Opcode.OP_ABS:\n              if (bn.cmp(BN.Zero) < 0) {\n                bn = bn.neg();\n              }\n              break;\n            case Opcode.OP_NOT:\n              bn = new BN((bn.cmp(BN.Zero) === 0) + 0);\n              break;\n            case Opcode.OP_0NOTEQUAL:\n              bn = new BN((bn.cmp(BN.Zero) !== 0) + 0);\n              break;\n              //default:      assert(!'invalid opcode'); break; // TODO: does this ever occur?\n          }\n          this.stack.pop();\n          this.stack.push(bn.toScriptNumBuffer());\n        }\n        break;\n\n      case Opcode.OP_ADD:\n      case Opcode.OP_SUB:\n      case Opcode.OP_BOOLAND:\n      case Opcode.OP_BOOLOR:\n      case Opcode.OP_NUMEQUAL:\n      case Opcode.OP_NUMEQUALVERIFY:\n      case Opcode.OP_NUMNOTEQUAL:\n      case Opcode.OP_LESSTHAN:\n      case Opcode.OP_GREATERTHAN:\n      case Opcode.OP_LESSTHANOREQUAL:\n      case Opcode.OP_GREATERTHANOREQUAL:\n      case Opcode.OP_MIN:\n      case Opcode.OP_MAX:\n        {\n          // (x1 x2 -- out)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          bn1 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 2], fRequireMinimal);\n          bn2 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal);\n          bn = new BN(0);\n\n          switch (opcodenum) {\n            case Opcode.OP_ADD:\n              bn = bn1.add(bn2);\n              break;\n\n            case Opcode.OP_SUB:\n              bn = bn1.sub(bn2);\n              break;\n\n              // case Opcode.OP_BOOLAND:       bn = (bn1 != bnZero && bn2 != bnZero); break;\n            case Opcode.OP_BOOLAND:\n              bn = new BN(((bn1.cmp(BN.Zero) !== 0) && (bn2.cmp(BN.Zero) !== 0)) + 0);\n              break;\n              // case Opcode.OP_BOOLOR:        bn = (bn1 != bnZero || bn2 != bnZero); break;\n            case Opcode.OP_BOOLOR:\n              bn = new BN(((bn1.cmp(BN.Zero) !== 0) || (bn2.cmp(BN.Zero) !== 0)) + 0);\n              break;\n              // case Opcode.OP_NUMEQUAL:      bn = (bn1 == bn2); break;\n            case Opcode.OP_NUMEQUAL:\n              bn = new BN((bn1.cmp(bn2) === 0) + 0);\n              break;\n              // case Opcode.OP_NUMEQUALVERIFY:    bn = (bn1 == bn2); break;\n            case Opcode.OP_NUMEQUALVERIFY:\n              bn = new BN((bn1.cmp(bn2) === 0) + 0);\n              break;\n              // case Opcode.OP_NUMNOTEQUAL:     bn = (bn1 != bn2); break;\n            case Opcode.OP_NUMNOTEQUAL:\n              bn = new BN((bn1.cmp(bn2) !== 0) + 0);\n              break;\n              // case Opcode.OP_LESSTHAN:      bn = (bn1 < bn2); break;\n            case Opcode.OP_LESSTHAN:\n              bn = new BN((bn1.cmp(bn2) < 0) + 0);\n              break;\n              // case Opcode.OP_GREATERTHAN:     bn = (bn1 > bn2); break;\n            case Opcode.OP_GREATERTHAN:\n              bn = new BN((bn1.cmp(bn2) > 0) + 0);\n              break;\n              // case Opcode.OP_LESSTHANOREQUAL:   bn = (bn1 <= bn2); break;\n            case Opcode.OP_LESSTHANOREQUAL:\n              bn = new BN((bn1.cmp(bn2) <= 0) + 0);\n              break;\n              // case Opcode.OP_GREATERTHANOREQUAL:  bn = (bn1 >= bn2); break;\n            case Opcode.OP_GREATERTHANOREQUAL:\n              bn = new BN((bn1.cmp(bn2) >= 0) + 0);\n              break;\n            case Opcode.OP_MIN:\n              bn = (bn1.cmp(bn2) < 0 ? bn1 : bn2);\n              break;\n            case Opcode.OP_MAX:\n              bn = (bn1.cmp(bn2) > 0 ? bn1 : bn2);\n              break;\n              // default:           assert(!'invalid opcode'); break; //TODO: does this ever occur?\n          }\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.push(bn.toScriptNumBuffer());\n\n          if (opcodenum === Opcode.OP_NUMEQUALVERIFY) {\n            // if (CastToBool(stacktop(-1)))\n            if (Interpreter.castToBool(this.stack[this.stack.length - 1])) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_NUMEQUALVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n\n      case Opcode.OP_WITHIN:\n        {\n          // (x min max -- out)\n          if (this.stack.length < 3) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          bn1 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 3], fRequireMinimal);\n          bn2 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 2], fRequireMinimal);\n          var bn3 = BN.fromScriptNumBuffer(this.stack[this.stack.length - 1], fRequireMinimal);\n          //bool fValue = (bn2 <= bn1 && bn1 < bn3);\n          fValue = (bn2.cmp(bn1) <= 0) && (bn1.cmp(bn3) < 0);\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.pop();\n          this.stack.push(fValue ? Interpreter.true : Interpreter.false);\n        }\n        break;\n\n\n        //\n        // Crypto\n        //\n      case Opcode.OP_RIPEMD160:\n      case Opcode.OP_SHA1:\n      case Opcode.OP_SHA256:\n      case Opcode.OP_HASH160:\n      case Opcode.OP_HASH256:\n        {\n          // (in -- hash)\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          buf = this.stack[this.stack.length - 1];\n          //valtype vchHash((opcode == Opcode.OP_RIPEMD160 ||\n          //                 opcode == Opcode.OP_SHA1 || opcode == Opcode.OP_HASH160) ? 20 : 32);\n          var bufHash;\n          if (opcodenum === Opcode.OP_RIPEMD160) {\n            bufHash = Hash.ripemd160(buf);\n          } else if (opcodenum === Opcode.OP_SHA1) {\n            bufHash = Hash.sha1(buf);\n          } else if (opcodenum === Opcode.OP_SHA256) {\n            bufHash = Hash.sha256(buf);\n          } else if (opcodenum === Opcode.OP_HASH160) {\n            bufHash = Hash.sha256ripemd160(buf);\n          } else if (opcodenum === Opcode.OP_HASH256) {\n            bufHash = Hash.sha256sha256(buf);\n          }\n          this.stack.pop();\n          this.stack.push(bufHash);\n        }\n        break;\n\n      case Opcode.OP_CODESEPARATOR:\n        {\n          // Hash starts after the code separator\n          this.pbegincodehash = this.pc;\n        }\n        break;\n\n      case Opcode.OP_CHECKSIG:\n      case Opcode.OP_CHECKSIGVERIFY:\n        {\n          // (sig pubkey -- bool)\n          if (this.stack.length < 2) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          bufSig = this.stack[this.stack.length - 2];\n          bufPubkey = this.stack[this.stack.length - 1];\n\n          // Subset of script starting at the most recent codeseparator\n          // CScript scriptCode(pbegincodehash, pend);\n          subscript = new Script().set({\n            chunks: this.script.chunks.slice(this.pbegincodehash)\n          });\n\n          // Drop the signature, since there's no way for a signature to sign itself\n          var tmpScript = new Script().add(bufSig);\n          subscript.findAndDelete(tmpScript);\n\n          if (!this.checkSignatureEncoding(bufSig) || !this.checkPubkeyEncoding(bufPubkey)) {\n            return false;\n          }\n\n          try {\n            sig = Signature.fromTxFormat(bufSig);\n            pubkey = PublicKey.fromBuffer(bufPubkey, false);\n            fSuccess = this.tx.verifySignature(sig, pubkey, this.nin, subscript);\n          } catch (e) {\n            //invalid sig or pubkey\n            fSuccess = false;\n          }\n\n          this.stack.pop();\n          this.stack.pop();\n          // stack.push_back(fSuccess ? vchTrue : vchFalse);\n          this.stack.push(fSuccess ? Interpreter.true : Interpreter.false);\n          if (opcodenum === Opcode.OP_CHECKSIGVERIFY) {\n            if (fSuccess) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_CHECKSIGVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n\n      case Opcode.OP_CHECKMULTISIG:\n      case Opcode.OP_CHECKMULTISIGVERIFY:\n        {\n          // ([sig ...] num_of_signatures [pubkey ...] num_of_pubkeys -- bool)\n\n          var i = 1;\n          if (this.stack.length < i) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          var nKeysCount = BN.fromScriptNumBuffer(this.stack[this.stack.length - i], fRequireMinimal).toNumber();\n          if (nKeysCount < 0 || nKeysCount > 20) {\n            this.errstr = 'SCRIPT_ERR_PUBKEY_COUNT';\n            return false;\n          }\n          this.nOpCount += nKeysCount;\n          if (this.nOpCount > 201) {\n            this.errstr = 'SCRIPT_ERR_OP_COUNT';\n            return false;\n          }\n          // int ikey = ++i;\n          var ikey = ++i;\n          i += nKeysCount;\n          if (this.stack.length < i) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          var nSigsCount = BN.fromScriptNumBuffer(this.stack[this.stack.length - i], fRequireMinimal).toNumber();\n          if (nSigsCount < 0 || nSigsCount > nKeysCount) {\n            this.errstr = 'SCRIPT_ERR_SIG_COUNT';\n            return false;\n          }\n          // int isig = ++i;\n          var isig = ++i;\n          i += nSigsCount;\n          if (this.stack.length < i) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n\n          // Subset of script starting at the most recent codeseparator\n          subscript = new Script().set({\n            chunks: this.script.chunks.slice(this.pbegincodehash)\n          });\n\n          // Drop the signatures, since there's no way for a signature to sign itself\n          for (var k = 0; k < nSigsCount; k++) {\n            bufSig = this.stack[this.stack.length - isig - k];\n            subscript.findAndDelete(new Script().add(bufSig));\n          }\n\n          fSuccess = true;\n          while (fSuccess && nSigsCount > 0) {\n            // valtype& vchSig  = stacktop(-isig);\n            bufSig = this.stack[this.stack.length - isig];\n            // valtype& vchPubKey = stacktop(-ikey);\n            bufPubkey = this.stack[this.stack.length - ikey];\n\n            if (!this.checkSignatureEncoding(bufSig) || !this.checkPubkeyEncoding(bufPubkey)) {\n              return false;\n            }\n\n            var fOk;\n            try {\n              sig = Signature.fromTxFormat(bufSig);\n              pubkey = PublicKey.fromBuffer(bufPubkey, false);\n              fOk = this.tx.verifySignature(sig, pubkey, this.nin, subscript);\n            } catch (e) {\n              //invalid sig or pubkey\n              fOk = false;\n            }\n\n            if (fOk) {\n              isig++;\n              nSigsCount--;\n            }\n            ikey++;\n            nKeysCount--;\n\n            // If there are more signatures left than keys left,\n            // then too many signatures have failed\n            if (nSigsCount > nKeysCount) {\n              fSuccess = false;\n            }\n          }\n\n          // Clean up stack of actual arguments\n          while (i-- > 1) {\n            this.stack.pop();\n          }\n\n          // A bug causes CHECKMULTISIG to consume one extra argument\n          // whose contents were not checked in any way.\n          //\n          // Unfortunately this is a potential source of mutability,\n          // so optionally verify it is exactly equal to zero prior\n          // to removing it from the stack.\n          if (this.stack.length < 1) {\n            this.errstr = 'SCRIPT_ERR_INVALID_STACK_OPERATION';\n            return false;\n          }\n          if ((this.flags & Interpreter.SCRIPT_VERIFY_NULLDUMMY) && this.stack[this.stack.length - 1].length) {\n            this.errstr = 'SCRIPT_ERR_SIG_NULLDUMMY';\n            return false;\n          }\n          this.stack.pop();\n\n          this.stack.push(fSuccess ? Interpreter.true : Interpreter.false);\n\n          if (opcodenum === Opcode.OP_CHECKMULTISIGVERIFY) {\n            if (fSuccess) {\n              this.stack.pop();\n            } else {\n              this.errstr = 'SCRIPT_ERR_CHECKMULTISIGVERIFY';\n              return false;\n            }\n          }\n        }\n        break;\n\n      default:\n        this.errstr = 'SCRIPT_ERR_BAD_OPCODE';\n        return false;\n    }\n  }\n\n  return true;\n};\n\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,CAAC,GAAGC,OAAO,CAAC,QAAQ,CAAC;AAEzB,IAAIC,MAAM,GAAGD,OAAO,CAAC,UAAU,CAAC;AAChC,IAAIE,MAAM,GAAGF,OAAO,CAAC,WAAW,CAAC;AACjC,IAAIG,EAAE,GAAGH,OAAO,CAAC,cAAc,CAAC;AAChC,IAAII,IAAI,GAAGJ,OAAO,CAAC,gBAAgB,CAAC;AACpC,IAAIK,SAAS,GAAGL,OAAO,CAAC,qBAAqB,CAAC;AAC9C,IAAIM,SAAS,GAAGN,OAAO,CAAC,cAAc,CAAC;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIO,WAAW,GAAG,SAASA,WAAW,CAACC,GAAG,EAAE;EAC1C,IAAI,EAAE,IAAI,YAAYD,WAAW,CAAC,EAAE;IAClC,OAAO,IAAIA,WAAW,CAACC,GAAG,CAAC;EAC7B;EACA,IAAIA,GAAG,EAAE;IACP,IAAI,CAACC,UAAU,EAAE;IACjB,IAAI,CAACC,GAAG,CAACF,GAAG,CAAC;EACf,CAAC,MAAM;IACL,IAAI,CAACC,UAAU,EAAE;EACnB;AACF,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAF,WAAW,CAACI,SAAS,CAACC,MAAM,GAAG,UAASC,SAAS,EAAEC,YAAY,EAAEC,EAAE,EAAEC,GAAG,EAAEC,KAAK,EAAE;EAC/E,IAAIC,WAAW,GAAGlB,OAAO,CAAC,gBAAgB,CAAC;EAC3C,IAAID,CAAC,CAACoB,WAAW,CAACJ,EAAE,CAAC,EAAE;IACrBA,EAAE,GAAG,IAAIG,WAAW,EAAE;EACxB;EACA,IAAInB,CAAC,CAACoB,WAAW,CAACH,GAAG,CAAC,EAAE;IACtBA,GAAG,GAAG,CAAC;EACT;EACA,IAAIjB,CAAC,CAACoB,WAAW,CAACF,KAAK,CAAC,EAAE;IACxBA,KAAK,GAAG,CAAC;EACX;EACA,IAAI,CAACP,GAAG,CAAC;IACPU,MAAM,EAAEP,SAAS;IACjBE,EAAE,EAAEA,EAAE;IACNC,GAAG,EAAEA,GAAG;IACRC,KAAK,EAAEA;EACT,CAAC,CAAC;EACF,IAAII,SAAS;EAEb,IAAI,CAACJ,KAAK,GAAGV,WAAW,CAACe,yBAAyB,MAAM,CAAC,IAAI,CAACT,SAAS,CAACU,UAAU,EAAE,EAAE;IACpF,IAAI,CAACC,MAAM,GAAG,yBAAyB;IACvC,OAAO,KAAK;EACd;;EAEA;EACA,IAAI,CAAC,IAAI,CAACC,QAAQ,EAAE,EAAE;IACpB,OAAO,KAAK;EACd;EAEA,IAAIR,KAAK,GAAGV,WAAW,CAACmB,kBAAkB,EAAE;IAC1CL,SAAS,GAAG,IAAI,CAACM,KAAK,CAACC,KAAK,EAAE;EAChC;EAEA,IAAID,KAAK,GAAG,IAAI,CAACA,KAAK;EACtB,IAAI,CAAClB,UAAU,EAAE;EACjB,IAAI,CAACC,GAAG,CAAC;IACPU,MAAM,EAAEN,YAAY;IACpBa,KAAK,EAAEA,KAAK;IACZZ,EAAE,EAAEA,EAAE;IACNC,GAAG,EAAEA,GAAG;IACRC,KAAK,EAAEA;EACT,CAAC,CAAC;;EAEF;EACA,IAAI,CAAC,IAAI,CAACQ,QAAQ,EAAE,EAAE;IACpB,OAAO,KAAK;EACd;EAEA,IAAI,IAAI,CAACE,KAAK,CAACE,MAAM,KAAK,CAAC,EAAE;IAC3B,IAAI,CAACL,MAAM,GAAG,iCAAiC;IAC/C,OAAO,KAAK;EACd;EAEA,IAAIM,GAAG,GAAG,IAAI,CAACH,KAAK,CAAC,IAAI,CAACA,KAAK,CAACE,MAAM,GAAG,CAAC,CAAC;EAC3C,IAAI,CAACtB,WAAW,CAACwB,UAAU,CAACD,GAAG,CAAC,EAAE;IAChC,IAAI,CAACN,MAAM,GAAG,gCAAgC;IAC9C,OAAO,KAAK;EACd;;EAEA;EACA,IAAKP,KAAK,GAAGV,WAAW,CAACmB,kBAAkB,IAAKZ,YAAY,CAACkB,eAAe,EAAE,EAAE;IAC9E;IACA,IAAI,CAACnB,SAAS,CAACU,UAAU,EAAE,EAAE;MAC3B,IAAI,CAACC,MAAM,GAAG,yBAAyB;MACvC,OAAO,KAAK;IACd;;IAEA;IACA;IACA;IACA,IAAIH,SAAS,CAACQ,MAAM,KAAK,CAAC,EAAE;MAC1B,MAAM,IAAII,KAAK,CAAC,mCAAmC,CAAC;IACtD;IAEA,IAAIC,sBAAsB,GAAGb,SAAS,CAACA,SAAS,CAACQ,MAAM,GAAG,CAAC,CAAC;IAC5D,IAAIM,YAAY,GAAGlC,MAAM,CAACmC,UAAU,CAACF,sBAAsB,CAAC;IAC5Db,SAAS,CAACgB,GAAG,EAAE;IAEf,IAAI,CAAC5B,UAAU,EAAE;IACjB,IAAI,CAACC,GAAG,CAAC;MACPU,MAAM,EAAEe,YAAY;MACpBR,KAAK,EAAEN,SAAS;MAChBN,EAAE,EAAEA,EAAE;MACNC,GAAG,EAAEA,GAAG;MACRC,KAAK,EAAEA;IACT,CAAC,CAAC;;IAEF;IACA,IAAI,CAAC,IAAI,CAACQ,QAAQ,EAAE,EAAE;MACpB,OAAO,KAAK;IACd;IAEA,IAAIJ,SAAS,CAACQ,MAAM,KAAK,CAAC,EAAE;MAC1B,IAAI,CAACL,MAAM,GAAG,qCAAqC;MACnD,OAAO,KAAK;IACd;IAEA,IAAI,CAACjB,WAAW,CAACwB,UAAU,CAACV,SAAS,CAACA,SAAS,CAACQ,MAAM,GAAG,CAAC,CAAC,CAAC,EAAE;MAC5D,IAAI,CAACL,MAAM,GAAG,qCAAqC;MACnD,OAAO,KAAK;IACd,CAAC,MAAM;MACL,OAAO,IAAI;IACb;EACF;EAEA,OAAO,IAAI;AACb,CAAC;AAEDc,MAAM,CAACC,OAAO,GAAGhC,WAAW;AAE5BA,WAAW,CAACI,SAAS,CAACF,UAAU,GAAG,UAASD,GAAG,EAAE;EAC/C,IAAI,CAACmB,KAAK,GAAG,EAAE;EACf,IAAI,CAACa,QAAQ,GAAG,EAAE;EAClB,IAAI,CAACC,EAAE,GAAG,CAAC;EACX,IAAI,CAACC,cAAc,GAAG,CAAC;EACvB,IAAI,CAACC,QAAQ,GAAG,CAAC;EACjB,IAAI,CAACC,MAAM,GAAG,EAAE;EAChB,IAAI,CAACpB,MAAM,GAAG,EAAE;EAChB,IAAI,CAACP,KAAK,GAAG,CAAC;AAChB,CAAC;AAEDV,WAAW,CAACI,SAAS,CAACD,GAAG,GAAG,UAASF,GAAG,EAAE;EACxC,IAAI,CAACY,MAAM,GAAGZ,GAAG,CAACY,MAAM,IAAI,IAAI,CAACA,MAAM;EACvC,IAAI,CAACL,EAAE,GAAGP,GAAG,CAACO,EAAE,IAAI,IAAI,CAACA,EAAE;EAC3B,IAAI,CAACC,GAAG,GAAG,OAAOR,GAAG,CAACQ,GAAG,KAAK,WAAW,GAAGR,GAAG,CAACQ,GAAG,GAAG,IAAI,CAACA,GAAG;EAC9D,IAAI,CAACW,KAAK,GAAGnB,GAAG,CAACmB,KAAK,IAAI,IAAI,CAACA,KAAK;EACpC,IAAI,CAACa,QAAQ,GAAGhC,GAAG,CAACqC,MAAM,IAAI,IAAI,CAACL,QAAQ;EAC3C,IAAI,CAACC,EAAE,GAAG,OAAOjC,GAAG,CAACiC,EAAE,KAAK,WAAW,GAAGjC,GAAG,CAACiC,EAAE,GAAG,IAAI,CAACA,EAAE;EAC1D,IAAI,CAACC,cAAc,GAAG,OAAOlC,GAAG,CAACkC,cAAc,KAAK,WAAW,GAAGlC,GAAG,CAACkC,cAAc,GAAG,IAAI,CAACA,cAAc;EAC1G,IAAI,CAACC,QAAQ,GAAG,OAAOnC,GAAG,CAACmC,QAAQ,KAAK,WAAW,GAAGnC,GAAG,CAACmC,QAAQ,GAAG,IAAI,CAACA,QAAQ;EAClF,IAAI,CAACC,MAAM,GAAGpC,GAAG,CAACoC,MAAM,IAAI,IAAI,CAACA,MAAM;EACvC,IAAI,CAACpB,MAAM,GAAGhB,GAAG,CAACgB,MAAM,IAAI,IAAI,CAACA,MAAM;EACvC,IAAI,CAACP,KAAK,GAAG,OAAOT,GAAG,CAACS,KAAK,KAAK,WAAW,GAAGT,GAAG,CAACS,KAAK,GAAG,IAAI,CAACA,KAAK;AACxE,CAAC;AAEDV,WAAW,CAACuC,IAAI,GAAG,IAAIC,MAAM,CAAC,CAAC,CAAC,CAAC,CAAC;AAClCxC,WAAW,CAACyC,KAAK,GAAG,IAAID,MAAM,CAAC,EAAE,CAAC;AAElCxC,WAAW,CAAC0C,uBAAuB,GAAG,GAAG;AAEzC1C,WAAW,CAAC2C,kBAAkB,GAAG,SAAS;AAC1C3C,WAAW,CAAC4C,qBAAqB,GAAG,IAAIhD,EAAE,CAACI,WAAW,CAAC2C,kBAAkB,CAAC;;AAE1E;AACA;AACA3C,WAAW,CAAC6C,kBAAkB,GAAG,CAAC;;AAElC;AACA7C,WAAW,CAACmB,kBAAkB,GAAI,CAAC,IAAI,CAAE;;AAEzC;AACA;AACA;AACAnB,WAAW,CAAC8C,uBAAuB,GAAI,CAAC,IAAI,CAAE;;AAE9C;AACA9C,WAAW,CAAC+C,oBAAoB,GAAI,CAAC,IAAI,CAAE;;AAE3C;AACA;AACA/C,WAAW,CAACgD,mBAAmB,GAAI,CAAC,IAAI,CAAE;;AAE1C;AACAhD,WAAW,CAACiD,uBAAuB,GAAI,CAAC,IAAI,CAAE;;AAE9C;AACAjD,WAAW,CAACe,yBAAyB,GAAI,CAAC,IAAI,CAAE;;AAEhD;AACA;AACA;AACA;AACA;AACAf,WAAW,CAACkD,yBAAyB,GAAI,CAAC,IAAI,CAAE;;AAEhD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAlD,WAAW,CAACmD,wCAAwC,GAAI,CAAC,IAAI,CAAE;;AAE/D;AACAnD,WAAW,CAACoD,iCAAiC,GAAI,CAAC,IAAI,CAAE;AAExDpD,WAAW,CAACwB,UAAU,GAAG,UAASD,GAAG,EAAE;EACrC,KAAK,IAAI8B,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG9B,GAAG,CAACD,MAAM,EAAE+B,CAAC,EAAE,EAAE;IACnC,IAAI9B,GAAG,CAAC8B,CAAC,CAAC,KAAK,CAAC,EAAE;MAChB;MACA,IAAIA,CAAC,KAAK9B,GAAG,CAACD,MAAM,GAAG,CAAC,IAAIC,GAAG,CAAC8B,CAAC,CAAC,KAAK,IAAI,EAAE;QAC3C,OAAO,KAAK;MACd;MACA,OAAO,IAAI;IACb;EACF;EACA,OAAO,KAAK;AACd,CAAC;;AAED;AACA;AACA;AACArD,WAAW,CAACI,SAAS,CAACkD,sBAAsB,GAAG,UAAS/B,GAAG,EAAE;EAC3D,IAAIgC,GAAG;EACP,IAAI,CAAC,IAAI,CAAC7C,KAAK,IAAIV,WAAW,CAAC+C,oBAAoB,GAAG/C,WAAW,CAACgD,mBAAmB,GAAGhD,WAAW,CAAC8C,uBAAuB,CAAC,MAAM,CAAC,IAAI,CAAChD,SAAS,CAAC0D,OAAO,CAACjC,GAAG,CAAC,EAAE;IAC9J,IAAI,CAACN,MAAM,GAAG,mCAAmC;IACjD,OAAO,KAAK;EACd,CAAC,MAAM,IAAI,CAAC,IAAI,CAACP,KAAK,GAAGV,WAAW,CAACgD,mBAAmB,MAAM,CAAC,EAAE;IAC/DO,GAAG,GAAGzD,SAAS,CAAC2D,YAAY,CAAClC,GAAG,CAAC;IACjC,IAAI,CAACgC,GAAG,CAACG,OAAO,EAAE,EAAE;MAClB,IAAI,CAACzC,MAAM,GAAG,2BAA2B;MACzC,OAAO,KAAK;IACd;EACF,CAAC,MAAM,IAAI,CAAC,IAAI,CAACP,KAAK,GAAGV,WAAW,CAAC8C,uBAAuB,MAAM,CAAC,EAAE;IACnES,GAAG,GAAGzD,SAAS,CAAC2D,YAAY,CAAClC,GAAG,CAAC;IACjC,IAAI,CAACgC,GAAG,CAACI,kBAAkB,EAAE,EAAE;MAC7B,IAAI,CAAC1C,MAAM,GAAG,yBAAyB;MACvC,OAAO,KAAK;IACd;EACF;EACA,OAAO,IAAI;AACb,CAAC;;AAED;AACA;AACA;AACAjB,WAAW,CAACI,SAAS,CAACwD,mBAAmB,GAAG,UAASrC,GAAG,EAAE;EACxD,IAAI,CAAC,IAAI,CAACb,KAAK,GAAGV,WAAW,CAAC8C,uBAAuB,MAAM,CAAC,IAAI,CAAC/C,SAAS,CAAC8D,OAAO,CAACtC,GAAG,CAAC,EAAE;IACvF,IAAI,CAACN,MAAM,GAAG,uBAAuB;IACrC,OAAO,KAAK;EACd;EACA,OAAO,IAAI;AACb,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAjB,WAAW,CAACI,SAAS,CAACc,QAAQ,GAAG,YAAW;EAC1C,IAAI,IAAI,CAACL,MAAM,CAACiD,QAAQ,EAAE,CAACxC,MAAM,GAAG,KAAK,EAAE;IACzC,IAAI,CAACL,MAAM,GAAG,wBAAwB;IACtC,OAAO,KAAK;EACd;EAEA,IAAI;IACF,OAAO,IAAI,CAACiB,EAAE,GAAG,IAAI,CAACrB,MAAM,CAACkD,MAAM,CAACzC,MAAM,EAAE;MAC1C,IAAI0C,QAAQ,GAAG,IAAI,CAACC,IAAI,EAAE;MAC1B,IAAI,CAACD,QAAQ,EAAE;QACb,OAAO,KAAK;MACd;IACF;;IAEA;IACA,IAAI,IAAI,CAAC5C,KAAK,CAACE,MAAM,GAAG,IAAI,CAACW,QAAQ,CAACX,MAAM,GAAG,IAAI,EAAE;MACnD,IAAI,CAACL,MAAM,GAAG,uBAAuB;MACrC,OAAO,KAAK;IACd;EACF,CAAC,CAAC,OAAOiD,CAAC,EAAE;IACV,IAAI,CAACjD,MAAM,GAAG,4BAA4B,GAAGiD,CAAC;IAC9C,OAAO,KAAK;EACd;EAEA,IAAI,IAAI,CAAC7B,MAAM,CAACf,MAAM,GAAG,CAAC,EAAE;IAC1B,IAAI,CAACL,MAAM,GAAG,mCAAmC;IACjD,OAAO,KAAK;EACd;EAEA,OAAO,IAAI;AACb,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAjB,WAAW,CAACI,SAAS,CAAC+D,aAAa,GAAG,UAASC,SAAS,EAAE;EAExD;EACA;EACA;EACA,IAAI,EACD,IAAI,CAAC5D,EAAE,CAAC4D,SAAS,GAAIpE,WAAW,CAAC2C,kBAAkB,IAAIyB,SAAS,CAACC,EAAE,CAACrE,WAAW,CAAC4C,qBAAqB,CAAC,IACtG,IAAI,CAACpC,EAAE,CAAC4D,SAAS,IAAIpE,WAAW,CAAC2C,kBAAkB,IAAIyB,SAAS,CAACE,GAAG,CAACtE,WAAW,CAAC4C,qBAAqB,CAAE,CAC1G,EAAE;IACD,OAAO,KAAK;EACd;;EAEA;EACA;EACA,IAAIwB,SAAS,CAACG,EAAE,CAAC,IAAI3E,EAAE,CAAC,IAAI,CAACY,EAAE,CAAC4D,SAAS,CAAC,CAAC,EAAE;IAC3C,OAAO,KAAK;EACd;;EAEA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA,IAAI,CAAC,IAAI,CAAC5D,EAAE,CAACgE,MAAM,CAAC,IAAI,CAAC/D,GAAG,CAAC,CAACgE,OAAO,EAAE,EAAE;IACvC,OAAO,KAAK;EACd;EAEA,OAAO,IAAI;AACb,CAAC;;AAED;AACA;AACA;AACA;AACAzE,WAAW,CAACI,SAAS,CAAC6D,IAAI,GAAG,YAAW;EAEtC,IAAIS,eAAe,GAAG,CAAC,IAAI,CAAChE,KAAK,GAAGV,WAAW,CAACkD,yBAAyB,MAAM,CAAC;;EAEhF;EACA,IAAIyB,KAAK,GAAI,IAAI,CAACtC,MAAM,CAACuC,OAAO,CAAC,KAAK,CAAC,KAAK,CAAC,CAAE;EAC/C,IAAIrD,GAAG,EAAEsD,IAAI,EAAEC,IAAI,EAAEC,OAAO,EAAEC,CAAC,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,EAAEC,GAAG,EAAEC,GAAG,EAAEC,MAAM,EAAEC,SAAS,EAAEC,SAAS;EACnF,IAAIjC,GAAG,EAAEkC,MAAM;EACf,IAAIC,MAAM,EAAE1B,QAAQ;;EAEpB;EACA,IAAI2B,KAAK,GAAG,IAAI,CAAC9E,MAAM,CAACkD,MAAM,CAAC,IAAI,CAAC7B,EAAE,CAAC;EACvC,IAAI,CAACA,EAAE,EAAE;EACT,IAAI0D,SAAS,GAAGD,KAAK,CAACC,SAAS;EAC/B,IAAIpG,CAAC,CAACoB,WAAW,CAACgF,SAAS,CAAC,EAAE;IAC5B,IAAI,CAAC3E,MAAM,GAAG,6BAA6B;IAC3C,OAAO,KAAK;EACd;EACA,IAAI0E,KAAK,CAACpE,GAAG,IAAIoE,KAAK,CAACpE,GAAG,CAACD,MAAM,GAAGtB,WAAW,CAAC0C,uBAAuB,EAAE;IACvE,IAAI,CAACzB,MAAM,GAAG,sBAAsB;IACpC,OAAO,KAAK;EACd;;EAEA;EACA,IAAI2E,SAAS,GAAGjG,MAAM,CAACkG,KAAK,IAAI,EAAG,IAAI,CAACzD,QAAS,GAAG,GAAG,EAAE;IACvD,IAAI,CAACnB,MAAM,GAAG,qBAAqB;IACnC,OAAO,KAAK;EACd;EAGA,IAAI2E,SAAS,KAAKjG,MAAM,CAACmG,MAAM,IAC7BF,SAAS,KAAKjG,MAAM,CAACoG,SAAS,IAC9BH,SAAS,KAAKjG,MAAM,CAACqG,OAAO,IAC5BJ,SAAS,KAAKjG,MAAM,CAACsG,QAAQ,IAC7BL,SAAS,KAAKjG,MAAM,CAACuG,SAAS,IAC9BN,SAAS,KAAKjG,MAAM,CAACwG,MAAM,IAC3BP,SAAS,KAAKjG,MAAM,CAACyG,KAAK,IAC1BR,SAAS,KAAKjG,MAAM,CAAC0G,MAAM,IAC3BT,SAAS,KAAKjG,MAAM,CAAC2G,OAAO,IAC5BV,SAAS,KAAKjG,MAAM,CAAC4G,OAAO,IAC5BX,SAAS,KAAKjG,MAAM,CAAC6G,MAAM,IAC3BZ,SAAS,KAAKjG,MAAM,CAAC8G,MAAM,IAC3Bb,SAAS,KAAKjG,MAAM,CAAC+G,MAAM,IAC3Bd,SAAS,KAAKjG,MAAM,CAACgH,SAAS,IAC9Bf,SAAS,KAAKjG,MAAM,CAACiH,SAAS,EAAE;IAChC,IAAI,CAAC3F,MAAM,GAAG,4BAA4B;IAC1C,OAAO,KAAK;EACd;EAEA,IAAI0D,KAAK,IAAI,CAAC,IAAIiB,SAAS,IAAIA,SAAS,IAAIjG,MAAM,CAACkH,YAAY,EAAE;IAC/D,IAAInC,eAAe,IAAI,CAAC,IAAI,CAAC7D,MAAM,CAACiG,gBAAgB,CAAC,IAAI,CAAC5E,EAAE,GAAG,CAAC,CAAC,EAAE;MACjE,IAAI,CAACjB,MAAM,GAAG,wBAAwB;MACtC,OAAO,KAAK;IACd;IACA,IAAI,CAAC0E,KAAK,CAACpE,GAAG,EAAE;MACd,IAAI,CAACH,KAAK,CAAC2F,IAAI,CAAC/G,WAAW,CAACyC,KAAK,CAAC;IACpC,CAAC,MAAM,IAAIkD,KAAK,CAACqB,GAAG,KAAKrB,KAAK,CAACpE,GAAG,CAACD,MAAM,EAAE;MACzC,MAAM,IAAII,KAAK,CAAC,kDAAkD,CAAC;IACrE,CAAC,MAAM;MACL,IAAI,CAACN,KAAK,CAAC2F,IAAI,CAACpB,KAAK,CAACpE,GAAG,CAAC;IAC5B;EACF,CAAC,MAAM,IAAIoD,KAAK,IAAKhF,MAAM,CAACsH,KAAK,IAAIrB,SAAS,IAAIA,SAAS,IAAIjG,MAAM,CAACuH,QAAS,EAAE;IAC/E,QAAQtB,SAAS;MACf;MACA,KAAKjG,MAAM,CAACwH,UAAU;MACtB,KAAKxH,MAAM,CAACyH,IAAI;MAChB,KAAKzH,MAAM,CAAC0H,IAAI;MAChB,KAAK1H,MAAM,CAAC2H,IAAI;MAChB,KAAK3H,MAAM,CAAC4H,IAAI;MAChB,KAAK5H,MAAM,CAAC6H,IAAI;MAChB,KAAK7H,MAAM,CAAC8H,IAAI;MAChB,KAAK9H,MAAM,CAAC+H,IAAI;MAChB,KAAK/H,MAAM,CAACgI,IAAI;MAChB,KAAKhI,MAAM,CAACiI,IAAI;MAChB,KAAKjI,MAAM,CAACkI,KAAK;MACjB,KAAKlI,MAAM,CAACmI,KAAK;MACjB,KAAKnI,MAAM,CAACoI,KAAK;MACjB,KAAKpI,MAAM,CAACqI,KAAK;MACjB,KAAKrI,MAAM,CAACsI,KAAK;MACjB,KAAKtI,MAAM,CAACuI,KAAK;MACjB,KAAKvI,MAAM,CAACkG,KAAK;QACf;UACE;UACA;UACAb,CAAC,GAAGY,SAAS,IAAIjG,MAAM,CAACyH,IAAI,GAAG,CAAC,CAAC;UACjC7F,GAAG,GAAG,IAAI3B,EAAE,CAACoF,CAAC,CAAC,CAACmD,iBAAiB,EAAE;UACnC,IAAI,CAAC/G,KAAK,CAAC2F,IAAI,CAACxF,GAAG,CAAC;UACpB;UACA;QACF;;QACA;;MAGA;MACA;MACA;MACF,KAAK5B,MAAM,CAACyI,MAAM;QAChB;MAEF,KAAKzI,MAAM,CAAC0I,OAAO;MACnB,KAAK1I,MAAM,CAAC2I,sBAAsB;QAEhC,IAAI,EAAE,IAAI,CAAC5H,KAAK,GAAGV,WAAW,CAACoD,iCAAiC,CAAC,EAAE;UACjE;UACA,IAAI,IAAI,CAAC1C,KAAK,GAAGV,WAAW,CAACmD,wCAAwC,EAAE;YACrE,IAAI,CAAClC,MAAM,GAAG,uCAAuC;YACrD,OAAO,KAAK;UACd;UACA;QACF;QAEA,IAAI,IAAI,CAACG,KAAK,CAACE,MAAM,GAAG,CAAC,EAAE;UACzB,IAAI,CAACL,MAAM,GAAG,oCAAoC;UAClD,OAAO,KAAK;QACd;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,IAAImD,SAAS,GAAGxE,EAAE,CAAC2I,mBAAmB,CAAC,IAAI,CAACnH,KAAK,CAAC,IAAI,CAACA,KAAK,CAACE,MAAM,GAAG,CAAC,CAAC,EAAEoD,eAAe,EAAE,CAAC,CAAC;;QAE7F;QACA;QACA;QACA,IAAIN,SAAS,CAACC,EAAE,CAAC,IAAIzE,EAAE,CAAC,CAAC,CAAC,CAAC,EAAE;UAC3B,IAAI,CAACqB,MAAM,GAAG,8BAA8B;UAC5C,OAAO,KAAK;QACd;;QAEA;QACA,IAAI,CAAC,IAAI,CAACkD,aAAa,CAACC,SAAS,CAAC,EAAE;UAClC,IAAI,CAACnD,MAAM,GAAG,iCAAiC;UAC/C,OAAO,KAAK;QACd;QACA;MAEF,KAAKtB,MAAM,CAAC6I,OAAO;MACnB,KAAK7I,MAAM,CAAC8I,OAAO;MACnB,KAAK9I,MAAM,CAAC+I,OAAO;MACnB,KAAK/I,MAAM,CAACgJ,OAAO;MACnB,KAAKhJ,MAAM,CAACiJ,OAAO;MACnB,KAAKjJ,MAAM,CAACkJ,OAAO;MACnB,KAAKlJ,MAAM,CAACmJ,OAAO;MACnB,KAAKnJ,MAAM,CAACoJ,OAAO;MACnB,KAAKpJ,MAAM,CAACqJ,QAAQ;QAClB;UACE,IAAI,IAAI,CAACtI,KAAK,GAAGV,WAAW,CAACmD,wCAAwC,EAAE;YACrE,IAAI,CAAClC,MAAM,GAAG,uCAAuC;YACrD,OAAO,KAAK;UACd;QACF;QACA;MAEF,KAAKtB,MAAM,CAACsH,KAAK;MACjB,KAAKtH,MAAM,CAACsJ,QAAQ;QAClB;UACE;UACA;UACAvD,MAAM,GAAG,KAAK;UACd,IAAIf,KAAK,EAAE;YACT,IAAI,IAAI,CAACvD,KAAK,CAACE,MAAM,GAAG,CAAC,EAAE;cACzB,IAAI,CAACL,MAAM,GAAG,mCAAmC;cACjD,OAAO,KAAK;YACd;YACAM,GAAG,GAAG,IAAI,CAACH,KAAK,CAACU,GAAG,EAAE;YACtB4D,MAAM,GAAG1F,WAAW,CAACwB,UAAU,CAACD,GAAG,CAAC;YACpC,IAAIqE,SAAS,KAAKjG,MAAM,CAACsJ,QAAQ,EAAE;cACjCvD,MAAM,GAAG,CAACA,MAAM;YAClB;UACF;UACA,IAAI,CAACrD,MAAM,CAAC0E,IAAI,CAACrB,MAAM,CAAC;QAC1B;QACA;MAEF,KAAK/F,MAAM,CAACuJ,OAAO;QACjB;UACE,IAAI,IAAI,CAAC7G,MAAM,CAACf,MAAM,KAAK,CAAC,EAAE;YAC5B,IAAI,CAACL,MAAM,GAAG,mCAAmC;YACjD,OAAO,KAAK;UACd;UACA,IAAI,CAACoB,MAAM,CAAC,IAAI,CAACA,MAAM,CAACf,MAAM,GAAG,CAAC,CAAC,GAAG,CAAC,IAAI,CAACe,MAAM,CAAC,IAAI,CAACA,MAAM,CAACf,MAAM,GAAG,CAAC,CAAC;QAC5E;QACA;MAEF,KAAK3B,MAAM,CAACuH,QAAQ;QAClB;UACE,IAAI,IAAI,CAAC7E,MAAM,CAACf,MAAM,KAAK,CAAC,EAAE;YAC5B,IAAI,CAACL,MAAM,GAAG,mCAAmC;YACjD,OAAO,KAAK;UACd;UACA,IAAI,CAACoB,MAAM,CAACP,GAAG,EAAE;QACnB;QACA;MAEF,KAAKnC,MAAM,CAACwJ,SAAS;QACnB;UACE;UACA;UACA,IAAI,IAAI,CAAC/H,KAAK,CAACE,MAAM,GAAG,CAAC,EAAE;YACzB,IAAI,CAACL,MAAM,GAAG,oCAAoC;YAClD,OAAO,KAAK;UACd;UACAM,GAAG,GAAG,IAAI,CAACH,KAAK,CAAC,IAAI,CAACA,KAAK,CAACE,MAAM,GAAG,CAAC,CAAC;UACvCoE,MAAM,GAAG1F,WAAW,CAACwB,UAAU,CAACD,GAAG,CAAC;UACpC,IAAImE,MAAM,EAAE;YACV,IAAI,CAACtE,KAAK,CAACU,GAAG,EAAE;UAClB,CAAC,MAAM;YACL,IAAI,CAACb,MAAM,GAAG,mBAAmB;YACjC,OAAO,KAAK;UACd;QACF;QACA;MAEF,KAAKtB,MAAM,CAACyJ,SAAS;QACnB;UACE,IAAI,CAACnI,MAAM,GAAG,sBAAsB;UACpC,OAAO,KAAK;QACd;QACA;;MAGA;MACA;MACA;MACF,KAAKtB,MAAM,CAAC0J,aAAa;QACvB;UACE,IAAI,IAAI,CAACjI,KAAK,CAACE,MAAM,GAAG,CAAC,EAAE;YACzB,IAAI,CAACL,MAAM,GAAG,oCAAoC;YAClD,OAAO,KAAK;UACd;UACA,IAAI,CAACgB,QAAQ,CAAC8E,IAAI,CAAC,IAAI,CAAC3F,KAAK,CAACU,GAAG,EAAE,CAAC;QACtC;QACA;MAEF,KAAKnC,MAAM,CAAC2J,eAAe;QACzB;UACE,IAAI,IAAI,CAACrH,QAAQ,CAACX,MAAM,GAAG,CAAC,EAAE;YAC5B,IAAI,CAACL,MAAM,GAAG,uCAAuC;YACrD,OAAO,KAAK;UACd;UACA,IAAI,CAACG,KAAK,CAAC2F,IAAI,CAAC,IAAI,CAAC9E,QAAQ,CAACH,GAAG,EAAE,CAAC;QACtC;QACA;MAEF,KAAKnC,MAAM,CAAC4J,QAAQ;QAClB;UACE;UACA,IAAI,IAAI,CAACnI,KAAK,CAACE,MAAM,GAAG,CAAC,EAAE;YACzB,IAAI,CAACL,MAAM,GAAG,oCAAoC;YAClD,OAAO,KAAK;UACd;UACA,IAAI,CAACG,KAAK,CAACU,GAAG,EAAE;UAChB,IAAI,CAACV,KAAK,CAACU,GAAG,EAAE;QAClB;QACA;MAEF,KAAKnC,MAAM,CAAC6J,OAAO;QACjB;UACE;UACA,IAAI,IAAI,CAACpI,KAAK,CAACE,MAAM,GAAG,CAAC,EAAE;YACzB,IAAI,CAACL,MAAM,GAAG,oCAAoC;YAClD,OAAO,KAAK;UACd;UACA4D,IAAI,GAAG,IAAI,CAACzD,KAAK,CAAC,IAAI,CAACA,KAAK,CAACE,MAAM,GAAG,CAAC,CAAC;UACxCwD,IAAI,GAAG,IAAI,CAAC1D,KAAK,CAAC,IAAI,CAACA,KAAK,CAACE,MAAM,GAAG,CAAC,CAAC;UACxC,IAAI,CAACF,KAAK,CAAC2F,IAAI,CAAClC,IAAI,CAAC;UACrB,IAAI,CAACzD,KAAK,CAAC2F,IAAI,CAACjC,IAAI,CAAC;QACvB;QACA;MAEF,KAAKnF,MAAM,CAAC8J,OAAO;QACjB;UACE;UACA,IAAI,IAAI,CAACrI,KAAK,CAACE,MAAM,GAAG,CAAC,EAAE;YACzB,IAAI,CAACL,MAAM,GAAG,oCAAoC;YAClD,OAAO,KAAK;UACd;UACA4D,IAAI,GAAG,IAAI,CAACzD,KAAK,CAAC,IAAI,CAACA,KAAK,CAACE,MAAM,GAAG,CAAC,CAAC;UACxCwD,IAAI,GAAG,IAAI,CAAC1D,KAAK,CAAC,IAAI,CAACA,KAAK,CAACE,MAAM,GAAG,CAAC,CAAC;UACxC,IAAIoI,IAAI,GAAG,IAAI,CAACtI,KAAK,CAAC,IAAI,CAACA,KAAK,CAACE,MAAM,GAAG,CAAC,CAAC;UAC5C,IAAI,CAACF,KAAK,CAAC2F,IAAI,CAAClC,IAAI,CAAC;UACrB,IAAI,CAACzD,KAAK,CAAC2F,IAAI,CAACjC,IAAI,CAAC;UACrB,IAAI,CAAC1D,KAAK,CAAC2F,IAAI,CAAC2C,IAAI,CAAC;QACvB;QACA;MAEF,KAAK/J,MAAM,CAACgK,QAAQ;QAClB;UACE;UACA,IAAI,IAAI,CAACvI,KAAK,CAACE,MAAM,GAAG,CAAC,EAAE;YACzB,IAAI,CAACL,MAAM,GAAG,oCAAoC;YAClD,OAAO,KAAK;UACd;UACA4D,IAAI,GAAG,IAAI,CAACzD,KAAK,CAAC,IAAI,CAACA,KAAK,CAACE,MAAM,GAAG,CAAC,CAAC;UACxCwD,IAAI,GAAG,IAAI,CAAC1D,KAAK,CAAC,IAAI,CAACA,KAAK,CAACE,MAAM,GAAG,CAAC,CAAC;UACxC,IAAI,CAACF,KAAK,CAAC2F,IAAI,CAAClC,IAAI,CAAC;UACrB,IAAI,CAACzD,KAAK,CAAC2F,IAAI,CAACjC,IAAI,CAAC;QACvB;QACA;MAEF,KAAKnF,MAAM,CAACiK,OAAO;QACjB;UACE;UACA,IAAI,IAAI,CAACxI,KAAK,CAACE,MAAM,GAAG,CAAC,EAAE;YACzB,IAAI,CAACL,MAAM,GAAG,oCAAoC;YAClD,OAAO,KAAK;UACd;UACA8D,OAAO,GAAG,IAAI,CAAC3D,KAAK,CAACyI,MAAM,CAAC,IAAI,CAACzI,KAAK,CAACE,MAAM,GAAG,CAAC,EAAE,CAAC,CAAC;UACrD,IAAI,CAACF,KAAK,CAAC2F,IAAI,CAAChC,OAAO,CAAC,CAAC,CAAC,CAAC;UAC3B,IAAI,CAAC3D,KAAK,CAAC2F,IAAI,CAAChC,OAAO,CAAC,CAAC,CAAC,CAAC;QAC7B;QACA;MAEF,KAAKpF,MAAM,CAACmK,QAAQ;QAClB;UACE;UACA,IAAI,IAAI,CAAC1I,KAAK,CAACE,MAAM,GAAG,CAAC,EAAE;YACzB,IAAI,CAACL,MAAM,GAAG,oCAAoC;YAClD,OAAO,KAAK;UACd;UACA8D,OAAO,GAAG,IAAI,CAAC3D,KAAK,CAACyI,MAAM,CAAC,IAAI,CAACzI,KAAK,CAACE,MAAM,GAAG,CAAC,EAAE,CAAC,CAAC;UACrD,IAAI,CAACF,KAAK,CAAC2F,IAAI,CAAChC,OAAO,CAAC,CAAC,CAAC,CAAC;UAC3B,IAAI,CAAC3D,KAAK,CAAC2F,IAAI,CAAChC,OAAO,CAAC,CAAC,CAAC,CAAC;QAC7B;QACA;MAEF,KAAKpF,MAAM,CAACoK,QAAQ;QAClB;UACE;UACA,IAAI,IAAI,CAAC3I,KAAK,CAACE,MAAM,GAAG,CAAC,EAAE;YACzB,IAAI,CAACL,MAAM,GAAG,oCAAoC;YAClD,OAAO,KAAK;UACd;UACAM,GAAG,GAAG,IAAI,CAACH,KAAK,CAAC,IAAI,CAACA,KAAK,CAACE,MAAM,GAAG,CAAC,CAAC;UACvCoE,MAAM,GAAG1F,WAAW,CAACwB,UAAU,CAACD,GAAG,CAAC;UACpC,IAAImE,MAAM,EAAE;YACV,IAAI,CAACtE,KAAK,CAAC2F,IAAI,CAACxF,GAAG,CAAC;UACtB;QACF;QACA;MAEF,KAAK5B,MAAM,CAACqK,QAAQ;QAClB;UACE;UACAzI,GAAG,GAAG,IAAI3B,EAAE,CAAC,IAAI,CAACwB,KAAK,CAACE,MAAM,CAAC,CAAC6G,iBAAiB,EAAE;UACnD,IAAI,CAAC/G,KAAK,CAAC2F,IAAI,CAACxF,GAAG,CAAC;QACtB;QACA;MAEF,KAAK5B,MAAM,CAACsK,OAAO;QACjB;UACE;UACA,IAAI,IAAI,CAAC7I,KAAK,CAACE,MAAM,GAAG,CAAC,EAAE;YACzB,IAAI,CAACL,MAAM,GAAG,oCAAoC;YAClD,OAAO,KAAK;UACd;UACA,IAAI,CAACG,KAAK,CAACU,GAAG,EAAE;QAClB;QACA;MAEF,KAAKnC,MAAM,CAACuK,MAAM;QAChB;UACE;UACA,IAAI,IAAI,CAAC9I,KAAK,CAACE,MAAM,GAAG,CAAC,EAAE;YACzB,IAAI,CAACL,MAAM,GAAG,oCAAoC;YAClD,OAAO,KAAK;UACd;UACA,IAAI,CAACG,KAAK,CAAC2F,IAAI,CAAC,IAAI,CAAC3F,KAAK,CAAC,IAAI,CAACA,KAAK,CAACE,MAAM,GAAG,CAAC,CAAC,CAAC;QACpD;QACA;MAEF,KAAK3B,MAAM,CAACwK,MAAM;QAChB;UACE;UACA,IAAI,IAAI,CAAC/I,KAAK,CAACE,MAAM,GAAG,CAAC,EAAE;YACzB,IAAI,CAACL,MAAM,GAAG,oCAAoC;YAClD,OAAO,KAAK;UACd;UACA,IAAI,CAACG,KAAK,CAACyI,MAAM,CAAC,IAAI,CAACzI,KAAK,CAACE,MAAM,GAAG,CAAC,EAAE,CAAC,CAAC;QAC7C;QACA;MAEF,KAAK3B,MAAM,CAACyK,OAAO;QACjB;UACE;UACA,IAAI,IAAI,CAAChJ,KAAK,CAACE,MAAM,GAAG,CAAC,EAAE;YACzB,IAAI,CAACL,MAAM,GAAG,oCAAoC;YAClD,OAAO,KAAK;UACd;UACA,IAAI,CAACG,KAAK,CAAC2F,IAAI,CAAC,IAAI,CAAC3F,KAAK,CAAC,IAAI,CAACA,KAAK,CAACE,MAAM,GAAG,CAAC,CAAC,CAAC;QACpD;QACA;MAEF,KAAK3B,MAAM,CAAC0K,OAAO;MACnB,KAAK1K,MAAM,CAAC2K,OAAO;QACjB;UACE;UACA;UACA,IAAI,IAAI,CAAClJ,KAAK,CAACE,MAAM,GAAG,CAAC,EAAE;YACzB,IAAI,CAACL,MAAM,GAAG,oCAAoC;YAClD,OAAO,KAAK;UACd;UACAM,GAAG,GAAG,IAAI,CAACH,KAAK,CAAC,IAAI,CAACA,KAAK,CAACE,MAAM,GAAG,CAAC,CAAC;UACvC6D,EAAE,GAAGvF,EAAE,CAAC2I,mBAAmB,CAAChH,GAAG,EAAEmD,eAAe,CAAC;UACjDM,CAAC,GAAGG,EAAE,CAACoF,QAAQ,EAAE;UACjB,IAAI,CAACnJ,KAAK,CAACU,GAAG,EAAE;UAChB,IAAIkD,CAAC,GAAG,CAAC,IAAIA,CAAC,IAAI,IAAI,CAAC5D,KAAK,CAACE,MAAM,EAAE;YACnC,IAAI,CAACL,MAAM,GAAG,oCAAoC;YAClD,OAAO,KAAK;UACd;UACAM,GAAG,GAAG,IAAI,CAACH,KAAK,CAAC,IAAI,CAACA,KAAK,CAACE,MAAM,GAAG0D,CAAC,GAAG,CAAC,CAAC;UAC3C,IAAIY,SAAS,KAAKjG,MAAM,CAAC2K,OAAO,EAAE;YAChC,IAAI,CAAClJ,KAAK,CAACyI,MAAM,CAAC,IAAI,CAACzI,KAAK,CAACE,MAAM,GAAG0D,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;UACjD;UACA,IAAI,CAAC5D,KAAK,CAAC2F,IAAI,CAACxF,GAAG,CAAC;QACtB;QACA;MAEF,KAAK5B,MAAM,CAAC6K,MAAM;QAChB;UACE;UACA;UACA;UACA,IAAI,IAAI,CAACpJ,KAAK,CAACE,MAAM,GAAG,CAAC,EAAE;YACzB,IAAI,CAACL,MAAM,GAAG,oCAAoC;YAClD,OAAO,KAAK;UACd;UACAgE,EAAE,GAAG,IAAI,CAAC7D,KAAK,CAAC,IAAI,CAACA,KAAK,CAACE,MAAM,GAAG,CAAC,CAAC;UACtC4D,EAAE,GAAG,IAAI,CAAC9D,KAAK,CAAC,IAAI,CAACA,KAAK,CAACE,MAAM,GAAG,CAAC,CAAC;UACtC,IAAImJ,EAAE,GAAG,IAAI,CAACrJ,KAAK,CAAC,IAAI,CAACA,KAAK,CAACE,MAAM,GAAG,CAAC,CAAC;UAC1C,IAAI,CAACF,KAAK,CAAC,IAAI,CAACA,KAAK,CAACE,MAAM,GAAG,CAAC,CAAC,GAAG4D,EAAE;UACtC,IAAI,CAAC9D,KAAK,CAAC,IAAI,CAACA,KAAK,CAACE,MAAM,GAAG,CAAC,CAAC,GAAGmJ,EAAE;UACtC,IAAI,CAACrJ,KAAK,CAAC,IAAI,CAACA,KAAK,CAACE,MAAM,GAAG,CAAC,CAAC,GAAG2D,EAAE;QACxC;QACA;MAEF,KAAKtF,MAAM,CAAC+K,OAAO;QACjB;UACE;UACA,IAAI,IAAI,CAACtJ,KAAK,CAACE,MAAM,GAAG,CAAC,EAAE;YACzB,IAAI,CAACL,MAAM,GAAG,oCAAoC;YAClD,OAAO,KAAK;UACd;UACAgE,EAAE,GAAG,IAAI,CAAC7D,KAAK,CAAC,IAAI,CAACA,KAAK,CAACE,MAAM,GAAG,CAAC,CAAC;UACtC4D,EAAE,GAAG,IAAI,CAAC9D,KAAK,CAAC,IAAI,CAACA,KAAK,CAACE,MAAM,GAAG,CAAC,CAAC;UACtC,IAAI,CAACF,KAAK,CAAC,IAAI,CAACA,KAAK,CAACE,MAAM,GAAG,CAAC,CAAC,GAAG4D,EAAE;UACtC,IAAI,CAAC9D,KAAK,CAAC,IAAI,CAACA,KAAK,CAACE,MAAM,GAAG,CAAC,CAAC,GAAG2D,EAAE;QACxC;QACA;MAEF,KAAKtF,MAAM,CAACgL,OAAO;QACjB;UACE;UACA,IAAI,IAAI,CAACvJ,KAAK,CAACE,MAAM,GAAG,CAAC,EAAE;YACzB,IAAI,CAACL,MAAM,GAAG,oCAAoC;YAClD,OAAO,KAAK;UACd;UACA,IAAI,CAACG,KAAK,CAACyI,MAAM,CAAC,IAAI,CAACzI,KAAK,CAACE,MAAM,GAAG,CAAC,EAAE,CAAC,EAAE,IAAI,CAACF,KAAK,CAAC,IAAI,CAACA,KAAK,CAACE,MAAM,GAAG,CAAC,CAAC,CAAC;QAChF;QACA;MAGF,KAAK3B,MAAM,CAACiL,OAAO;QACjB;UACE;UACA,IAAI,IAAI,CAACxJ,KAAK,CAACE,MAAM,GAAG,CAAC,EAAE;YACzB,IAAI,CAACL,MAAM,GAAG,oCAAoC;YAClD,OAAO,KAAK;UACd;UACAkE,EAAE,GAAG,IAAIvF,EAAE,CAAC,IAAI,CAACwB,KAAK,CAAC,IAAI,CAACA,KAAK,CAACE,MAAM,GAAG,CAAC,CAAC,CAACA,MAAM,CAAC;UACrD,IAAI,CAACF,KAAK,CAAC2F,IAAI,CAAC5B,EAAE,CAACgD,iBAAiB,EAAE,CAAC;QACzC;QACA;;MAGA;MACA;MACA;MACF,KAAKxI,MAAM,CAACkL,QAAQ;MACpB,KAAKlL,MAAM,CAACmL,cAAc;QACxB;QACA;UACE;UACA,IAAI,IAAI,CAAC1J,KAAK,CAACE,MAAM,GAAG,CAAC,EAAE;YACzB,IAAI,CAACL,MAAM,GAAG,oCAAoC;YAClD,OAAO,KAAK;UACd;UACA4D,IAAI,GAAG,IAAI,CAACzD,KAAK,CAAC,IAAI,CAACA,KAAK,CAACE,MAAM,GAAG,CAAC,CAAC;UACxCwD,IAAI,GAAG,IAAI,CAAC1D,KAAK,CAAC,IAAI,CAACA,KAAK,CAACE,MAAM,GAAG,CAAC,CAAC;UACxC,IAAIyJ,MAAM,GAAGlG,IAAI,CAACmG,QAAQ,CAAC,KAAK,CAAC,KAAKlG,IAAI,CAACkG,QAAQ,CAAC,KAAK,CAAC;UAC1D,IAAI,CAAC5J,KAAK,CAACU,GAAG,EAAE;UAChB,IAAI,CAACV,KAAK,CAACU,GAAG,EAAE;UAChB,IAAI,CAACV,KAAK,CAAC2F,IAAI,CAACgE,MAAM,GAAG/K,WAAW,CAACuC,IAAI,GAAGvC,WAAW,CAACyC,KAAK,CAAC;UAC9D,IAAImD,SAAS,KAAKjG,MAAM,CAACmL,cAAc,EAAE;YACvC,IAAIC,MAAM,EAAE;cACV,IAAI,CAAC3J,KAAK,CAACU,GAAG,EAAE;YAClB,CAAC,MAAM;cACL,IAAI,CAACb,MAAM,GAAG,wBAAwB;cACtC,OAAO,KAAK;YACd;UACF;QACF;QACA;;MAGA;MACA;MACA;MACF,KAAKtB,MAAM,CAACsL,OAAO;MACnB,KAAKtL,MAAM,CAACuL,OAAO;MACnB,KAAKvL,MAAM,CAACwL,SAAS;MACrB,KAAKxL,MAAM,CAACyL,MAAM;MAClB,KAAKzL,MAAM,CAAC0L,MAAM;MAClB,KAAK1L,MAAM,CAAC2L,YAAY;QACtB;UACE;UACA,IAAI,IAAI,CAAClK,KAAK,CAACE,MAAM,GAAG,CAAC,EAAE;YACzB,IAAI,CAACL,MAAM,GAAG,oCAAoC;YAClD,OAAO,KAAK;UACd;UACAM,GAAG,GAAG,IAAI,CAACH,KAAK,CAAC,IAAI,CAACA,KAAK,CAACE,MAAM,GAAG,CAAC,CAAC;UACvC6D,EAAE,GAAGvF,EAAE,CAAC2I,mBAAmB,CAAChH,GAAG,EAAEmD,eAAe,CAAC;UACjD,QAAQkB,SAAS;YACf,KAAKjG,MAAM,CAACsL,OAAO;cACjB9F,EAAE,GAAGA,EAAE,CAACoG,GAAG,CAAC3L,EAAE,CAAC4L,GAAG,CAAC;cACnB;YACF,KAAK7L,MAAM,CAACuL,OAAO;cACjB/F,EAAE,GAAGA,EAAE,CAACsG,GAAG,CAAC7L,EAAE,CAAC4L,GAAG,CAAC;cACnB;YACF,KAAK7L,MAAM,CAACwL,SAAS;cACnBhG,EAAE,GAAGA,EAAE,CAACuG,GAAG,EAAE;cACb;YACF,KAAK/L,MAAM,CAACyL,MAAM;cAChB,IAAIjG,EAAE,CAACwG,GAAG,CAAC/L,EAAE,CAACgM,IAAI,CAAC,GAAG,CAAC,EAAE;gBACvBzG,EAAE,GAAGA,EAAE,CAACuG,GAAG,EAAE;cACf;cACA;YACF,KAAK/L,MAAM,CAAC0L,MAAM;cAChBlG,EAAE,GAAG,IAAIvF,EAAE,CAAC,CAACuF,EAAE,CAACwG,GAAG,CAAC/L,EAAE,CAACgM,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;cACxC;YACF,KAAKjM,MAAM,CAAC2L,YAAY;cACtBnG,EAAE,GAAG,IAAIvF,EAAE,CAAC,CAACuF,EAAE,CAACwG,GAAG,CAAC/L,EAAE,CAACgM,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;cACxC;YACA;UAAA;;UAEJ,IAAI,CAACxK,KAAK,CAACU,GAAG,EAAE;UAChB,IAAI,CAACV,KAAK,CAAC2F,IAAI,CAAC5B,EAAE,CAACgD,iBAAiB,EAAE,CAAC;QACzC;QACA;MAEF,KAAKxI,MAAM,CAACkM,MAAM;MAClB,KAAKlM,MAAM,CAACmM,MAAM;MAClB,KAAKnM,MAAM,CAACoM,UAAU;MACtB,KAAKpM,MAAM,CAACqM,SAAS;MACrB,KAAKrM,MAAM,CAACsM,WAAW;MACvB,KAAKtM,MAAM,CAACuM,iBAAiB;MAC7B,KAAKvM,MAAM,CAACwM,cAAc;MAC1B,KAAKxM,MAAM,CAACyM,WAAW;MACvB,KAAKzM,MAAM,CAAC0M,cAAc;MAC1B,KAAK1M,MAAM,CAAC2M,kBAAkB;MAC9B,KAAK3M,MAAM,CAAC4M,qBAAqB;MACjC,KAAK5M,MAAM,CAAC6M,MAAM;MAClB,KAAK7M,MAAM,CAAC8M,MAAM;QAChB;UACE;UACA,IAAI,IAAI,CAACrL,KAAK,CAACE,MAAM,GAAG,CAAC,EAAE;YACzB,IAAI,CAACL,MAAM,GAAG,oCAAoC;YAClD,OAAO,KAAK;UACd;UACAmE,GAAG,GAAGxF,EAAE,CAAC2I,mBAAmB,CAAC,IAAI,CAACnH,KAAK,CAAC,IAAI,CAACA,KAAK,CAACE,MAAM,GAAG,CAAC,CAAC,EAAEoD,eAAe,CAAC;UAChFW,GAAG,GAAGzF,EAAE,CAAC2I,mBAAmB,CAAC,IAAI,CAACnH,KAAK,CAAC,IAAI,CAACA,KAAK,CAACE,MAAM,GAAG,CAAC,CAAC,EAAEoD,eAAe,CAAC;UAChFS,EAAE,GAAG,IAAIvF,EAAE,CAAC,CAAC,CAAC;UAEd,QAAQgG,SAAS;YACf,KAAKjG,MAAM,CAACkM,MAAM;cAChB1G,EAAE,GAAGC,GAAG,CAACmG,GAAG,CAAClG,GAAG,CAAC;cACjB;YAEF,KAAK1F,MAAM,CAACmM,MAAM;cAChB3G,EAAE,GAAGC,GAAG,CAACqG,GAAG,CAACpG,GAAG,CAAC;cACjB;;YAEA;YACF,KAAK1F,MAAM,CAACoM,UAAU;cACpB5G,EAAE,GAAG,IAAIvF,EAAE,CAAC,CAAEwF,GAAG,CAACuG,GAAG,CAAC/L,EAAE,CAACgM,IAAI,CAAC,KAAK,CAAC,IAAMvG,GAAG,CAACsG,GAAG,CAAC/L,EAAE,CAACgM,IAAI,CAAC,KAAK,CAAE,IAAI,CAAC,CAAC;cACvE;YACA;YACF,KAAKjM,MAAM,CAACqM,SAAS;cACnB7G,EAAE,GAAG,IAAIvF,EAAE,CAAC,CAAEwF,GAAG,CAACuG,GAAG,CAAC/L,EAAE,CAACgM,IAAI,CAAC,KAAK,CAAC,IAAMvG,GAAG,CAACsG,GAAG,CAAC/L,EAAE,CAACgM,IAAI,CAAC,KAAK,CAAE,IAAI,CAAC,CAAC;cACvE;YACA;YACF,KAAKjM,MAAM,CAACsM,WAAW;cACrB9G,EAAE,GAAG,IAAIvF,EAAE,CAAC,CAACwF,GAAG,CAACuG,GAAG,CAACtG,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;cACrC;YACA;YACF,KAAK1F,MAAM,CAACuM,iBAAiB;cAC3B/G,EAAE,GAAG,IAAIvF,EAAE,CAAC,CAACwF,GAAG,CAACuG,GAAG,CAACtG,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;cACrC;YACA;YACF,KAAK1F,MAAM,CAACwM,cAAc;cACxBhH,EAAE,GAAG,IAAIvF,EAAE,CAAC,CAACwF,GAAG,CAACuG,GAAG,CAACtG,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;cACrC;YACA;YACF,KAAK1F,MAAM,CAACyM,WAAW;cACrBjH,EAAE,GAAG,IAAIvF,EAAE,CAAC,CAACwF,GAAG,CAACuG,GAAG,CAACtG,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;cACnC;YACA;YACF,KAAK1F,MAAM,CAAC0M,cAAc;cACxBlH,EAAE,GAAG,IAAIvF,EAAE,CAAC,CAACwF,GAAG,CAACuG,GAAG,CAACtG,GAAG,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;cACnC;YACA;YACF,KAAK1F,MAAM,CAAC2M,kBAAkB;cAC5BnH,EAAE,GAAG,IAAIvF,EAAE,CAAC,CAACwF,GAAG,CAACuG,GAAG,CAACtG,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;cACpC;YACA;YACF,KAAK1F,MAAM,CAAC4M,qBAAqB;cAC/BpH,EAAE,GAAG,IAAIvF,EAAE,CAAC,CAACwF,GAAG,CAACuG,GAAG,CAACtG,GAAG,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;cACpC;YACF,KAAK1F,MAAM,CAAC6M,MAAM;cAChBrH,EAAE,GAAIC,GAAG,CAACuG,GAAG,CAACtG,GAAG,CAAC,GAAG,CAAC,GAAGD,GAAG,GAAGC,GAAI;cACnC;YACF,KAAK1F,MAAM,CAAC8M,MAAM;cAChBtH,EAAE,GAAIC,GAAG,CAACuG,GAAG,CAACtG,GAAG,CAAC,GAAG,CAAC,GAAGD,GAAG,GAAGC,GAAI;cACnC;YACA;UAAA;;UAEJ,IAAI,CAACjE,KAAK,CAACU,GAAG,EAAE;UAChB,IAAI,CAACV,KAAK,CAACU,GAAG,EAAE;UAChB,IAAI,CAACV,KAAK,CAAC2F,IAAI,CAAC5B,EAAE,CAACgD,iBAAiB,EAAE,CAAC;UAEvC,IAAIvC,SAAS,KAAKjG,MAAM,CAACuM,iBAAiB,EAAE;YAC1C;YACA,IAAIlM,WAAW,CAACwB,UAAU,CAAC,IAAI,CAACJ,KAAK,CAAC,IAAI,CAACA,KAAK,CAACE,MAAM,GAAG,CAAC,CAAC,CAAC,EAAE;cAC7D,IAAI,CAACF,KAAK,CAACU,GAAG,EAAE;YAClB,CAAC,MAAM;cACL,IAAI,CAACb,MAAM,GAAG,2BAA2B;cACzC,OAAO,KAAK;YACd;UACF;QACF;QACA;MAEF,KAAKtB,MAAM,CAAC+M,SAAS;QACnB;UACE;UACA,IAAI,IAAI,CAACtL,KAAK,CAACE,MAAM,GAAG,CAAC,EAAE;YACzB,IAAI,CAACL,MAAM,GAAG,oCAAoC;YAClD,OAAO,KAAK;UACd;UACAmE,GAAG,GAAGxF,EAAE,CAAC2I,mBAAmB,CAAC,IAAI,CAACnH,KAAK,CAAC,IAAI,CAACA,KAAK,CAACE,MAAM,GAAG,CAAC,CAAC,EAAEoD,eAAe,CAAC;UAChFW,GAAG,GAAGzF,EAAE,CAAC2I,mBAAmB,CAAC,IAAI,CAACnH,KAAK,CAAC,IAAI,CAACA,KAAK,CAACE,MAAM,GAAG,CAAC,CAAC,EAAEoD,eAAe,CAAC;UAChF,IAAIiI,GAAG,GAAG/M,EAAE,CAAC2I,mBAAmB,CAAC,IAAI,CAACnH,KAAK,CAAC,IAAI,CAACA,KAAK,CAACE,MAAM,GAAG,CAAC,CAAC,EAAEoD,eAAe,CAAC;UACpF;UACAgB,MAAM,GAAIL,GAAG,CAACsG,GAAG,CAACvG,GAAG,CAAC,IAAI,CAAC,IAAMA,GAAG,CAACuG,GAAG,CAACgB,GAAG,CAAC,GAAG,CAAE;UAClD,IAAI,CAACvL,KAAK,CAACU,GAAG,EAAE;UAChB,IAAI,CAACV,KAAK,CAACU,GAAG,EAAE;UAChB,IAAI,CAACV,KAAK,CAACU,GAAG,EAAE;UAChB,IAAI,CAACV,KAAK,CAAC2F,IAAI,CAACrB,MAAM,GAAG1F,WAAW,CAACuC,IAAI,GAAGvC,WAAW,CAACyC,KAAK,CAAC;QAChE;QACA;;MAGA;MACA;MACA;MACF,KAAK9C,MAAM,CAACiN,YAAY;MACxB,KAAKjN,MAAM,CAACkN,OAAO;MACnB,KAAKlN,MAAM,CAACmN,SAAS;MACrB,KAAKnN,MAAM,CAACoN,UAAU;MACtB,KAAKpN,MAAM,CAACqN,UAAU;QACpB;UACE;UACA,IAAI,IAAI,CAAC5L,KAAK,CAACE,MAAM,GAAG,CAAC,EAAE;YACzB,IAAI,CAACL,MAAM,GAAG,oCAAoC;YAClD,OAAO,KAAK;UACd;UACAM,GAAG,GAAG,IAAI,CAACH,KAAK,CAAC,IAAI,CAACA,KAAK,CAACE,MAAM,GAAG,CAAC,CAAC;UACvC;UACA;UACA,IAAI2L,OAAO;UACX,IAAIrH,SAAS,KAAKjG,MAAM,CAACiN,YAAY,EAAE;YACrCK,OAAO,GAAGpN,IAAI,CAACqN,SAAS,CAAC3L,GAAG,CAAC;UAC/B,CAAC,MAAM,IAAIqE,SAAS,KAAKjG,MAAM,CAACkN,OAAO,EAAE;YACvCI,OAAO,GAAGpN,IAAI,CAACsN,IAAI,CAAC5L,GAAG,CAAC;UAC1B,CAAC,MAAM,IAAIqE,SAAS,KAAKjG,MAAM,CAACmN,SAAS,EAAE;YACzCG,OAAO,GAAGpN,IAAI,CAACuN,MAAM,CAAC7L,GAAG,CAAC;UAC5B,CAAC,MAAM,IAAIqE,SAAS,KAAKjG,MAAM,CAACoN,UAAU,EAAE;YAC1CE,OAAO,GAAGpN,IAAI,CAACwN,eAAe,CAAC9L,GAAG,CAAC;UACrC,CAAC,MAAM,IAAIqE,SAAS,KAAKjG,MAAM,CAACqN,UAAU,EAAE;YAC1CC,OAAO,GAAGpN,IAAI,CAACyN,YAAY,CAAC/L,GAAG,CAAC;UAClC;UACA,IAAI,CAACH,KAAK,CAACU,GAAG,EAAE;UAChB,IAAI,CAACV,KAAK,CAAC2F,IAAI,CAACkG,OAAO,CAAC;QAC1B;QACA;MAEF,KAAKtN,MAAM,CAAC4N,gBAAgB;QAC1B;UACE;UACA,IAAI,CAACpL,cAAc,GAAG,IAAI,CAACD,EAAE;QAC/B;QACA;MAEF,KAAKvC,MAAM,CAAC6N,WAAW;MACvB,KAAK7N,MAAM,CAAC8N,iBAAiB;QAC3B;UACE;UACA,IAAI,IAAI,CAACrM,KAAK,CAACE,MAAM,GAAG,CAAC,EAAE;YACzB,IAAI,CAACL,MAAM,GAAG,oCAAoC;YAClD,OAAO,KAAK;UACd;UAEAqE,MAAM,GAAG,IAAI,CAAClE,KAAK,CAAC,IAAI,CAACA,KAAK,CAACE,MAAM,GAAG,CAAC,CAAC;UAC1CiE,SAAS,GAAG,IAAI,CAACnE,KAAK,CAAC,IAAI,CAACA,KAAK,CAACE,MAAM,GAAG,CAAC,CAAC;;UAE7C;UACA;UACAkE,SAAS,GAAG,IAAI9F,MAAM,EAAE,CAACS,GAAG,CAAC;YAC3B4D,MAAM,EAAE,IAAI,CAAClD,MAAM,CAACkD,MAAM,CAAC1C,KAAK,CAAC,IAAI,CAACc,cAAc;UACtD,CAAC,CAAC;;UAEF;UACA,IAAIuL,SAAS,GAAG,IAAIhO,MAAM,EAAE,CAAC6L,GAAG,CAACjG,MAAM,CAAC;UACxCE,SAAS,CAACmI,aAAa,CAACD,SAAS,CAAC;UAElC,IAAI,CAAC,IAAI,CAACpK,sBAAsB,CAACgC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC1B,mBAAmB,CAAC2B,SAAS,CAAC,EAAE;YAChF,OAAO,KAAK;UACd;UAEA,IAAI;YACFhC,GAAG,GAAGzD,SAAS,CAAC2D,YAAY,CAAC6B,MAAM,CAAC;YACpCG,MAAM,GAAG1F,SAAS,CAAC8B,UAAU,CAAC0D,SAAS,EAAE,KAAK,CAAC;YAC/CvB,QAAQ,GAAG,IAAI,CAACxD,EAAE,CAACoN,eAAe,CAACrK,GAAG,EAAEkC,MAAM,EAAE,IAAI,CAAChF,GAAG,EAAE+E,SAAS,CAAC;UACtE,CAAC,CAAC,OAAOtB,CAAC,EAAE;YACV;YACAF,QAAQ,GAAG,KAAK;UAClB;UAEA,IAAI,CAAC5C,KAAK,CAACU,GAAG,EAAE;UAChB,IAAI,CAACV,KAAK,CAACU,GAAG,EAAE;UAChB;UACA,IAAI,CAACV,KAAK,CAAC2F,IAAI,CAAC/C,QAAQ,GAAGhE,WAAW,CAACuC,IAAI,GAAGvC,WAAW,CAACyC,KAAK,CAAC;UAChE,IAAImD,SAAS,KAAKjG,MAAM,CAAC8N,iBAAiB,EAAE;YAC1C,IAAIzJ,QAAQ,EAAE;cACZ,IAAI,CAAC5C,KAAK,CAACU,GAAG,EAAE;YAClB,CAAC,MAAM;cACL,IAAI,CAACb,MAAM,GAAG,2BAA2B;cACzC,OAAO,KAAK;YACd;UACF;QACF;QACA;MAEF,KAAKtB,MAAM,CAACkO,gBAAgB;MAC5B,KAAKlO,MAAM,CAACmO,sBAAsB;QAChC;UACE;;UAEA,IAAIzK,CAAC,GAAG,CAAC;UACT,IAAI,IAAI,CAACjC,KAAK,CAACE,MAAM,GAAG+B,CAAC,EAAE;YACzB,IAAI,CAACpC,MAAM,GAAG,oCAAoC;YAClD,OAAO,KAAK;UACd;UAEA,IAAI8M,UAAU,GAAGnO,EAAE,CAAC2I,mBAAmB,CAAC,IAAI,CAACnH,KAAK,CAAC,IAAI,CAACA,KAAK,CAACE,MAAM,GAAG+B,CAAC,CAAC,EAAEqB,eAAe,CAAC,CAAC6F,QAAQ,EAAE;UACtG,IAAIwD,UAAU,GAAG,CAAC,IAAIA,UAAU,GAAG,EAAE,EAAE;YACrC,IAAI,CAAC9M,MAAM,GAAG,yBAAyB;YACvC,OAAO,KAAK;UACd;UACA,IAAI,CAACmB,QAAQ,IAAI2L,UAAU;UAC3B,IAAI,IAAI,CAAC3L,QAAQ,GAAG,GAAG,EAAE;YACvB,IAAI,CAACnB,MAAM,GAAG,qBAAqB;YACnC,OAAO,KAAK;UACd;UACA;UACA,IAAI+M,IAAI,GAAG,EAAE3K,CAAC;UACdA,CAAC,IAAI0K,UAAU;UACf,IAAI,IAAI,CAAC3M,KAAK,CAACE,MAAM,GAAG+B,CAAC,EAAE;YACzB,IAAI,CAACpC,MAAM,GAAG,oCAAoC;YAClD,OAAO,KAAK;UACd;UAEA,IAAIgN,UAAU,GAAGrO,EAAE,CAAC2I,mBAAmB,CAAC,IAAI,CAACnH,KAAK,CAAC,IAAI,CAACA,KAAK,CAACE,MAAM,GAAG+B,CAAC,CAAC,EAAEqB,eAAe,CAAC,CAAC6F,QAAQ,EAAE;UACtG,IAAI0D,UAAU,GAAG,CAAC,IAAIA,UAAU,GAAGF,UAAU,EAAE;YAC7C,IAAI,CAAC9M,MAAM,GAAG,sBAAsB;YACpC,OAAO,KAAK;UACd;UACA;UACA,IAAIiN,IAAI,GAAG,EAAE7K,CAAC;UACdA,CAAC,IAAI4K,UAAU;UACf,IAAI,IAAI,CAAC7M,KAAK,CAACE,MAAM,GAAG+B,CAAC,EAAE;YACzB,IAAI,CAACpC,MAAM,GAAG,oCAAoC;YAClD,OAAO,KAAK;UACd;;UAEA;UACAuE,SAAS,GAAG,IAAI9F,MAAM,EAAE,CAACS,GAAG,CAAC;YAC3B4D,MAAM,EAAE,IAAI,CAAClD,MAAM,CAACkD,MAAM,CAAC1C,KAAK,CAAC,IAAI,CAACc,cAAc;UACtD,CAAC,CAAC;;UAEF;UACA,KAAK,IAAIgM,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,UAAU,EAAEE,CAAC,EAAE,EAAE;YACnC7I,MAAM,GAAG,IAAI,CAAClE,KAAK,CAAC,IAAI,CAACA,KAAK,CAACE,MAAM,GAAG4M,IAAI,GAAGC,CAAC,CAAC;YACjD3I,SAAS,CAACmI,aAAa,CAAC,IAAIjO,MAAM,EAAE,CAAC6L,GAAG,CAACjG,MAAM,CAAC,CAAC;UACnD;UAEAtB,QAAQ,GAAG,IAAI;UACf,OAAOA,QAAQ,IAAIiK,UAAU,GAAG,CAAC,EAAE;YACjC;YACA3I,MAAM,GAAG,IAAI,CAAClE,KAAK,CAAC,IAAI,CAACA,KAAK,CAACE,MAAM,GAAG4M,IAAI,CAAC;YAC7C;YACA3I,SAAS,GAAG,IAAI,CAACnE,KAAK,CAAC,IAAI,CAACA,KAAK,CAACE,MAAM,GAAG0M,IAAI,CAAC;YAEhD,IAAI,CAAC,IAAI,CAAC1K,sBAAsB,CAACgC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC1B,mBAAmB,CAAC2B,SAAS,CAAC,EAAE;cAChF,OAAO,KAAK;YACd;YAEA,IAAI6I,GAAG;YACP,IAAI;cACF7K,GAAG,GAAGzD,SAAS,CAAC2D,YAAY,CAAC6B,MAAM,CAAC;cACpCG,MAAM,GAAG1F,SAAS,CAAC8B,UAAU,CAAC0D,SAAS,EAAE,KAAK,CAAC;cAC/C6I,GAAG,GAAG,IAAI,CAAC5N,EAAE,CAACoN,eAAe,CAACrK,GAAG,EAAEkC,MAAM,EAAE,IAAI,CAAChF,GAAG,EAAE+E,SAAS,CAAC;YACjE,CAAC,CAAC,OAAOtB,CAAC,EAAE;cACV;cACAkK,GAAG,GAAG,KAAK;YACb;YAEA,IAAIA,GAAG,EAAE;cACPF,IAAI,EAAE;cACND,UAAU,EAAE;YACd;YACAD,IAAI,EAAE;YACND,UAAU,EAAE;;YAEZ;YACA;YACA,IAAIE,UAAU,GAAGF,UAAU,EAAE;cAC3B/J,QAAQ,GAAG,KAAK;YAClB;UACF;;UAEA;UACA,OAAOX,CAAC,EAAE,GAAG,CAAC,EAAE;YACd,IAAI,CAACjC,KAAK,CAACU,GAAG,EAAE;UAClB;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA,IAAI,IAAI,CAACV,KAAK,CAACE,MAAM,GAAG,CAAC,EAAE;YACzB,IAAI,CAACL,MAAM,GAAG,oCAAoC;YAClD,OAAO,KAAK;UACd;UACA,IAAK,IAAI,CAACP,KAAK,GAAGV,WAAW,CAACiD,uBAAuB,IAAK,IAAI,CAAC7B,KAAK,CAAC,IAAI,CAACA,KAAK,CAACE,MAAM,GAAG,CAAC,CAAC,CAACA,MAAM,EAAE;YAClG,IAAI,CAACL,MAAM,GAAG,0BAA0B;YACxC,OAAO,KAAK;UACd;UACA,IAAI,CAACG,KAAK,CAACU,GAAG,EAAE;UAEhB,IAAI,CAACV,KAAK,CAAC2F,IAAI,CAAC/C,QAAQ,GAAGhE,WAAW,CAACuC,IAAI,GAAGvC,WAAW,CAACyC,KAAK,CAAC;UAEhE,IAAImD,SAAS,KAAKjG,MAAM,CAACmO,sBAAsB,EAAE;YAC/C,IAAI9J,QAAQ,EAAE;cACZ,IAAI,CAAC5C,KAAK,CAACU,GAAG,EAAE;YAClB,CAAC,MAAM;cACL,IAAI,CAACb,MAAM,GAAG,gCAAgC;cAC9C,OAAO,KAAK;YACd;UACF;QACF;QACA;MAEF;QACE,IAAI,CAACA,MAAM,GAAG,uBAAuB;QACrC,OAAO,KAAK;IAAC;EAEnB;EAEA,OAAO,IAAI;AACb,CAAC"},"metadata":{},"sourceType":"script"}