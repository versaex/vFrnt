{"ast":null,"code":"import { ToRawFixed } from './ToRawFixed';\nimport * as digitMapping from './digit-mapping.json';\n// This is from: unicode-12.1.0/General_Category/Symbol/regex.js\n// IE11 does not support unicode flag, otherwise this is just /\\p{S}/u.\nvar S_UNICODE_REGEX = /[\\$\\+<->\\^`\\|~\\xA2-\\xA6\\xA8\\xA9\\xAC\\xAE-\\xB1\\xB4\\xB8\\xD7\\xF7\\u02C2-\\u02C5\\u02D2-\\u02DF\\u02E5-\\u02EB\\u02ED\\u02EF-\\u02FF\\u0375\\u0384\\u0385\\u03F6\\u0482\\u058D-\\u058F\\u0606-\\u0608\\u060B\\u060E\\u060F\\u06DE\\u06E9\\u06FD\\u06FE\\u07F6\\u07FE\\u07FF\\u09F2\\u09F3\\u09FA\\u09FB\\u0AF1\\u0B70\\u0BF3-\\u0BFA\\u0C7F\\u0D4F\\u0D79\\u0E3F\\u0F01-\\u0F03\\u0F13\\u0F15-\\u0F17\\u0F1A-\\u0F1F\\u0F34\\u0F36\\u0F38\\u0FBE-\\u0FC5\\u0FC7-\\u0FCC\\u0FCE\\u0FCF\\u0FD5-\\u0FD8\\u109E\\u109F\\u1390-\\u1399\\u166D\\u17DB\\u1940\\u19DE-\\u19FF\\u1B61-\\u1B6A\\u1B74-\\u1B7C\\u1FBD\\u1FBF-\\u1FC1\\u1FCD-\\u1FCF\\u1FDD-\\u1FDF\\u1FED-\\u1FEF\\u1FFD\\u1FFE\\u2044\\u2052\\u207A-\\u207C\\u208A-\\u208C\\u20A0-\\u20BF\\u2100\\u2101\\u2103-\\u2106\\u2108\\u2109\\u2114\\u2116-\\u2118\\u211E-\\u2123\\u2125\\u2127\\u2129\\u212E\\u213A\\u213B\\u2140-\\u2144\\u214A-\\u214D\\u214F\\u218A\\u218B\\u2190-\\u2307\\u230C-\\u2328\\u232B-\\u2426\\u2440-\\u244A\\u249C-\\u24E9\\u2500-\\u2767\\u2794-\\u27C4\\u27C7-\\u27E5\\u27F0-\\u2982\\u2999-\\u29D7\\u29DC-\\u29FB\\u29FE-\\u2B73\\u2B76-\\u2B95\\u2B98-\\u2BFF\\u2CE5-\\u2CEA\\u2E80-\\u2E99\\u2E9B-\\u2EF3\\u2F00-\\u2FD5\\u2FF0-\\u2FFB\\u3004\\u3012\\u3013\\u3020\\u3036\\u3037\\u303E\\u303F\\u309B\\u309C\\u3190\\u3191\\u3196-\\u319F\\u31C0-\\u31E3\\u3200-\\u321E\\u322A-\\u3247\\u3250\\u3260-\\u327F\\u328A-\\u32B0\\u32C0-\\u33FF\\u4DC0-\\u4DFF\\uA490-\\uA4C6\\uA700-\\uA716\\uA720\\uA721\\uA789\\uA78A\\uA828-\\uA82B\\uA836-\\uA839\\uAA77-\\uAA79\\uAB5B\\uFB29\\uFBB2-\\uFBC1\\uFDFC\\uFDFD\\uFE62\\uFE64-\\uFE66\\uFE69\\uFF04\\uFF0B\\uFF1C-\\uFF1E\\uFF3E\\uFF40\\uFF5C\\uFF5E\\uFFE0-\\uFFE6\\uFFE8-\\uFFEE\\uFFFC\\uFFFD]|\\uD800[\\uDD37-\\uDD3F\\uDD79-\\uDD89\\uDD8C-\\uDD8E\\uDD90-\\uDD9B\\uDDA0\\uDDD0-\\uDDFC]|\\uD802[\\uDC77\\uDC78\\uDEC8]|\\uD805\\uDF3F|\\uD807[\\uDFD5-\\uDFF1]|\\uD81A[\\uDF3C-\\uDF3F\\uDF45]|\\uD82F\\uDC9C|\\uD834[\\uDC00-\\uDCF5\\uDD00-\\uDD26\\uDD29-\\uDD64\\uDD6A-\\uDD6C\\uDD83\\uDD84\\uDD8C-\\uDDA9\\uDDAE-\\uDDE8\\uDE00-\\uDE41\\uDE45\\uDF00-\\uDF56]|\\uD835[\\uDEC1\\uDEDB\\uDEFB\\uDF15\\uDF35\\uDF4F\\uDF6F\\uDF89\\uDFA9\\uDFC3]|\\uD836[\\uDC00-\\uDDFF\\uDE37-\\uDE3A\\uDE6D-\\uDE74\\uDE76-\\uDE83\\uDE85\\uDE86]|\\uD838[\\uDD4F\\uDEFF]|\\uD83B[\\uDCAC\\uDCB0\\uDD2E\\uDEF0\\uDEF1]|\\uD83C[\\uDC00-\\uDC2B\\uDC30-\\uDC93\\uDCA0-\\uDCAE\\uDCB1-\\uDCBF\\uDCC1-\\uDCCF\\uDCD1-\\uDCF5\\uDD10-\\uDD6C\\uDD70-\\uDDAC\\uDDE6-\\uDE02\\uDE10-\\uDE3B\\uDE40-\\uDE48\\uDE50\\uDE51\\uDE60-\\uDE65\\uDF00-\\uDFFF]|\\uD83D[\\uDC00-\\uDED5\\uDEE0-\\uDEEC\\uDEF0-\\uDEFA\\uDF00-\\uDF73\\uDF80-\\uDFD8\\uDFE0-\\uDFEB]|\\uD83E[\\uDC00-\\uDC0B\\uDC10-\\uDC47\\uDC50-\\uDC59\\uDC60-\\uDC87\\uDC90-\\uDCAD\\uDD00-\\uDD0B\\uDD0D-\\uDD71\\uDD73-\\uDD76\\uDD7A-\\uDDA2\\uDDA5-\\uDDAA\\uDDAE-\\uDDCA\\uDDCD-\\uDE53\\uDE60-\\uDE6D\\uDE70-\\uDE73\\uDE78-\\uDE7A\\uDE80-\\uDE82\\uDE90-\\uDE95]/;\n// /^\\p{S}/u\nvar CARET_S_UNICODE_REGEX = new RegExp(\"^\" + S_UNICODE_REGEX.source);\n// /\\p{S}$/u\nvar S_DOLLAR_UNICODE_REGEX = new RegExp(S_UNICODE_REGEX.source + \"$\");\nvar CLDR_NUMBER_PATTERN = /[#0](?:[\\.,][#0]+)*/g;\nexport default function formatToParts(numberResult, data, pl, options) {\n  var sign = numberResult.sign,\n    exponent = numberResult.exponent,\n    magnitude = numberResult.magnitude;\n  var notation = options.notation,\n    style = options.style,\n    numberingSystem = options.numberingSystem;\n  var defaultNumberingSystem = data.numbers.nu[0];\n  // #region Part 1: partition and interpolate the CLDR number pattern.\n  // ----------------------------------------------------------\n  var compactNumberPattern = null;\n  if (notation === 'compact' && magnitude) {\n    compactNumberPattern = getCompactDisplayPattern(numberResult, pl, data, style, options.compactDisplay, options.currencyDisplay, numberingSystem);\n  }\n  // This is used multiple times\n  var nonNameCurrencyPart;\n  if (style === 'currency' && options.currencyDisplay !== 'name') {\n    var byCurrencyDisplay = data.currencies[options.currency];\n    if (byCurrencyDisplay) {\n      switch (options.currencyDisplay) {\n        case 'code':\n          nonNameCurrencyPart = options.currency;\n          break;\n        case 'symbol':\n          nonNameCurrencyPart = byCurrencyDisplay.symbol;\n          break;\n        default:\n          nonNameCurrencyPart = byCurrencyDisplay.narrow;\n          break;\n      }\n    } else {\n      // Fallback for unknown currency\n      nonNameCurrencyPart = options.currency;\n    }\n  }\n  var numberPattern;\n  if (!compactNumberPattern) {\n    // Note: if the style is unit, or is currency and the currency display is name,\n    // its unit parts will be interpolated in part 2. So here we can fallback to decimal.\n    if (style === 'decimal' || style === 'unit' || style === 'currency' && options.currencyDisplay === 'name') {\n      // Shortcut for decimal\n      var decimalData = data.numbers.decimal[numberingSystem] || data.numbers.decimal[defaultNumberingSystem];\n      numberPattern = getPatternForSign(decimalData.standard, sign);\n    } else if (style === 'currency') {\n      var currencyData = data.numbers.currency[numberingSystem] || data.numbers.currency[defaultNumberingSystem];\n      // We replace number pattern part with `0` for easier postprocessing.\n      numberPattern = getPatternForSign(currencyData[options.currencySign], sign);\n    } else {\n      // percent\n      var percentPattern = data.numbers.percent[numberingSystem] || data.numbers.percent[defaultNumberingSystem];\n      numberPattern = getPatternForSign(percentPattern, sign);\n    }\n  } else {\n    numberPattern = compactNumberPattern;\n  }\n  // Extract the decimal number pattern string. It looks like \"#,##0,00\", which will later be\n  // used to infer decimal group sizes.\n  var decimalNumberPattern = CLDR_NUMBER_PATTERN.exec(numberPattern)[0];\n  // Now we start to substitute patterns\n  // 1. replace strings like `0` and `#,##0.00` with `{0}`\n  // 2. unquote characters (invariant: the quoted characters does not contain the special tokens)\n  numberPattern = numberPattern.replace(CLDR_NUMBER_PATTERN, '{0}').replace(/'(.)'/g, '$1');\n  // Handle currency spacing (both compact and non-compact).\n  if (style === 'currency' && options.currencyDisplay !== 'name') {\n    var currencyData = data.numbers.currency[numberingSystem] || data.numbers.currency[defaultNumberingSystem];\n    // See `currencySpacing` substitution rule in TR-35.\n    // Here we always assume the currencyMatch is \"[:^S:]\" and surroundingMatch is \"[:digit:]\".\n    //\n    // Example 1: for pattern \"#,##0.00¤\" with symbol \"US$\", we replace \"¤\" with the symbol,\n    // but insert an extra non-break space before the symbol, because \"[:^S:]\" matches \"U\" in\n    // \"US$\" and \"[:digit:]\" matches the latn numbering system digits.\n    //\n    // Example 2: for pattern \"¤#,##0.00\" with symbol \"US$\", there is no spacing between symbol\n    // and number, because `$` does not match \"[:^S:]\".\n    //\n    // Implementation note: here we do the best effort to infer the insertion.\n    // We also assume that `beforeInsertBetween` and `afterInsertBetween` will never be `;`.\n    var afterCurrency = currencyData.currencySpacing.afterInsertBetween;\n    if (afterCurrency && !S_DOLLAR_UNICODE_REGEX.test(nonNameCurrencyPart)) {\n      numberPattern = numberPattern.replace('¤{0}', \"\\xA4\" + afterCurrency + \"{0}\");\n    }\n    var beforeCurrency = currencyData.currencySpacing.beforeInsertBetween;\n    if (beforeCurrency && !CARET_S_UNICODE_REGEX.test(nonNameCurrencyPart)) {\n      numberPattern = numberPattern.replace('{0}¤', \"{0}\" + beforeCurrency + \"\\xA4\");\n    }\n  }\n  // The following tokens are special: `{0}`, `¤`, `%`, `-`, `+`, `{c:...}.\n  var numberPatternParts = numberPattern.split(/({c:[^}]+}|\\{0\\}|[¤%\\-\\+])/g);\n  var numberParts = [];\n  var symbols = data.numbers.symbols[numberingSystem] || data.numbers.symbols[defaultNumberingSystem];\n  for (var _i = 0, numberPatternParts_1 = numberPatternParts; _i < numberPatternParts_1.length; _i++) {\n    var part = numberPatternParts_1[_i];\n    if (!part) {\n      continue;\n    }\n    switch (part) {\n      case '{0}':\n        {\n          // We only need to handle scientific and engineering notation here.\n          numberParts.push.apply(numberParts, paritionNumberIntoParts(symbols, numberResult, notation, exponent, numberingSystem,\n          // If compact number pattern exists, do not insert group separators.\n          !compactNumberPattern && options.useGrouping, decimalNumberPattern));\n          break;\n        }\n      case '-':\n        numberParts.push({\n          type: 'minusSign',\n          value: symbols.minusSign\n        });\n        break;\n      case '+':\n        numberParts.push({\n          type: 'plusSign',\n          value: symbols.plusSign\n        });\n        break;\n      case '%':\n        numberParts.push({\n          type: 'percentSign',\n          value: symbols.percentSign\n        });\n        break;\n      case '¤':\n        // Computed above when handling currency spacing.\n        numberParts.push({\n          type: 'currency',\n          value: nonNameCurrencyPart\n        });\n        break;\n      default:\n        if (/^\\{c:/.test(part)) {\n          numberParts.push({\n            type: 'compact',\n            value: part.substring(3, part.length - 1)\n          });\n        } else {\n          // literal\n          numberParts.push({\n            type: 'literal',\n            value: part\n          });\n        }\n        break;\n    }\n  }\n  // #endregion\n  // #region Part 2: interpolate unit pattern if necessary.\n  // ----------------------------------------------\n  switch (style) {\n    case 'currency':\n      {\n        // `currencyDisplay: 'name'` has similar pattern handling as units.\n        if (options.currencyDisplay === 'name') {\n          var unitPattern = (data.numbers.currency[numberingSystem] || data.numbers.currency[defaultNumberingSystem]).unitPattern;\n          // Select plural\n          var unitName = void 0;\n          var currencyNameData = data.currencies[options.currency];\n          if (currencyNameData) {\n            unitName = selectPlural(pl, numberResult.roundedNumber * Math.pow(10, exponent), currencyNameData.displayName);\n          } else {\n            // Fallback for unknown currency\n            unitName = options.currency;\n          }\n          // Do {0} and {1} substitution\n          var unitPatternParts = unitPattern.split(/(\\{[01]\\})/g);\n          var result = [];\n          for (var _a = 0, unitPatternParts_1 = unitPatternParts; _a < unitPatternParts_1.length; _a++) {\n            var part = unitPatternParts_1[_a];\n            switch (part) {\n              case '{0}':\n                result.push.apply(result, numberParts);\n                break;\n              case '{1}':\n                result.push({\n                  type: 'currency',\n                  value: unitName\n                });\n                break;\n              default:\n                if (part) {\n                  result.push({\n                    type: 'literal',\n                    value: part\n                  });\n                }\n                break;\n            }\n          }\n          return result;\n        } else {\n          return numberParts;\n        }\n      }\n    case 'unit':\n      {\n        var unit = options.unit,\n          unitDisplay = options.unitDisplay;\n        var unitData = data.units.simple[unit];\n        var unitPattern = void 0;\n        if (unitData) {\n          // Simple unit pattern\n          unitPattern = selectPlural(pl, numberResult.roundedNumber * Math.pow(10, exponent), data.units.simple[unit][unitDisplay]);\n        } else {\n          // See: http://unicode.org/reports/tr35/tr35-general.html#perUnitPatterns\n          // If cannot find unit in the simple pattern, it must be \"per\" compound pattern.\n          // Implementation note: we are not following TR-35 here because we need to format to parts!\n          var _b = unit.split('-per-'),\n            numeratorUnit = _b[0],\n            denominatorUnit = _b[1];\n          unitData = data.units.simple[numeratorUnit];\n          var numeratorUnitPattern = selectPlural(pl, numberResult.roundedNumber * Math.pow(10, exponent), data.units.simple[numeratorUnit][unitDisplay]);\n          var perUnitPattern = data.units.simple[denominatorUnit].perUnit[unitDisplay];\n          if (perUnitPattern) {\n            // perUnitPattern exists, combine it with numeratorUnitPattern\n            unitPattern = perUnitPattern.replace('{0}', numeratorUnitPattern);\n          } else {\n            // get compoundUnit pattern (e.g. \"{0} per {1}\"), repalce {0} with numerator pattern and {1} with\n            // the denominator pattern in singular form.\n            var perPattern = data.units.compound.per[unitDisplay];\n            var denominatorPattern = selectPlural(pl, 1, data.units.simple[denominatorUnit][unitDisplay]);\n            unitPattern = unitPattern = perPattern.replace('{0}', numeratorUnitPattern).replace('{1}', denominatorPattern.replace('{0}', ''));\n          }\n        }\n        var result = [];\n        // We need spacing around \"{0}\" because they are not treated as \"unit\" parts, but \"literal\".\n        for (var _c = 0, _d = unitPattern.split(/(\\s*\\{0\\}\\s*)/); _c < _d.length; _c++) {\n          var part = _d[_c];\n          var interpolateMatch = /^(\\s*)\\{0\\}(\\s*)$/.exec(part);\n          if (interpolateMatch) {\n            // Space before \"{0}\"\n            if (interpolateMatch[1]) {\n              result.push({\n                type: 'literal',\n                value: interpolateMatch[1]\n              });\n            }\n            // \"{0}\" itself\n            result.push.apply(result, numberParts);\n            // Space after \"{0}\"\n            if (interpolateMatch[2]) {\n              result.push({\n                type: 'literal',\n                value: interpolateMatch[2]\n              });\n            }\n          } else if (part) {\n            result.push({\n              type: 'unit',\n              value: part\n            });\n          }\n        }\n        return result;\n      }\n    default:\n      return numberParts;\n  }\n  // #endregion\n}\n// A subset of https://tc39.es/ecma402/#sec-partitionnotationsubpattern\n// Plus the exponent parts handling.\nfunction paritionNumberIntoParts(symbols, numberResult, notation, exponent, numberingSystem, useGrouping,\n/**\n * This is the decimal number pattern without signs or symbols.\n * It is used to infer the group size when `useGrouping` is true.\n *\n * A typical value looks like \"#,##0.00\" (primary group size is 3).\n * Some locales like Hindi has secondary group size of 2 (e.g. \"#,##,##0.00\").\n */\ndecimalNumberPattern) {\n  var result = [];\n  // eslint-disable-next-line prefer-const\n  var n = numberResult.formattedString,\n    x = numberResult.roundedNumber;\n  if (isNaN(x)) {\n    return [{\n      type: 'nan',\n      value: n\n    }];\n  } else if (!isFinite(x)) {\n    return [{\n      type: 'infinity',\n      value: n\n    }];\n  }\n  var digitReplacementTable = digitMapping[numberingSystem];\n  if (digitReplacementTable) {\n    n = n.replace(/\\d/g, function (digit) {\n      return digitReplacementTable[+digit] || digit;\n    });\n  }\n  // TODO: Else use an implementation dependent algorithm to map n to the appropriate\n  // representation of n in the given numbering system.\n  var decimalSepIndex = n.indexOf('.');\n  var integer;\n  var fraction;\n  if (decimalSepIndex > 0) {\n    integer = n.slice(0, decimalSepIndex);\n    fraction = n.slice(decimalSepIndex + 1);\n  } else {\n    integer = n;\n  }\n  // #region Grouping integer digits\n  // The weird compact and x >= 10000 check is to ensure consistency with Node.js and Chrome.\n  // Note that `de` does not have compact form for thousands, but Node.js does not insert grouping separator\n  // unless the rounded number is greater than 10000:\n  //   NumberFormat('de', {notation: 'compact', compactDisplay: 'short'}).format(1234) //=> \"1234\"\n  //   NumberFormat('de').format(1234) //=> \"1.234\"\n  if (useGrouping && (notation !== 'compact' || x >= 10000)) {\n    var groupSepSymbol = symbols.group;\n    var groups = [];\n    // > There may be two different grouping sizes: The primary grouping size used for the least\n    // > significant integer group, and the secondary grouping size used for more significant groups.\n    // > If a pattern contains multiple grouping separators, the interval between the last one and the\n    // > end of the integer defines the primary grouping size, and the interval between the last two\n    // > defines the secondary grouping size. All others are ignored.\n    var integerNumberPattern = decimalNumberPattern.split('.')[0];\n    var patternGroups = integerNumberPattern.split(',');\n    var primaryGroupingSize = 3;\n    var secondaryGroupingSize = 3;\n    if (patternGroups.length > 1) {\n      primaryGroupingSize = patternGroups[patternGroups.length - 1].length;\n    }\n    if (patternGroups.length > 2) {\n      secondaryGroupingSize = patternGroups[patternGroups.length - 2].length;\n    }\n    var i = integer.length - primaryGroupingSize;\n    if (i > 0) {\n      // Slice the least significant integer group\n      groups.push(integer.slice(i, i + primaryGroupingSize));\n      // Then iteratively push the more signicant groups\n      // TODO: handle surrogate pairs in some numbering system digits\n      for (i -= secondaryGroupingSize; i > 0; i -= secondaryGroupingSize) {\n        groups.push(integer.slice(i, i + secondaryGroupingSize));\n      }\n      groups.push(integer.slice(0, i + secondaryGroupingSize));\n    } else {\n      groups.push(integer);\n    }\n    while (groups.length > 0) {\n      var integerGroup = groups.pop();\n      result.push({\n        type: 'integer',\n        value: integerGroup\n      });\n      if (groups.length > 0) {\n        result.push({\n          type: 'group',\n          value: groupSepSymbol\n        });\n      }\n    }\n  } else {\n    result.push({\n      type: 'integer',\n      value: integer\n    });\n  }\n  // #endregion\n  if (fraction !== undefined) {\n    result.push({\n      type: 'decimal',\n      value: symbols.decimal\n    }, {\n      type: 'fraction',\n      value: fraction\n    });\n  }\n  if ((notation === 'scientific' || notation === 'engineering') && isFinite(x)) {\n    result.push({\n      type: 'exponentSeparator',\n      value: symbols.exponential\n    });\n    if (exponent < 0) {\n      result.push({\n        type: 'exponentMinusSign',\n        value: symbols.minusSign\n      });\n      exponent = -exponent;\n    }\n    var exponentResult = ToRawFixed(exponent, 0, 0);\n    result.push({\n      type: 'exponentInteger',\n      value: exponentResult.formattedString\n    });\n  }\n  return result;\n}\nfunction getPatternForSign(pattern, sign) {\n  if (pattern.indexOf(';') < 0) {\n    pattern = pattern + \";-\" + pattern;\n  }\n  var _a = pattern.split(';'),\n    zeroPattern = _a[0],\n    negativePattern = _a[1];\n  switch (sign) {\n    case 0:\n      return zeroPattern;\n    case -1:\n      return negativePattern;\n    default:\n      return negativePattern.indexOf('-') >= 0 ? negativePattern.replace(/-/g, '+') : \"+\" + zeroPattern;\n  }\n}\n// Find the CLDR pattern for compact notation based on the magnitude of data and style.\n//\n// Example return value: \"¤ {c:laki}000;¤{c:laki} -0\" (`sw` locale):\n// - Notice the `{c:...}` token that wraps the compact literal.\n// - The consecutive zeros are normalized to single zero to match CLDR_NUMBER_PATTERN.\n//\n// Returning null means the compact display pattern cannot be found.\nfunction getCompactDisplayPattern(numberResult, pl, data, style, compactDisplay, currencyDisplay, numberingSystem) {\n  var _a;\n  var roundedNumber = numberResult.roundedNumber,\n    sign = numberResult.sign,\n    magnitude = numberResult.magnitude;\n  var magnitudeKey = String(Math.pow(10, magnitude));\n  var defaultNumberingSystem = data.numbers.nu[0];\n  var pattern;\n  if (style === 'currency' && currencyDisplay !== 'name') {\n    var byNumberingSystem = data.numbers.currency;\n    var currencyData = byNumberingSystem[numberingSystem] || byNumberingSystem[defaultNumberingSystem];\n    // NOTE: compact notation ignores currencySign!\n    var compactPluralRules = (_a = currencyData.short) === null || _a === void 0 ? void 0 : _a[magnitudeKey];\n    if (!compactPluralRules) {\n      return null;\n    }\n    pattern = selectPlural(pl, roundedNumber, compactPluralRules);\n  } else {\n    var byNumberingSystem = data.numbers.decimal;\n    var byCompactDisplay = byNumberingSystem[numberingSystem] || byNumberingSystem[defaultNumberingSystem];\n    var compactPlaralRule = byCompactDisplay[compactDisplay][magnitudeKey];\n    if (!compactPlaralRule) {\n      return null;\n    }\n    pattern = selectPlural(pl, roundedNumber, compactPlaralRule);\n  }\n  // See https://unicode.org/reports/tr35/tr35-numbers.html#Compact_Number_Formats\n  // > If the value is precisely “0”, either explicit or defaulted, then the normal number format\n  // > pattern for that sort of object is supplied.\n  if (pattern === '0') {\n    return null;\n  }\n  pattern = getPatternForSign(pattern, sign)\n  // Extract compact literal from the pattern\n  .replace(/([^\\s;\\-\\+\\d¤]+)/g, '{c:$1}')\n  // We replace one or more zeros with a single zero so it matches `CLDR_NUMBER_PATTERN`.\n  .replace(/0+/, '0');\n  return pattern;\n}\nfunction selectPlural(pl, x, rules) {\n  return rules[pl.select(x)] || rules.other;\n}","map":{"version":3,"names":["ToRawFixed","digitMapping","S_UNICODE_REGEX","CARET_S_UNICODE_REGEX","RegExp","source","S_DOLLAR_UNICODE_REGEX","CLDR_NUMBER_PATTERN","formatToParts","numberResult","data","pl","options","sign","exponent","magnitude","notation","style","numberingSystem","defaultNumberingSystem","numbers","nu","compactNumberPattern","getCompactDisplayPattern","compactDisplay","currencyDisplay","nonNameCurrencyPart","byCurrencyDisplay","currencies","currency","symbol","narrow","numberPattern","decimalData","decimal","getPatternForSign","standard","currencyData","currencySign","percentPattern","percent","decimalNumberPattern","exec","replace","afterCurrency","currencySpacing","afterInsertBetween","test","beforeCurrency","beforeInsertBetween","numberPatternParts","split","numberParts","symbols","_i","numberPatternParts_1","length","part","push","apply","paritionNumberIntoParts","useGrouping","type","value","minusSign","plusSign","percentSign","substring","unitPattern","unitName","currencyNameData","selectPlural","roundedNumber","Math","pow","displayName","unitPatternParts","result","_a","unitPatternParts_1","unit","unitDisplay","unitData","units","simple","_b","numeratorUnit","denominatorUnit","numeratorUnitPattern","perUnitPattern","perUnit","perPattern","compound","per","denominatorPattern","_c","_d","interpolateMatch","n","formattedString","x","isNaN","isFinite","digitReplacementTable","digit","decimalSepIndex","indexOf","integer","fraction","slice","groupSepSymbol","group","groups","integerNumberPattern","patternGroups","primaryGroupingSize","secondaryGroupingSize","i","integerGroup","pop","undefined","exponential","exponentResult","pattern","zeroPattern","negativePattern","magnitudeKey","String","byNumberingSystem","compactPluralRules","short","byCompactDisplay","compactPlaralRule","rules","select","other"],"sources":["C:/Users/Elton/OneDrive/Desktop/baseapp-2024/node_modules/@formatjs/ecma402-abstract/lib/NumberFormat/format_to_parts.js"],"sourcesContent":["import { ToRawFixed } from './ToRawFixed';\nimport * as digitMapping from './digit-mapping.json';\n// This is from: unicode-12.1.0/General_Category/Symbol/regex.js\n// IE11 does not support unicode flag, otherwise this is just /\\p{S}/u.\nvar S_UNICODE_REGEX = /[\\$\\+<->\\^`\\|~\\xA2-\\xA6\\xA8\\xA9\\xAC\\xAE-\\xB1\\xB4\\xB8\\xD7\\xF7\\u02C2-\\u02C5\\u02D2-\\u02DF\\u02E5-\\u02EB\\u02ED\\u02EF-\\u02FF\\u0375\\u0384\\u0385\\u03F6\\u0482\\u058D-\\u058F\\u0606-\\u0608\\u060B\\u060E\\u060F\\u06DE\\u06E9\\u06FD\\u06FE\\u07F6\\u07FE\\u07FF\\u09F2\\u09F3\\u09FA\\u09FB\\u0AF1\\u0B70\\u0BF3-\\u0BFA\\u0C7F\\u0D4F\\u0D79\\u0E3F\\u0F01-\\u0F03\\u0F13\\u0F15-\\u0F17\\u0F1A-\\u0F1F\\u0F34\\u0F36\\u0F38\\u0FBE-\\u0FC5\\u0FC7-\\u0FCC\\u0FCE\\u0FCF\\u0FD5-\\u0FD8\\u109E\\u109F\\u1390-\\u1399\\u166D\\u17DB\\u1940\\u19DE-\\u19FF\\u1B61-\\u1B6A\\u1B74-\\u1B7C\\u1FBD\\u1FBF-\\u1FC1\\u1FCD-\\u1FCF\\u1FDD-\\u1FDF\\u1FED-\\u1FEF\\u1FFD\\u1FFE\\u2044\\u2052\\u207A-\\u207C\\u208A-\\u208C\\u20A0-\\u20BF\\u2100\\u2101\\u2103-\\u2106\\u2108\\u2109\\u2114\\u2116-\\u2118\\u211E-\\u2123\\u2125\\u2127\\u2129\\u212E\\u213A\\u213B\\u2140-\\u2144\\u214A-\\u214D\\u214F\\u218A\\u218B\\u2190-\\u2307\\u230C-\\u2328\\u232B-\\u2426\\u2440-\\u244A\\u249C-\\u24E9\\u2500-\\u2767\\u2794-\\u27C4\\u27C7-\\u27E5\\u27F0-\\u2982\\u2999-\\u29D7\\u29DC-\\u29FB\\u29FE-\\u2B73\\u2B76-\\u2B95\\u2B98-\\u2BFF\\u2CE5-\\u2CEA\\u2E80-\\u2E99\\u2E9B-\\u2EF3\\u2F00-\\u2FD5\\u2FF0-\\u2FFB\\u3004\\u3012\\u3013\\u3020\\u3036\\u3037\\u303E\\u303F\\u309B\\u309C\\u3190\\u3191\\u3196-\\u319F\\u31C0-\\u31E3\\u3200-\\u321E\\u322A-\\u3247\\u3250\\u3260-\\u327F\\u328A-\\u32B0\\u32C0-\\u33FF\\u4DC0-\\u4DFF\\uA490-\\uA4C6\\uA700-\\uA716\\uA720\\uA721\\uA789\\uA78A\\uA828-\\uA82B\\uA836-\\uA839\\uAA77-\\uAA79\\uAB5B\\uFB29\\uFBB2-\\uFBC1\\uFDFC\\uFDFD\\uFE62\\uFE64-\\uFE66\\uFE69\\uFF04\\uFF0B\\uFF1C-\\uFF1E\\uFF3E\\uFF40\\uFF5C\\uFF5E\\uFFE0-\\uFFE6\\uFFE8-\\uFFEE\\uFFFC\\uFFFD]|\\uD800[\\uDD37-\\uDD3F\\uDD79-\\uDD89\\uDD8C-\\uDD8E\\uDD90-\\uDD9B\\uDDA0\\uDDD0-\\uDDFC]|\\uD802[\\uDC77\\uDC78\\uDEC8]|\\uD805\\uDF3F|\\uD807[\\uDFD5-\\uDFF1]|\\uD81A[\\uDF3C-\\uDF3F\\uDF45]|\\uD82F\\uDC9C|\\uD834[\\uDC00-\\uDCF5\\uDD00-\\uDD26\\uDD29-\\uDD64\\uDD6A-\\uDD6C\\uDD83\\uDD84\\uDD8C-\\uDDA9\\uDDAE-\\uDDE8\\uDE00-\\uDE41\\uDE45\\uDF00-\\uDF56]|\\uD835[\\uDEC1\\uDEDB\\uDEFB\\uDF15\\uDF35\\uDF4F\\uDF6F\\uDF89\\uDFA9\\uDFC3]|\\uD836[\\uDC00-\\uDDFF\\uDE37-\\uDE3A\\uDE6D-\\uDE74\\uDE76-\\uDE83\\uDE85\\uDE86]|\\uD838[\\uDD4F\\uDEFF]|\\uD83B[\\uDCAC\\uDCB0\\uDD2E\\uDEF0\\uDEF1]|\\uD83C[\\uDC00-\\uDC2B\\uDC30-\\uDC93\\uDCA0-\\uDCAE\\uDCB1-\\uDCBF\\uDCC1-\\uDCCF\\uDCD1-\\uDCF5\\uDD10-\\uDD6C\\uDD70-\\uDDAC\\uDDE6-\\uDE02\\uDE10-\\uDE3B\\uDE40-\\uDE48\\uDE50\\uDE51\\uDE60-\\uDE65\\uDF00-\\uDFFF]|\\uD83D[\\uDC00-\\uDED5\\uDEE0-\\uDEEC\\uDEF0-\\uDEFA\\uDF00-\\uDF73\\uDF80-\\uDFD8\\uDFE0-\\uDFEB]|\\uD83E[\\uDC00-\\uDC0B\\uDC10-\\uDC47\\uDC50-\\uDC59\\uDC60-\\uDC87\\uDC90-\\uDCAD\\uDD00-\\uDD0B\\uDD0D-\\uDD71\\uDD73-\\uDD76\\uDD7A-\\uDDA2\\uDDA5-\\uDDAA\\uDDAE-\\uDDCA\\uDDCD-\\uDE53\\uDE60-\\uDE6D\\uDE70-\\uDE73\\uDE78-\\uDE7A\\uDE80-\\uDE82\\uDE90-\\uDE95]/;\n// /^\\p{S}/u\nvar CARET_S_UNICODE_REGEX = new RegExp(\"^\" + S_UNICODE_REGEX.source);\n// /\\p{S}$/u\nvar S_DOLLAR_UNICODE_REGEX = new RegExp(S_UNICODE_REGEX.source + \"$\");\nvar CLDR_NUMBER_PATTERN = /[#0](?:[\\.,][#0]+)*/g;\nexport default function formatToParts(numberResult, data, pl, options) {\n    var sign = numberResult.sign, exponent = numberResult.exponent, magnitude = numberResult.magnitude;\n    var notation = options.notation, style = options.style, numberingSystem = options.numberingSystem;\n    var defaultNumberingSystem = data.numbers.nu[0];\n    // #region Part 1: partition and interpolate the CLDR number pattern.\n    // ----------------------------------------------------------\n    var compactNumberPattern = null;\n    if (notation === 'compact' && magnitude) {\n        compactNumberPattern = getCompactDisplayPattern(numberResult, pl, data, style, options.compactDisplay, options.currencyDisplay, numberingSystem);\n    }\n    // This is used multiple times\n    var nonNameCurrencyPart;\n    if (style === 'currency' && options.currencyDisplay !== 'name') {\n        var byCurrencyDisplay = data.currencies[options.currency];\n        if (byCurrencyDisplay) {\n            switch (options.currencyDisplay) {\n                case 'code':\n                    nonNameCurrencyPart = options.currency;\n                    break;\n                case 'symbol':\n                    nonNameCurrencyPart = byCurrencyDisplay.symbol;\n                    break;\n                default:\n                    nonNameCurrencyPart = byCurrencyDisplay.narrow;\n                    break;\n            }\n        }\n        else {\n            // Fallback for unknown currency\n            nonNameCurrencyPart = options.currency;\n        }\n    }\n    var numberPattern;\n    if (!compactNumberPattern) {\n        // Note: if the style is unit, or is currency and the currency display is name,\n        // its unit parts will be interpolated in part 2. So here we can fallback to decimal.\n        if (style === 'decimal' ||\n            style === 'unit' ||\n            (style === 'currency' && options.currencyDisplay === 'name')) {\n            // Shortcut for decimal\n            var decimalData = data.numbers.decimal[numberingSystem] ||\n                data.numbers.decimal[defaultNumberingSystem];\n            numberPattern = getPatternForSign(decimalData.standard, sign);\n        }\n        else if (style === 'currency') {\n            var currencyData = data.numbers.currency[numberingSystem] ||\n                data.numbers.currency[defaultNumberingSystem];\n            // We replace number pattern part with `0` for easier postprocessing.\n            numberPattern = getPatternForSign(currencyData[options.currencySign], sign);\n        }\n        else {\n            // percent\n            var percentPattern = data.numbers.percent[numberingSystem] ||\n                data.numbers.percent[defaultNumberingSystem];\n            numberPattern = getPatternForSign(percentPattern, sign);\n        }\n    }\n    else {\n        numberPattern = compactNumberPattern;\n    }\n    // Extract the decimal number pattern string. It looks like \"#,##0,00\", which will later be\n    // used to infer decimal group sizes.\n    var decimalNumberPattern = CLDR_NUMBER_PATTERN.exec(numberPattern)[0];\n    // Now we start to substitute patterns\n    // 1. replace strings like `0` and `#,##0.00` with `{0}`\n    // 2. unquote characters (invariant: the quoted characters does not contain the special tokens)\n    numberPattern = numberPattern\n        .replace(CLDR_NUMBER_PATTERN, '{0}')\n        .replace(/'(.)'/g, '$1');\n    // Handle currency spacing (both compact and non-compact).\n    if (style === 'currency' && options.currencyDisplay !== 'name') {\n        var currencyData = data.numbers.currency[numberingSystem] ||\n            data.numbers.currency[defaultNumberingSystem];\n        // See `currencySpacing` substitution rule in TR-35.\n        // Here we always assume the currencyMatch is \"[:^S:]\" and surroundingMatch is \"[:digit:]\".\n        //\n        // Example 1: for pattern \"#,##0.00¤\" with symbol \"US$\", we replace \"¤\" with the symbol,\n        // but insert an extra non-break space before the symbol, because \"[:^S:]\" matches \"U\" in\n        // \"US$\" and \"[:digit:]\" matches the latn numbering system digits.\n        //\n        // Example 2: for pattern \"¤#,##0.00\" with symbol \"US$\", there is no spacing between symbol\n        // and number, because `$` does not match \"[:^S:]\".\n        //\n        // Implementation note: here we do the best effort to infer the insertion.\n        // We also assume that `beforeInsertBetween` and `afterInsertBetween` will never be `;`.\n        var afterCurrency = currencyData.currencySpacing.afterInsertBetween;\n        if (afterCurrency && !S_DOLLAR_UNICODE_REGEX.test(nonNameCurrencyPart)) {\n            numberPattern = numberPattern.replace('¤{0}', \"\\u00A4\" + afterCurrency + \"{0}\");\n        }\n        var beforeCurrency = currencyData.currencySpacing.beforeInsertBetween;\n        if (beforeCurrency && !CARET_S_UNICODE_REGEX.test(nonNameCurrencyPart)) {\n            numberPattern = numberPattern.replace('{0}¤', \"{0}\" + beforeCurrency + \"\\u00A4\");\n        }\n    }\n    // The following tokens are special: `{0}`, `¤`, `%`, `-`, `+`, `{c:...}.\n    var numberPatternParts = numberPattern.split(/({c:[^}]+}|\\{0\\}|[¤%\\-\\+])/g);\n    var numberParts = [];\n    var symbols = data.numbers.symbols[numberingSystem] ||\n        data.numbers.symbols[defaultNumberingSystem];\n    for (var _i = 0, numberPatternParts_1 = numberPatternParts; _i < numberPatternParts_1.length; _i++) {\n        var part = numberPatternParts_1[_i];\n        if (!part) {\n            continue;\n        }\n        switch (part) {\n            case '{0}': {\n                // We only need to handle scientific and engineering notation here.\n                numberParts.push.apply(numberParts, paritionNumberIntoParts(symbols, numberResult, notation, exponent, numberingSystem, \n                // If compact number pattern exists, do not insert group separators.\n                !compactNumberPattern && options.useGrouping, decimalNumberPattern));\n                break;\n            }\n            case '-':\n                numberParts.push({ type: 'minusSign', value: symbols.minusSign });\n                break;\n            case '+':\n                numberParts.push({ type: 'plusSign', value: symbols.plusSign });\n                break;\n            case '%':\n                numberParts.push({ type: 'percentSign', value: symbols.percentSign });\n                break;\n            case '¤':\n                // Computed above when handling currency spacing.\n                numberParts.push({ type: 'currency', value: nonNameCurrencyPart });\n                break;\n            default:\n                if (/^\\{c:/.test(part)) {\n                    numberParts.push({\n                        type: 'compact',\n                        value: part.substring(3, part.length - 1),\n                    });\n                }\n                else {\n                    // literal\n                    numberParts.push({ type: 'literal', value: part });\n                }\n                break;\n        }\n    }\n    // #endregion\n    // #region Part 2: interpolate unit pattern if necessary.\n    // ----------------------------------------------\n    switch (style) {\n        case 'currency': {\n            // `currencyDisplay: 'name'` has similar pattern handling as units.\n            if (options.currencyDisplay === 'name') {\n                var unitPattern = (data.numbers.currency[numberingSystem] ||\n                    data.numbers.currency[defaultNumberingSystem]).unitPattern;\n                // Select plural\n                var unitName = void 0;\n                var currencyNameData = data.currencies[options.currency];\n                if (currencyNameData) {\n                    unitName = selectPlural(pl, numberResult.roundedNumber * Math.pow(10, exponent), currencyNameData.displayName);\n                }\n                else {\n                    // Fallback for unknown currency\n                    unitName = options.currency;\n                }\n                // Do {0} and {1} substitution\n                var unitPatternParts = unitPattern.split(/(\\{[01]\\})/g);\n                var result = [];\n                for (var _a = 0, unitPatternParts_1 = unitPatternParts; _a < unitPatternParts_1.length; _a++) {\n                    var part = unitPatternParts_1[_a];\n                    switch (part) {\n                        case '{0}':\n                            result.push.apply(result, numberParts);\n                            break;\n                        case '{1}':\n                            result.push({ type: 'currency', value: unitName });\n                            break;\n                        default:\n                            if (part) {\n                                result.push({ type: 'literal', value: part });\n                            }\n                            break;\n                    }\n                }\n                return result;\n            }\n            else {\n                return numberParts;\n            }\n        }\n        case 'unit': {\n            var unit = options.unit, unitDisplay = options.unitDisplay;\n            var unitData = data.units.simple[unit];\n            var unitPattern = void 0;\n            if (unitData) {\n                // Simple unit pattern\n                unitPattern = selectPlural(pl, numberResult.roundedNumber * Math.pow(10, exponent), data.units.simple[unit][unitDisplay]);\n            }\n            else {\n                // See: http://unicode.org/reports/tr35/tr35-general.html#perUnitPatterns\n                // If cannot find unit in the simple pattern, it must be \"per\" compound pattern.\n                // Implementation note: we are not following TR-35 here because we need to format to parts!\n                var _b = unit.split('-per-'), numeratorUnit = _b[0], denominatorUnit = _b[1];\n                unitData = data.units.simple[numeratorUnit];\n                var numeratorUnitPattern = selectPlural(pl, numberResult.roundedNumber * Math.pow(10, exponent), data.units.simple[numeratorUnit][unitDisplay]);\n                var perUnitPattern = data.units.simple[denominatorUnit].perUnit[unitDisplay];\n                if (perUnitPattern) {\n                    // perUnitPattern exists, combine it with numeratorUnitPattern\n                    unitPattern = perUnitPattern.replace('{0}', numeratorUnitPattern);\n                }\n                else {\n                    // get compoundUnit pattern (e.g. \"{0} per {1}\"), repalce {0} with numerator pattern and {1} with\n                    // the denominator pattern in singular form.\n                    var perPattern = data.units.compound.per[unitDisplay];\n                    var denominatorPattern = selectPlural(pl, 1, data.units.simple[denominatorUnit][unitDisplay]);\n                    unitPattern = unitPattern = perPattern\n                        .replace('{0}', numeratorUnitPattern)\n                        .replace('{1}', denominatorPattern.replace('{0}', ''));\n                }\n            }\n            var result = [];\n            // We need spacing around \"{0}\" because they are not treated as \"unit\" parts, but \"literal\".\n            for (var _c = 0, _d = unitPattern.split(/(\\s*\\{0\\}\\s*)/); _c < _d.length; _c++) {\n                var part = _d[_c];\n                var interpolateMatch = /^(\\s*)\\{0\\}(\\s*)$/.exec(part);\n                if (interpolateMatch) {\n                    // Space before \"{0}\"\n                    if (interpolateMatch[1]) {\n                        result.push({ type: 'literal', value: interpolateMatch[1] });\n                    }\n                    // \"{0}\" itself\n                    result.push.apply(result, numberParts);\n                    // Space after \"{0}\"\n                    if (interpolateMatch[2]) {\n                        result.push({ type: 'literal', value: interpolateMatch[2] });\n                    }\n                }\n                else if (part) {\n                    result.push({ type: 'unit', value: part });\n                }\n            }\n            return result;\n        }\n        default:\n            return numberParts;\n    }\n    // #endregion\n}\n// A subset of https://tc39.es/ecma402/#sec-partitionnotationsubpattern\n// Plus the exponent parts handling.\nfunction paritionNumberIntoParts(symbols, numberResult, notation, exponent, numberingSystem, useGrouping, \n/**\n * This is the decimal number pattern without signs or symbols.\n * It is used to infer the group size when `useGrouping` is true.\n *\n * A typical value looks like \"#,##0.00\" (primary group size is 3).\n * Some locales like Hindi has secondary group size of 2 (e.g. \"#,##,##0.00\").\n */\ndecimalNumberPattern) {\n    var result = [];\n    // eslint-disable-next-line prefer-const\n    var n = numberResult.formattedString, x = numberResult.roundedNumber;\n    if (isNaN(x)) {\n        return [{ type: 'nan', value: n }];\n    }\n    else if (!isFinite(x)) {\n        return [{ type: 'infinity', value: n }];\n    }\n    var digitReplacementTable = digitMapping[numberingSystem];\n    if (digitReplacementTable) {\n        n = n.replace(/\\d/g, function (digit) { return digitReplacementTable[+digit] || digit; });\n    }\n    // TODO: Else use an implementation dependent algorithm to map n to the appropriate\n    // representation of n in the given numbering system.\n    var decimalSepIndex = n.indexOf('.');\n    var integer;\n    var fraction;\n    if (decimalSepIndex > 0) {\n        integer = n.slice(0, decimalSepIndex);\n        fraction = n.slice(decimalSepIndex + 1);\n    }\n    else {\n        integer = n;\n    }\n    // #region Grouping integer digits\n    // The weird compact and x >= 10000 check is to ensure consistency with Node.js and Chrome.\n    // Note that `de` does not have compact form for thousands, but Node.js does not insert grouping separator\n    // unless the rounded number is greater than 10000:\n    //   NumberFormat('de', {notation: 'compact', compactDisplay: 'short'}).format(1234) //=> \"1234\"\n    //   NumberFormat('de').format(1234) //=> \"1.234\"\n    if (useGrouping && (notation !== 'compact' || x >= 10000)) {\n        var groupSepSymbol = symbols.group;\n        var groups = [];\n        // > There may be two different grouping sizes: The primary grouping size used for the least\n        // > significant integer group, and the secondary grouping size used for more significant groups.\n        // > If a pattern contains multiple grouping separators, the interval between the last one and the\n        // > end of the integer defines the primary grouping size, and the interval between the last two\n        // > defines the secondary grouping size. All others are ignored.\n        var integerNumberPattern = decimalNumberPattern.split('.')[0];\n        var patternGroups = integerNumberPattern.split(',');\n        var primaryGroupingSize = 3;\n        var secondaryGroupingSize = 3;\n        if (patternGroups.length > 1) {\n            primaryGroupingSize = patternGroups[patternGroups.length - 1].length;\n        }\n        if (patternGroups.length > 2) {\n            secondaryGroupingSize = patternGroups[patternGroups.length - 2].length;\n        }\n        var i = integer.length - primaryGroupingSize;\n        if (i > 0) {\n            // Slice the least significant integer group\n            groups.push(integer.slice(i, i + primaryGroupingSize));\n            // Then iteratively push the more signicant groups\n            // TODO: handle surrogate pairs in some numbering system digits\n            for (i -= secondaryGroupingSize; i > 0; i -= secondaryGroupingSize) {\n                groups.push(integer.slice(i, i + secondaryGroupingSize));\n            }\n            groups.push(integer.slice(0, i + secondaryGroupingSize));\n        }\n        else {\n            groups.push(integer);\n        }\n        while (groups.length > 0) {\n            var integerGroup = groups.pop();\n            result.push({ type: 'integer', value: integerGroup });\n            if (groups.length > 0) {\n                result.push({ type: 'group', value: groupSepSymbol });\n            }\n        }\n    }\n    else {\n        result.push({ type: 'integer', value: integer });\n    }\n    // #endregion\n    if (fraction !== undefined) {\n        result.push({ type: 'decimal', value: symbols.decimal }, { type: 'fraction', value: fraction });\n    }\n    if ((notation === 'scientific' || notation === 'engineering') &&\n        isFinite(x)) {\n        result.push({ type: 'exponentSeparator', value: symbols.exponential });\n        if (exponent < 0) {\n            result.push({ type: 'exponentMinusSign', value: symbols.minusSign });\n            exponent = -exponent;\n        }\n        var exponentResult = ToRawFixed(exponent, 0, 0);\n        result.push({\n            type: 'exponentInteger',\n            value: exponentResult.formattedString,\n        });\n    }\n    return result;\n}\nfunction getPatternForSign(pattern, sign) {\n    if (pattern.indexOf(';') < 0) {\n        pattern = pattern + \";-\" + pattern;\n    }\n    var _a = pattern.split(';'), zeroPattern = _a[0], negativePattern = _a[1];\n    switch (sign) {\n        case 0:\n            return zeroPattern;\n        case -1:\n            return negativePattern;\n        default:\n            return negativePattern.indexOf('-') >= 0\n                ? negativePattern.replace(/-/g, '+')\n                : \"+\" + zeroPattern;\n    }\n}\n// Find the CLDR pattern for compact notation based on the magnitude of data and style.\n//\n// Example return value: \"¤ {c:laki}000;¤{c:laki} -0\" (`sw` locale):\n// - Notice the `{c:...}` token that wraps the compact literal.\n// - The consecutive zeros are normalized to single zero to match CLDR_NUMBER_PATTERN.\n//\n// Returning null means the compact display pattern cannot be found.\nfunction getCompactDisplayPattern(numberResult, pl, data, style, compactDisplay, currencyDisplay, numberingSystem) {\n    var _a;\n    var roundedNumber = numberResult.roundedNumber, sign = numberResult.sign, magnitude = numberResult.magnitude;\n    var magnitudeKey = String(Math.pow(10, magnitude));\n    var defaultNumberingSystem = data.numbers.nu[0];\n    var pattern;\n    if (style === 'currency' && currencyDisplay !== 'name') {\n        var byNumberingSystem = data.numbers.currency;\n        var currencyData = byNumberingSystem[numberingSystem] ||\n            byNumberingSystem[defaultNumberingSystem];\n        // NOTE: compact notation ignores currencySign!\n        var compactPluralRules = (_a = currencyData.short) === null || _a === void 0 ? void 0 : _a[magnitudeKey];\n        if (!compactPluralRules) {\n            return null;\n        }\n        pattern = selectPlural(pl, roundedNumber, compactPluralRules);\n    }\n    else {\n        var byNumberingSystem = data.numbers.decimal;\n        var byCompactDisplay = byNumberingSystem[numberingSystem] ||\n            byNumberingSystem[defaultNumberingSystem];\n        var compactPlaralRule = byCompactDisplay[compactDisplay][magnitudeKey];\n        if (!compactPlaralRule) {\n            return null;\n        }\n        pattern = selectPlural(pl, roundedNumber, compactPlaralRule);\n    }\n    // See https://unicode.org/reports/tr35/tr35-numbers.html#Compact_Number_Formats\n    // > If the value is precisely “0”, either explicit or defaulted, then the normal number format\n    // > pattern for that sort of object is supplied.\n    if (pattern === '0') {\n        return null;\n    }\n    pattern = getPatternForSign(pattern, sign)\n        // Extract compact literal from the pattern\n        .replace(/([^\\s;\\-\\+\\d¤]+)/g, '{c:$1}')\n        // We replace one or more zeros with a single zero so it matches `CLDR_NUMBER_PATTERN`.\n        .replace(/0+/, '0');\n    return pattern;\n}\nfunction selectPlural(pl, x, rules) {\n    return rules[pl.select(x)] || rules.other;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}