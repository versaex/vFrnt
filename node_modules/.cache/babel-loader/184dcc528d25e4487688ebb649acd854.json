{"ast":null,"code":"import { __values } from \"tslib\";\nimport { API } from '@sentry/core';\nimport { Status } from '@sentry/types';\nimport { logger, parseRetryAfterHeader, PromiseBuffer, SentryError } from '@sentry/utils';\n/** Base Transport class implementation */\nvar BaseTransport = /** @class */function () {\n  function BaseTransport(options) {\n    this.options = options;\n    /** A simple buffer holding all requests. */\n    this._buffer = new PromiseBuffer(30);\n    /** Locks transport after receiving rate limits in a response */\n    this._rateLimits = {};\n    this._api = new API(this.options.dsn);\n    // eslint-disable-next-line deprecation/deprecation\n    this.url = this._api.getStoreEndpointWithUrlEncodedAuth();\n  }\n  /**\n   * @inheritDoc\n   */\n  BaseTransport.prototype.sendEvent = function (_) {\n    throw new SentryError('Transport Class has to implement `sendEvent` method');\n  };\n  /**\n   * @inheritDoc\n   */\n  BaseTransport.prototype.close = function (timeout) {\n    return this._buffer.drain(timeout);\n  };\n  /**\n   * Handle Sentry repsonse for promise-based transports.\n   */\n  BaseTransport.prototype._handleResponse = function (_a) {\n    var requestType = _a.requestType,\n      response = _a.response,\n      headers = _a.headers,\n      resolve = _a.resolve,\n      reject = _a.reject;\n    var status = Status.fromHttpCode(response.status);\n    /**\n     * \"The name is case-insensitive.\"\n     * https://developer.mozilla.org/en-US/docs/Web/API/Headers/get\n     */\n    var limited = this._handleRateLimit(headers);\n    if (limited) logger.warn(\"Too many requests, backing off until: \" + this._disabledUntil(requestType));\n    if (status === Status.Success) {\n      resolve({\n        status: status\n      });\n      return;\n    }\n    reject(response);\n  };\n  /**\n   * Gets the time that given category is disabled until for rate limiting\n   */\n  BaseTransport.prototype._disabledUntil = function (category) {\n    return this._rateLimits[category] || this._rateLimits.all;\n  };\n  /**\n   * Checks if a category is rate limited\n   */\n  BaseTransport.prototype._isRateLimited = function (category) {\n    return this._disabledUntil(category) > new Date(Date.now());\n  };\n  /**\n   * Sets internal _rateLimits from incoming headers. Returns true if headers contains a non-empty rate limiting header.\n   */\n  BaseTransport.prototype._handleRateLimit = function (headers) {\n    var e_1, _a, e_2, _b;\n    var now = Date.now();\n    var rlHeader = headers['x-sentry-rate-limits'];\n    var raHeader = headers['retry-after'];\n    if (rlHeader) {\n      try {\n        // rate limit headers are of the form\n        //     <header>,<header>,..\n        // where each <header> is of the form\n        //     <retry_after>: <categories>: <scope>: <reason_code>\n        // where\n        //     <retry_after> is a delay in ms\n        //     <categories> is the event type(s) (error, transaction, etc) being rate limited and is of the form\n        //         <category>;<category>;...\n        //     <scope> is what's being limited (org, project, or key) - ignored by SDK\n        //     <reason_code> is an arbitrary string like \"org_quota\" - ignored by SDK\n        for (var _c = __values(rlHeader.trim().split(',')), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var limit = _d.value;\n          var parameters = limit.split(':', 2);\n          var headerDelay = parseInt(parameters[0], 10);\n          var delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1000; // 60sec default\n          try {\n            for (var _e = (e_2 = void 0, __values(parameters[1].split(';'))), _f = _e.next(); !_f.done; _f = _e.next()) {\n              var category = _f.value;\n              this._rateLimits[category || 'all'] = new Date(now + delay);\n            }\n          } catch (e_2_1) {\n            e_2 = {\n              error: e_2_1\n            };\n          } finally {\n            try {\n              if (_f && !_f.done && (_b = _e.return)) _b.call(_e);\n            } finally {\n              if (e_2) throw e_2.error;\n            }\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n      return true;\n    } else if (raHeader) {\n      this._rateLimits.all = new Date(now + parseRetryAfterHeader(now, raHeader));\n      return true;\n    }\n    return false;\n  };\n  return BaseTransport;\n}();\nexport { BaseTransport };","map":{"version":3,"sources":["../../src/transports/base.ts"],"names":[],"mappings":"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","sourcesContent":["import { API } from '@sentry/core';\nimport {\n  Event,\n  Response as SentryResponse,\n  SentryRequestType,\n  Status,\n  Transport,\n  TransportOptions,\n} from '@sentry/types';\nimport { logger, parseRetryAfterHeader, PromiseBuffer, SentryError } from '@sentry/utils';\n\n/** Base Transport class implementation */\nexport abstract class BaseTransport implements Transport {\n  /**\n   * @deprecated\n   */\n  public url: string;\n\n  /** Helper to get Sentry API endpoints. */\n  protected readonly _api: API;\n\n  /** A simple buffer holding all requests. */\n  protected readonly _buffer: PromiseBuffer<SentryResponse> = new PromiseBuffer(30);\n\n  /** Locks transport after receiving rate limits in a response */\n  protected readonly _rateLimits: Record<string, Date> = {};\n\n  public constructor(public options: TransportOptions) {\n    this._api = new API(this.options.dsn);\n    // eslint-disable-next-line deprecation/deprecation\n    this.url = this._api.getStoreEndpointWithUrlEncodedAuth();\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public sendEvent(_: Event): PromiseLike<SentryResponse> {\n    throw new SentryError('Transport Class has to implement `sendEvent` method');\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public close(timeout?: number): PromiseLike<boolean> {\n    return this._buffer.drain(timeout);\n  }\n\n  /**\n   * Handle Sentry repsonse for promise-based transports.\n   */\n  protected _handleResponse({\n    requestType,\n    response,\n    headers,\n    resolve,\n    reject,\n  }: {\n    requestType: SentryRequestType;\n    response: Response | XMLHttpRequest;\n    headers: Record<string, string | null>;\n    resolve: (value?: SentryResponse | PromiseLike<SentryResponse> | null | undefined) => void;\n    reject: (reason?: unknown) => void;\n  }): void {\n    const status = Status.fromHttpCode(response.status);\n    /**\n     * \"The name is case-insensitive.\"\n     * https://developer.mozilla.org/en-US/docs/Web/API/Headers/get\n     */\n    const limited = this._handleRateLimit(headers);\n    if (limited) logger.warn(`Too many requests, backing off until: ${this._disabledUntil(requestType)}`);\n\n    if (status === Status.Success) {\n      resolve({ status });\n      return;\n    }\n\n    reject(response);\n  }\n\n  /**\n   * Gets the time that given category is disabled until for rate limiting\n   */\n  protected _disabledUntil(category: string): Date {\n    return this._rateLimits[category] || this._rateLimits.all;\n  }\n\n  /**\n   * Checks if a category is rate limited\n   */\n  protected _isRateLimited(category: string): boolean {\n    return this._disabledUntil(category) > new Date(Date.now());\n  }\n\n  /**\n   * Sets internal _rateLimits from incoming headers. Returns true if headers contains a non-empty rate limiting header.\n   */\n  protected _handleRateLimit(headers: Record<string, string | null>): boolean {\n    const now = Date.now();\n    const rlHeader = headers['x-sentry-rate-limits'];\n    const raHeader = headers['retry-after'];\n\n    if (rlHeader) {\n      // rate limit headers are of the form\n      //     <header>,<header>,..\n      // where each <header> is of the form\n      //     <retry_after>: <categories>: <scope>: <reason_code>\n      // where\n      //     <retry_after> is a delay in ms\n      //     <categories> is the event type(s) (error, transaction, etc) being rate limited and is of the form\n      //         <category>;<category>;...\n      //     <scope> is what's being limited (org, project, or key) - ignored by SDK\n      //     <reason_code> is an arbitrary string like \"org_quota\" - ignored by SDK\n      for (const limit of rlHeader.trim().split(',')) {\n        const parameters = limit.split(':', 2);\n        const headerDelay = parseInt(parameters[0], 10);\n        const delay = (!isNaN(headerDelay) ? headerDelay : 60) * 1000; // 60sec default\n        for (const category of parameters[1].split(';')) {\n          this._rateLimits[category || 'all'] = new Date(now + delay);\n        }\n      }\n      return true;\n    } else if (raHeader) {\n      this._rateLimits.all = new Date(now + parseRetryAfterHeader(now, raHeader));\n      return true;\n    }\n    return false;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}