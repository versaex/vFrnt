{"ast":null,"code":"'use strict';\n\nvar inherits = require('inherits');\nvar $ = require('../../util/preconditions');\nvar BufferUtil = require('../../util/buffer');\nvar Hash = require('../../crypto/hash');\nvar Input = require('./input');\nvar Output = require('../output');\nvar Sighash = require('../sighash');\nvar Script = require('../../script');\nvar Signature = require('../../crypto/signature');\nvar TransactionSignature = require('../signature');\n\n/**\n * Represents a special kind of input of PayToPublicKeyHash kind.\n * @constructor\n */\nfunction PublicKeyHashInput() {\n  Input.apply(this, arguments);\n}\ninherits(PublicKeyHashInput, Input);\n\n/* jshint maxparams: 5 */\n/**\n * @param {Transaction} transaction - the transaction to be signed\n * @param {PrivateKey} privateKey - the private key with which to sign the transaction\n * @param {number} index - the index of the input in the transaction input vector\n * @param {number=} sigtype - the type of signature, defaults to Signature.SIGHASH_ALL\n * @param {Buffer=} hashData - the precalculated hash of the public key associated with the privateKey provided\n * @return {Array} of objects that can be\n */\nPublicKeyHashInput.prototype.getSignatures = function (transaction, privateKey, index, sigtype, hashData) {\n  $.checkState(this.output instanceof Output);\n  hashData = hashData || Hash.sha256ripemd160(privateKey.publicKey.toBuffer());\n  sigtype = sigtype || Signature.SIGHASH_ALL | Signature.SIGHASH_FORKID;\n  if (BufferUtil.equals(hashData, this.output.script.getPublicKeyHash())) {\n    return [new TransactionSignature({\n      publicKey: privateKey.publicKey,\n      prevTxId: this.prevTxId,\n      outputIndex: this.outputIndex,\n      inputIndex: index,\n      signature: Sighash.sign(transaction, privateKey, sigtype, index, this.output.script, this.output.satoshisBN),\n      sigtype: sigtype\n    })];\n  }\n  return [];\n};\n/* jshint maxparams: 3 */\n\n/**\n * Add the provided signature\n *\n * @param {Object} signature\n * @param {PublicKey} signature.publicKey\n * @param {Signature} signature.signature\n * @param {number=} signature.sigtype\n * @return {PublicKeyHashInput} this, for chaining\n */\nPublicKeyHashInput.prototype.addSignature = function (transaction, signature) {\n  $.checkState(this.isValidSignature(transaction, signature), 'Signature is invalid');\n  this.setScript(Script.buildPublicKeyHashIn(signature.publicKey, signature.signature.toDER(), signature.sigtype));\n  return this;\n};\n\n/**\n * Clear the input's signature\n * @return {PublicKeyHashInput} this, for chaining\n */\nPublicKeyHashInput.prototype.clearSignatures = function () {\n  this.setScript(Script.empty());\n  return this;\n};\n\n/**\n * Query whether the input is signed\n * @return {boolean}\n */\nPublicKeyHashInput.prototype.isFullySigned = function () {\n  return this.script.isPublicKeyHashIn();\n};\nPublicKeyHashInput.SCRIPT_MAX_SIZE = 73 + 34; // sigsize (1 + 72) + pubkey (1 + 33)\n\nPublicKeyHashInput.prototype._estimateSize = function () {\n  return PublicKeyHashInput.SCRIPT_MAX_SIZE;\n};\nmodule.exports = PublicKeyHashInput;","map":{"version":3,"names":["inherits","require","$","BufferUtil","Hash","Input","Output","Sighash","Script","Signature","TransactionSignature","PublicKeyHashInput","apply","arguments","prototype","getSignatures","transaction","privateKey","index","sigtype","hashData","checkState","output","sha256ripemd160","publicKey","toBuffer","SIGHASH_ALL","SIGHASH_FORKID","equals","script","getPublicKeyHash","prevTxId","outputIndex","inputIndex","signature","sign","satoshisBN","addSignature","isValidSignature","setScript","buildPublicKeyHashIn","toDER","clearSignatures","empty","isFullySigned","isPublicKeyHashIn","SCRIPT_MAX_SIZE","_estimateSize","module","exports"],"sources":["C:/Users/Elton/OneDrive/Desktop/baseapp-2024/node_modules/bitcoincashjs/src/transaction/input/publickeyhash.js"],"sourcesContent":["'use strict';\n\nvar inherits = require('inherits');\n\nvar $ = require('../../util/preconditions');\nvar BufferUtil = require('../../util/buffer');\n\nvar Hash = require('../../crypto/hash');\nvar Input = require('./input');\nvar Output = require('../output');\nvar Sighash = require('../sighash');\nvar Script = require('../../script');\nvar Signature = require('../../crypto/signature');\nvar TransactionSignature = require('../signature');\n\n/**\n * Represents a special kind of input of PayToPublicKeyHash kind.\n * @constructor\n */\nfunction PublicKeyHashInput() {\n  Input.apply(this, arguments);\n}\ninherits(PublicKeyHashInput, Input);\n\n/* jshint maxparams: 5 */\n/**\n * @param {Transaction} transaction - the transaction to be signed\n * @param {PrivateKey} privateKey - the private key with which to sign the transaction\n * @param {number} index - the index of the input in the transaction input vector\n * @param {number=} sigtype - the type of signature, defaults to Signature.SIGHASH_ALL\n * @param {Buffer=} hashData - the precalculated hash of the public key associated with the privateKey provided\n * @return {Array} of objects that can be\n */\nPublicKeyHashInput.prototype.getSignatures = function(transaction, privateKey, index, sigtype, hashData) {\n  $.checkState(this.output instanceof Output);\n  hashData = hashData || Hash.sha256ripemd160(privateKey.publicKey.toBuffer());\n  sigtype = sigtype || (Signature.SIGHASH_ALL |  Signature.SIGHASH_FORKID);\n\n  if (BufferUtil.equals(hashData, this.output.script.getPublicKeyHash())) {\n    return [new TransactionSignature({\n      publicKey: privateKey.publicKey,\n      prevTxId: this.prevTxId,\n      outputIndex: this.outputIndex,\n      inputIndex: index,\n      signature: Sighash.sign(transaction, privateKey, sigtype, index, this.output.script, this.output.satoshisBN),\n      sigtype: sigtype\n    })];\n  }\n  return [];\n};\n/* jshint maxparams: 3 */\n\n/**\n * Add the provided signature\n *\n * @param {Object} signature\n * @param {PublicKey} signature.publicKey\n * @param {Signature} signature.signature\n * @param {number=} signature.sigtype\n * @return {PublicKeyHashInput} this, for chaining\n */\nPublicKeyHashInput.prototype.addSignature = function(transaction, signature) {\n  $.checkState(this.isValidSignature(transaction, signature), 'Signature is invalid');\n\n  this.setScript(Script.buildPublicKeyHashIn(\n    signature.publicKey,\n    signature.signature.toDER(),\n    signature.sigtype\n  ));\n  return this;\n};\n\n/**\n * Clear the input's signature\n * @return {PublicKeyHashInput} this, for chaining\n */\nPublicKeyHashInput.prototype.clearSignatures = function() {\n  this.setScript(Script.empty());\n  return this;\n};\n\n/**\n * Query whether the input is signed\n * @return {boolean}\n */\nPublicKeyHashInput.prototype.isFullySigned = function() {\n  return this.script.isPublicKeyHashIn();\n};\n\nPublicKeyHashInput.SCRIPT_MAX_SIZE = 73 + 34; // sigsize (1 + 72) + pubkey (1 + 33)\n\nPublicKeyHashInput.prototype._estimateSize = function() {\n  return PublicKeyHashInput.SCRIPT_MAX_SIZE;\n};\n\nmodule.exports = PublicKeyHashInput;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}