{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\nvar $ = require('../util/preconditions');\nvar BN = require('../crypto/bn');\nvar errors = require('../errors');\nvar Hash = require('../crypto/hash');\nvar HDPrivateKey = require('../hdprivatekey');\nvar Random = require('../crypto/random');\nvar unorm = require('unorm');\n\n/**\n * This is an immutable class that represents a BIP39 Mnemonic code.\n * See BIP39 specification for more info: https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki\n * A Mnemonic code is a a group of easy to remember words used for the generation\n * of deterministic wallets. A Mnemonic can be used to generate a seed using\n * an optional passphrase, for later generate a HDPrivateKey.\n *\n * @example\n * // generate a random mnemonic\n * var mnemonic = new Mnemonic();\n * var phrase = mnemonic.phrase;\n *\n * // use a different language\n * var mnemonic = new Mnemonic(Mnemonic.Words.SPANISH);\n * var xprivkey = mnemonic.toHDPrivateKey();\n *\n * @param {*=} data - a seed, phrase, or entropy to initialize (can be skipped)\n * @param {Array=} wordlist - the wordlist to generate mnemonics from\n * @returns {Mnemonic} A new instance of Mnemonic\n * @constructor\n */\nvar Mnemonic = function Mnemonic(data, wordlist) {\n  if (!(this instanceof Mnemonic)) {\n    return new Mnemonic(data, wordlist);\n  }\n  if (_.isArray(data)) {\n    wordlist = data;\n    data = null;\n  }\n\n  // handle data overloading\n  var ent, phrase, seed;\n  if (Buffer.isBuffer(data)) {\n    seed = data;\n  } else if (_.isString(data)) {\n    phrase = unorm.nfkd(data);\n  } else if (_.isNumber(data)) {\n    ent = data;\n  } else if (data) {\n    throw new errors.InvalidArgument('data', 'Must be a Buffer, a string or an integer');\n  }\n  ent = ent || 128;\n\n  // check and detect wordlist\n  wordlist = wordlist || Mnemonic._getDictionary(phrase);\n  if (phrase && !wordlist) {\n    throw new errors.UnknownWordlist(phrase);\n  }\n  wordlist = wordlist || Mnemonic.Words.ENGLISH;\n  if (seed) {\n    phrase = Mnemonic._entropy2mnemonic(seed, wordlist);\n  }\n\n  // validate phrase and ent\n  if (phrase && !Mnemonic.isValid(phrase, wordlist)) {\n    throw new errors.InvalidMnemonic(phrase);\n  }\n  if (ent % 32 !== 0 || ent < 128) {\n    throw new errors.InvalidArgument('ENT', 'Values must be ENT > 128 and ENT % 32 == 0');\n  }\n  phrase = phrase || Mnemonic._mnemonic(ent, wordlist);\n  Object.defineProperty(this, 'wordlist', {\n    configurable: false,\n    value: wordlist\n  });\n  Object.defineProperty(this, 'phrase', {\n    configurable: false,\n    value: phrase\n  });\n};\nMnemonic.Words = require('./words');\n\n/**\n * Will return a boolean if the mnemonic is valid\n *\n * @example\n *\n * var valid = Mnemonic.isValid('lab rescue lunch elbow recall phrase perfect donkey biology guess moment husband');\n * // true\n *\n * @param {String} mnemonic - The mnemonic string\n * @param {String} [wordlist] - The wordlist used\n * @returns {boolean}\n */\nMnemonic.isValid = function (mnemonic, wordlist) {\n  mnemonic = unorm.nfkd(mnemonic);\n  wordlist = wordlist || Mnemonic._getDictionary(mnemonic);\n  if (!wordlist) {\n    return false;\n  }\n  var words = mnemonic.split(' ');\n  var bin = '';\n  for (var i = 0; i < words.length; i++) {\n    var ind = wordlist.indexOf(words[i]);\n    if (ind < 0) return false;\n    bin = bin + ('00000000000' + ind.toString(2)).slice(-11);\n  }\n  var cs = bin.length / 33;\n  var hash_bits = bin.slice(-cs);\n  var nonhash_bits = bin.slice(0, bin.length - cs);\n  var buf = new Buffer(nonhash_bits.length / 8);\n  for (i = 0; i < nonhash_bits.length / 8; i++) {\n    buf.writeUInt8(parseInt(bin.slice(i * 8, (i + 1) * 8), 2), i);\n  }\n  var expected_hash_bits = Mnemonic._entropyChecksum(buf);\n  return expected_hash_bits === hash_bits;\n};\n\n/**\n * Internal function to check if a mnemonic belongs to a wordlist.\n *\n * @param {String} mnemonic - The mnemonic string\n * @param {String} wordlist - The wordlist\n * @returns {boolean}\n */\nMnemonic._belongsToWordlist = function (mnemonic, wordlist) {\n  var words = unorm.nfkd(mnemonic).split(' ');\n  for (var i = 0; i < words.length; i++) {\n    var ind = wordlist.indexOf(words[i]);\n    if (ind < 0) return false;\n  }\n  return true;\n};\n\n/**\n * Internal function to detect the wordlist used to generate the mnemonic.\n *\n * @param {String} mnemonic - The mnemonic string\n * @returns {Array} the wordlist or null\n */\nMnemonic._getDictionary = function (mnemonic) {\n  if (!mnemonic) return null;\n  var dicts = Object.keys(Mnemonic.Words);\n  for (var i = 0; i < dicts.length; i++) {\n    var key = dicts[i];\n    if (Mnemonic._belongsToWordlist(mnemonic, Mnemonic.Words[key])) {\n      return Mnemonic.Words[key];\n    }\n  }\n  return null;\n};\n\n/**\n * Will generate a seed based on the mnemonic and optional passphrase.\n *\n * @param {String} [passphrase]\n * @returns {Buffer}\n */\nMnemonic.prototype.toSeed = function (passphrase) {\n  passphrase = passphrase || '';\n  return Mnemonic.pbkdf2(unorm.nfkd(this.phrase), unorm.nfkd('mnemonic' + passphrase), 2048, 64);\n};\n\n/**\n * Will generate a Mnemonic object based on a seed.\n *\n * @param {Buffer} [seed]\n * @param {string} [wordlist]\n * @returns {Mnemonic}\n */\nMnemonic.fromSeed = function (seed, wordlist) {\n  $.checkArgument(Buffer.isBuffer(seed), 'seed must be a Buffer.');\n  $.checkArgument(_.isArray(wordlist) || _.isString(wordlist), 'wordlist must be a string or an array.');\n  return new Mnemonic(seed, wordlist);\n};\n\n/**\n *\n * Generates a HD Private Key from a Mnemonic.\n * Optionally receive a passphrase and bitcoin network.\n *\n * @param {String=} [passphrase]\n * @param {Network|String|number=} [network] - The network: 'livenet' or 'testnet'\n * @returns {HDPrivateKey}\n */\nMnemonic.prototype.toHDPrivateKey = function (passphrase, network) {\n  var seed = this.toSeed(passphrase);\n  return HDPrivateKey.fromSeed(seed, network);\n};\n\n/**\n * Will return a the string representation of the mnemonic\n *\n * @returns {String} Mnemonic\n */\nMnemonic.prototype.toString = function () {\n  return this.phrase;\n};\n\n/**\n * Will return a string formatted for the console\n *\n * @returns {String} Mnemonic\n */\nMnemonic.prototype.inspect = function () {\n  return '<Mnemonic: ' + this.toString() + ' >';\n};\n\n/**\n * Internal function to generate a random mnemonic\n *\n * @param {Number} ENT - Entropy size, defaults to 128\n * @param {Array} wordlist - Array of words to generate the mnemonic\n * @returns {String} Mnemonic string\n */\nMnemonic._mnemonic = function (ENT, wordlist) {\n  var buf = Random.getRandomBuffer(ENT / 8);\n  return Mnemonic._entropy2mnemonic(buf, wordlist);\n};\n\n/**\n * Internal function to generate mnemonic based on entropy\n *\n * @param {Number} entropy - Entropy buffer\n * @param {Array} wordlist - Array of words to generate the mnemonic\n * @returns {String} Mnemonic string\n */\nMnemonic._entropy2mnemonic = function (entropy, wordlist) {\n  var bin = '';\n  for (var i = 0; i < entropy.length; i++) {\n    bin = bin + ('00000000' + entropy[i].toString(2)).slice(-8);\n  }\n  bin = bin + Mnemonic._entropyChecksum(entropy);\n  if (bin.length % 11 !== 0) {\n    throw new errors.InvalidEntropy(bin);\n  }\n  var mnemonic = [];\n  for (i = 0; i < bin.length / 11; i++) {\n    var wi = parseInt(bin.slice(i * 11, (i + 1) * 11), 2);\n    mnemonic.push(wordlist[wi]);\n  }\n  var ret;\n  if (wordlist === Mnemonic.Words.JAPANESE) {\n    ret = mnemonic.join(\"\\u3000\");\n  } else {\n    ret = mnemonic.join(' ');\n  }\n  return ret;\n};\n\n/**\n * Internal function to create checksum of entropy\n *\n * @param entropy\n * @returns {string} Checksum of entropy length / 32\n * @private\n */\nMnemonic._entropyChecksum = function (entropy) {\n  var hash = Hash.sha256(entropy);\n  var bits = entropy.length * 8;\n  var cs = bits / 32;\n  var hashbits = new BN(hash.toString('hex'), 16).toString(2);\n\n  // zero pad the hash bits\n  while (hashbits.length % 256 !== 0) {\n    hashbits = '0' + hashbits;\n  }\n  var checksum = hashbits.slice(0, cs);\n  return checksum;\n};\nMnemonic.pbkdf2 = require('./pbkdf2');\nmodule.exports = Mnemonic;","map":{"version":3,"names":["_","require","$","BN","errors","Hash","HDPrivateKey","Random","unorm","Mnemonic","data","wordlist","isArray","ent","phrase","seed","Buffer","isBuffer","isString","nfkd","isNumber","InvalidArgument","_getDictionary","UnknownWordlist","Words","ENGLISH","_entropy2mnemonic","isValid","InvalidMnemonic","_mnemonic","Object","defineProperty","configurable","value","mnemonic","words","split","bin","i","length","ind","indexOf","toString","slice","cs","hash_bits","nonhash_bits","buf","writeUInt8","parseInt","expected_hash_bits","_entropyChecksum","_belongsToWordlist","dicts","keys","key","prototype","toSeed","passphrase","pbkdf2","fromSeed","checkArgument","toHDPrivateKey","network","inspect","ENT","getRandomBuffer","entropy","InvalidEntropy","wi","push","ret","JAPANESE","join","hash","sha256","bits","hashbits","checksum","module","exports"],"sources":["C:/Users/Elton/OneDrive/Desktop/baseapp-2024/node_modules/bitcoincashjs/src/mnemonic/mnemonic.js"],"sourcesContent":["'use strict';\n\nvar _ = require('lodash');\nvar $ = require('../util/preconditions');\nvar BN = require('../crypto/bn');\nvar errors = require('../errors');\nvar Hash = require('../crypto/hash');\nvar HDPrivateKey = require('../hdprivatekey');\nvar Random = require('../crypto/random');\nvar unorm = require('unorm');\n\n/**\n * This is an immutable class that represents a BIP39 Mnemonic code.\n * See BIP39 specification for more info: https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki\n * A Mnemonic code is a a group of easy to remember words used for the generation\n * of deterministic wallets. A Mnemonic can be used to generate a seed using\n * an optional passphrase, for later generate a HDPrivateKey.\n *\n * @example\n * // generate a random mnemonic\n * var mnemonic = new Mnemonic();\n * var phrase = mnemonic.phrase;\n *\n * // use a different language\n * var mnemonic = new Mnemonic(Mnemonic.Words.SPANISH);\n * var xprivkey = mnemonic.toHDPrivateKey();\n *\n * @param {*=} data - a seed, phrase, or entropy to initialize (can be skipped)\n * @param {Array=} wordlist - the wordlist to generate mnemonics from\n * @returns {Mnemonic} A new instance of Mnemonic\n * @constructor\n */\nvar Mnemonic = function(data, wordlist) {\n  if (!(this instanceof Mnemonic)) {\n    return new Mnemonic(data, wordlist);\n  }\n\n  if (_.isArray(data)) {\n    wordlist = data;\n    data = null;\n  }\n\n\n  // handle data overloading\n  var ent, phrase, seed;\n  if (Buffer.isBuffer(data)) {\n    seed = data;\n  } else if (_.isString(data)) {\n    phrase = unorm.nfkd(data);\n  } else if (_.isNumber(data)) {\n    ent = data;\n  } else if (data) {\n    throw new errors.InvalidArgument('data', 'Must be a Buffer, a string or an integer');\n  }\n  ent = ent || 128;\n\n\n  // check and detect wordlist\n  wordlist = wordlist || Mnemonic._getDictionary(phrase);\n  if (phrase && !wordlist) {\n    throw new errors.UnknownWordlist(phrase);\n  }\n  wordlist = wordlist || Mnemonic.Words.ENGLISH;\n\n  if (seed) {\n    phrase = Mnemonic._entropy2mnemonic(seed, wordlist);\n  }\n\n\n  // validate phrase and ent\n  if (phrase && !Mnemonic.isValid(phrase, wordlist)) {\n    throw new errors.InvalidMnemonic(phrase);\n  }\n  if (ent % 32 !== 0 || ent < 128) {\n    throw new errors.InvalidArgument('ENT', 'Values must be ENT > 128 and ENT % 32 == 0');\n  }\n\n  phrase = phrase || Mnemonic._mnemonic(ent, wordlist);\n\n  Object.defineProperty(this, 'wordlist', {\n    configurable: false,\n    value: wordlist\n  });\n\n  Object.defineProperty(this, 'phrase', {\n    configurable: false,\n    value: phrase\n  });\n};\n\nMnemonic.Words = require('./words');\n\n/**\n * Will return a boolean if the mnemonic is valid\n *\n * @example\n *\n * var valid = Mnemonic.isValid('lab rescue lunch elbow recall phrase perfect donkey biology guess moment husband');\n * // true\n *\n * @param {String} mnemonic - The mnemonic string\n * @param {String} [wordlist] - The wordlist used\n * @returns {boolean}\n */\nMnemonic.isValid = function(mnemonic, wordlist) {\n  mnemonic = unorm.nfkd(mnemonic);\n  wordlist = wordlist || Mnemonic._getDictionary(mnemonic);\n\n  if (!wordlist) {\n    return false;\n  }\n\n  var words = mnemonic.split(' ');\n  var bin = '';\n  for (var i = 0; i < words.length; i++) {\n    var ind = wordlist.indexOf(words[i]);\n    if (ind < 0) return false;\n    bin = bin + ('00000000000' + ind.toString(2)).slice(-11);\n  }\n\n  var cs = bin.length / 33;\n  var hash_bits = bin.slice(-cs);\n  var nonhash_bits = bin.slice(0, bin.length - cs);\n  var buf = new Buffer(nonhash_bits.length / 8);\n  for (i = 0; i < nonhash_bits.length / 8; i++) {\n    buf.writeUInt8(parseInt(bin.slice(i * 8, (i + 1) * 8), 2), i);\n  }\n  var expected_hash_bits = Mnemonic._entropyChecksum(buf);\n  return expected_hash_bits === hash_bits;\n};\n\n/**\n * Internal function to check if a mnemonic belongs to a wordlist.\n *\n * @param {String} mnemonic - The mnemonic string\n * @param {String} wordlist - The wordlist\n * @returns {boolean}\n */\nMnemonic._belongsToWordlist = function(mnemonic, wordlist) {\n  var words = unorm.nfkd(mnemonic).split(' ');\n  for (var i = 0; i < words.length; i++) {\n    var ind = wordlist.indexOf(words[i]);\n    if (ind < 0) return false;\n  }\n  return true;\n};\n\n/**\n * Internal function to detect the wordlist used to generate the mnemonic.\n *\n * @param {String} mnemonic - The mnemonic string\n * @returns {Array} the wordlist or null\n */\nMnemonic._getDictionary = function(mnemonic) {\n  if (!mnemonic) return null;\n\n  var dicts = Object.keys(Mnemonic.Words);\n  for (var i = 0; i < dicts.length; i++) {\n    var key = dicts[i];\n    if (Mnemonic._belongsToWordlist(mnemonic, Mnemonic.Words[key])) {\n      return Mnemonic.Words[key];\n    }\n  }\n  return null;\n};\n\n/**\n * Will generate a seed based on the mnemonic and optional passphrase.\n *\n * @param {String} [passphrase]\n * @returns {Buffer}\n */\nMnemonic.prototype.toSeed = function(passphrase) {\n  passphrase = passphrase || '';\n  return Mnemonic.pbkdf2(unorm.nfkd(this.phrase), unorm.nfkd('mnemonic' + passphrase), 2048, 64);\n};\n\n/**\n * Will generate a Mnemonic object based on a seed.\n *\n * @param {Buffer} [seed]\n * @param {string} [wordlist]\n * @returns {Mnemonic}\n */\nMnemonic.fromSeed = function(seed, wordlist) {\n  $.checkArgument(Buffer.isBuffer(seed), 'seed must be a Buffer.');\n  $.checkArgument(_.isArray(wordlist) || _.isString(wordlist), 'wordlist must be a string or an array.');\n  return new Mnemonic(seed, wordlist);\n};\n\n/**\n *\n * Generates a HD Private Key from a Mnemonic.\n * Optionally receive a passphrase and bitcoin network.\n *\n * @param {String=} [passphrase]\n * @param {Network|String|number=} [network] - The network: 'livenet' or 'testnet'\n * @returns {HDPrivateKey}\n */\nMnemonic.prototype.toHDPrivateKey = function(passphrase, network) {\n  var seed = this.toSeed(passphrase);\n  return HDPrivateKey.fromSeed(seed, network);\n};\n\n/**\n * Will return a the string representation of the mnemonic\n *\n * @returns {String} Mnemonic\n */\nMnemonic.prototype.toString = function() {\n  return this.phrase;\n};\n\n/**\n * Will return a string formatted for the console\n *\n * @returns {String} Mnemonic\n */\nMnemonic.prototype.inspect = function() {\n  return '<Mnemonic: ' + this.toString() + ' >';\n};\n\n/**\n * Internal function to generate a random mnemonic\n *\n * @param {Number} ENT - Entropy size, defaults to 128\n * @param {Array} wordlist - Array of words to generate the mnemonic\n * @returns {String} Mnemonic string\n */\nMnemonic._mnemonic = function(ENT, wordlist) {\n  var buf = Random.getRandomBuffer(ENT / 8);\n  return Mnemonic._entropy2mnemonic(buf, wordlist);\n};\n\n/**\n * Internal function to generate mnemonic based on entropy\n *\n * @param {Number} entropy - Entropy buffer\n * @param {Array} wordlist - Array of words to generate the mnemonic\n * @returns {String} Mnemonic string\n */\nMnemonic._entropy2mnemonic = function(entropy, wordlist) {\n  var bin = '';\n  for (var i = 0; i < entropy.length; i++) {\n    bin = bin + ('00000000' + entropy[i].toString(2)).slice(-8);\n  }\n\n  bin = bin + Mnemonic._entropyChecksum(entropy);\n  if (bin.length % 11 !== 0) {\n    throw new errors.InvalidEntropy(bin);\n  }\n  var mnemonic = [];\n  for (i = 0; i < bin.length / 11; i++) {\n    var wi = parseInt(bin.slice(i * 11, (i + 1) * 11), 2);\n    mnemonic.push(wordlist[wi]);\n  }\n  var ret;\n  if (wordlist === Mnemonic.Words.JAPANESE) {\n    ret = mnemonic.join('\\u3000');\n  } else {\n    ret = mnemonic.join(' ');\n  }\n  return ret;\n};\n\n/**\n * Internal function to create checksum of entropy\n *\n * @param entropy\n * @returns {string} Checksum of entropy length / 32\n * @private\n */\nMnemonic._entropyChecksum = function(entropy) {\n  var hash = Hash.sha256(entropy);\n  var bits = entropy.length * 8;\n  var cs = bits / 32;\n\n  var hashbits = new BN(hash.toString('hex'), 16).toString(2);\n\n  // zero pad the hash bits\n  while (hashbits.length % 256 !== 0) {\n    hashbits = '0' + hashbits;\n  }\n\n  var checksum = hashbits.slice(0, cs);\n\n  return checksum;\n};\n\nMnemonic.pbkdf2 = require('./pbkdf2');\n\nmodule.exports = Mnemonic;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}