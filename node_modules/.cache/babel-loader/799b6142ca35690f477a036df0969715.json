{"ast":null,"code":"'use strict';\n\nvar BN = require('./crypto/bn');\nvar Point = require('./crypto/point');\nvar Hash = require('./crypto/hash');\nvar JSUtil = require('./util/js');\nvar Network = require('./networks');\nvar _ = require('lodash');\nvar $ = require('./util/preconditions');\n\n/**\n * Instantiate a PublicKey from a {@link PrivateKey}, {@link Point}, `string`, or `Buffer`.\n *\n * There are two internal properties, `network` and `compressed`, that deal with importing\n * a PublicKey from a PrivateKey in WIF format. More details described on {@link PrivateKey}\n *\n * @example\n * ```javascript\n * // instantiate from a private key\n * var key = PublicKey(privateKey, true);\n *\n * // export to as a DER hex encoded string\n * var exported = key.toString();\n *\n * // import the public key\n * var imported = PublicKey.fromString(exported);\n * ```\n *\n * @param {string} data - The encoded data in various formats\n * @param {Object} extra - additional options\n * @param {Network=} extra.network - Which network should the address for this public key be for\n * @param {String=} extra.compressed - If the public key is compressed\n * @returns {PublicKey} A new valid instance of an PublicKey\n * @constructor\n */\nfunction PublicKey(data, extra) {\n  if (!(this instanceof PublicKey)) {\n    return new PublicKey(data, extra);\n  }\n  $.checkArgument(data, 'First argument is required, please include public key data.');\n  if (data instanceof PublicKey) {\n    // Return copy, but as it's an immutable object, return same argument\n    return data;\n  }\n  extra = extra || {};\n  var info = this._classifyArgs(data, extra);\n\n  // validation\n  info.point.validate();\n  JSUtil.defineImmutable(this, {\n    point: info.point,\n    compressed: info.compressed,\n    network: info.network || Network.defaultNetwork\n  });\n  return this;\n}\n;\n\n/**\n * Internal function to differentiate between arguments passed to the constructor\n * @param {*} data\n * @param {Object} extra\n */\nPublicKey.prototype._classifyArgs = function (data, extra) {\n  /* jshint maxcomplexity: 10 */\n  var info = {\n    compressed: _.isUndefined(extra.compressed) || extra.compressed\n  };\n\n  // detect type of data\n  if (data instanceof Point) {\n    info.point = data;\n  } else if (data.x && data.y) {\n    info = PublicKey._transformObject(data);\n  } else if (typeof data === 'string') {\n    info = PublicKey._transformDER(new Buffer(data, 'hex'));\n  } else if (PublicKey._isBuffer(data)) {\n    info = PublicKey._transformDER(data);\n  } else if (PublicKey._isPrivateKey(data)) {\n    info = PublicKey._transformPrivateKey(data);\n  } else {\n    throw new TypeError('First argument is an unrecognized data format.');\n  }\n  if (!info.network) {\n    info.network = _.isUndefined(extra.network) ? undefined : Network.get(extra.network);\n  }\n  return info;\n};\n\n/**\n * Internal function to detect if an object is a {@link PrivateKey}\n *\n * @param {*} param - object to test\n * @returns {boolean}\n * @private\n */\nPublicKey._isPrivateKey = function (param) {\n  var PrivateKey = require('./privatekey');\n  return param instanceof PrivateKey;\n};\n\n/**\n * Internal function to detect if an object is a Buffer\n *\n * @param {*} param - object to test\n * @returns {boolean}\n * @private\n */\nPublicKey._isBuffer = function (param) {\n  return param instanceof Buffer || param instanceof Uint8Array;\n};\n\n/**\n * Internal function to transform a private key into a public key point\n *\n * @param {PrivateKey} privkey - An instance of PrivateKey\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\nPublicKey._transformPrivateKey = function (privkey) {\n  $.checkArgument(PublicKey._isPrivateKey(privkey), 'Must be an instance of PrivateKey');\n  var info = {};\n  info.point = Point.getG().mul(privkey.bn);\n  info.compressed = privkey.compressed;\n  info.network = privkey.network;\n  return info;\n};\n\n/**\n * Internal function to transform DER into a public key point\n *\n * @param {Buffer} buf - An hex encoded buffer\n * @param {bool=} strict - if set to false, will loosen some conditions\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\nPublicKey._transformDER = function (buf, strict) {\n  /* jshint maxstatements: 30 */\n  /* jshint maxcomplexity: 12 */\n  $.checkArgument(PublicKey._isBuffer(buf), 'Must be a hex buffer of DER encoded public key');\n  var info = {};\n  strict = _.isUndefined(strict) ? true : strict;\n  var x;\n  var y;\n  var xbuf;\n  var ybuf;\n  if (buf[0] === 0x04 || !strict && (buf[0] === 0x06 || buf[0] === 0x07)) {\n    xbuf = buf.slice(1, 33);\n    ybuf = buf.slice(33, 65);\n    if (xbuf.length !== 32 || ybuf.length !== 32 || buf.length !== 65) {\n      throw new TypeError('Length of x and y must be 32 bytes');\n    }\n    x = new BN(xbuf);\n    y = new BN(ybuf);\n    info.point = new Point(x, y);\n    info.compressed = false;\n  } else if (buf[0] === 0x03) {\n    xbuf = buf.slice(1);\n    x = new BN(xbuf);\n    info = PublicKey._transformX(true, x);\n    info.compressed = true;\n  } else if (buf[0] === 0x02) {\n    xbuf = buf.slice(1);\n    x = new BN(xbuf);\n    info = PublicKey._transformX(false, x);\n    info.compressed = true;\n  } else {\n    throw new TypeError('Invalid DER format public key');\n  }\n  return info;\n};\n\n/**\n * Internal function to transform X into a public key point\n *\n * @param {Boolean} odd - If the point is above or below the x axis\n * @param {Point} x - The x point\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\nPublicKey._transformX = function (odd, x) {\n  $.checkArgument(typeof odd === 'boolean', 'Must specify whether y is odd or not (true or false)');\n  var info = {};\n  info.point = Point.fromX(odd, x);\n  return info;\n};\n\n/**\n * Internal function to transform a JSON into a public key point\n *\n * @param {String|Object} json - a JSON string or plain object\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\nPublicKey._transformObject = function (json) {\n  var x = new BN(json.x, 'hex');\n  var y = new BN(json.y, 'hex');\n  var point = new Point(x, y);\n  return new PublicKey(point, {\n    compressed: json.compressed\n  });\n};\n\n/**\n * Instantiate a PublicKey from a PrivateKey\n *\n * @param {PrivateKey} privkey - An instance of PrivateKey\n * @returns {PublicKey} A new valid instance of PublicKey\n */\nPublicKey.fromPrivateKey = function (privkey) {\n  $.checkArgument(PublicKey._isPrivateKey(privkey), 'Must be an instance of PrivateKey');\n  var info = PublicKey._transformPrivateKey(privkey);\n  return new PublicKey(info.point, {\n    compressed: info.compressed,\n    network: info.network\n  });\n};\n\n/**\n * Instantiate a PublicKey from a Buffer\n * @param {Buffer} buf - A DER hex buffer\n * @param {bool=} strict - if set to false, will loosen some conditions\n * @returns {PublicKey} A new valid instance of PublicKey\n */\nPublicKey.fromDER = PublicKey.fromBuffer = function (buf, strict) {\n  $.checkArgument(PublicKey._isBuffer(buf), 'Must be a hex buffer of DER encoded public key');\n  var info = PublicKey._transformDER(buf, strict);\n  return new PublicKey(info.point, {\n    compressed: info.compressed\n  });\n};\n\n/**\n * Instantiate a PublicKey from a Point\n *\n * @param {Point} point - A Point instance\n * @param {boolean=} compressed - whether to store this public key as compressed format\n * @returns {PublicKey} A new valid instance of PublicKey\n */\nPublicKey.fromPoint = function (point, compressed) {\n  $.checkArgument(point instanceof Point, 'First argument must be an instance of Point.');\n  return new PublicKey(point, {\n    compressed: compressed\n  });\n};\n\n/**\n * Instantiate a PublicKey from a DER hex encoded string\n *\n * @param {string} str - A DER hex string\n * @param {String=} encoding - The type of string encoding\n * @returns {PublicKey} A new valid instance of PublicKey\n */\nPublicKey.fromString = function (str, encoding) {\n  var buf = new Buffer(str, encoding || 'hex');\n  var info = PublicKey._transformDER(buf);\n  return new PublicKey(info.point, {\n    compressed: info.compressed\n  });\n};\n\n/**\n * Instantiate a PublicKey from an X Point\n *\n * @param {Boolean} odd - If the point is above or below the x axis\n * @param {Point} x - The x point\n * @returns {PublicKey} A new valid instance of PublicKey\n */\nPublicKey.fromX = function (odd, x) {\n  var info = PublicKey._transformX(odd, x);\n  return new PublicKey(info.point, {\n    compressed: info.compressed\n  });\n};\n\n/**\n * Check if there would be any errors when initializing a PublicKey\n *\n * @param {string} data - The encoded data in various formats\n * @returns {null|Error} An error if exists\n */\nPublicKey.getValidationError = function (data) {\n  var error;\n  try {\n    /* jshint nonew: false */\n    new PublicKey(data);\n  } catch (e) {\n    error = e;\n  }\n  return error;\n};\n\n/**\n * Check if the parameters are valid\n *\n * @param {string} data - The encoded data in various formats\n * @returns {Boolean} If the public key would be valid\n */\nPublicKey.isValid = function (data) {\n  return !PublicKey.getValidationError(data);\n};\n\n/**\n * @returns {Object} A plain object of the PublicKey\n */\nPublicKey.prototype.toObject = PublicKey.prototype.toJSON = function toObject() {\n  return {\n    x: this.point.getX().toString('hex', 2),\n    y: this.point.getY().toString('hex', 2),\n    compressed: this.compressed\n  };\n};\n\n/**\n * Will output the PublicKey to a DER Buffer\n *\n * @returns {Buffer} A DER hex encoded buffer\n */\nPublicKey.prototype.toBuffer = PublicKey.prototype.toDER = function () {\n  var x = this.point.getX();\n  var y = this.point.getY();\n  var xbuf = x.toBuffer({\n    size: 32\n  });\n  var ybuf = y.toBuffer({\n    size: 32\n  });\n  var prefix;\n  if (!this.compressed) {\n    prefix = new Buffer([0x04]);\n    return Buffer.concat([prefix, xbuf, ybuf]);\n  } else {\n    var odd = ybuf[ybuf.length - 1] % 2;\n    if (odd) {\n      prefix = new Buffer([0x03]);\n    } else {\n      prefix = new Buffer([0x02]);\n    }\n    return Buffer.concat([prefix, xbuf]);\n  }\n};\n\n/**\n * Will return a sha256 + ripemd160 hash of the serialized public key\n * @see https://github.com/bitcoin/bitcoin/blob/master/src/pubkey.h#L141\n * @returns {Buffer}\n */\nPublicKey.prototype._getID = function _getID() {\n  return Hash.sha256ripemd160(this.toBuffer());\n};\n\n/**\n * Will return an address for the public key\n *\n * @param {String|Network=} network - Which network should the address be for\n * @returns {Address} An address generated from the public key\n */\nPublicKey.prototype.toAddress = function (network) {\n  var Address = require('./address');\n  return Address.fromPublicKey(this, network || this.network);\n};\n\n/**\n * Will output the PublicKey to a DER encoded hex string\n *\n * @returns {string} A DER hex encoded string\n */\nPublicKey.prototype.toString = function () {\n  return this.toDER().toString('hex');\n};\n\n/**\n * Will return a string formatted for the console\n *\n * @returns {string} Public key\n */\nPublicKey.prototype.inspect = function () {\n  return '<PublicKey: ' + this.toString() + (this.compressed ? '' : ', uncompressed') + '>';\n};\nmodule.exports = PublicKey;","map":{"version":3,"names":["BN","require","Point","Hash","JSUtil","Network","_","$","PublicKey","data","extra","checkArgument","info","_classifyArgs","point","validate","defineImmutable","compressed","network","defaultNetwork","prototype","isUndefined","x","y","_transformObject","_transformDER","Buffer","_isBuffer","_isPrivateKey","_transformPrivateKey","TypeError","undefined","get","param","PrivateKey","Uint8Array","privkey","getG","mul","bn","buf","strict","xbuf","ybuf","slice","length","_transformX","odd","fromX","json","fromPrivateKey","fromDER","fromBuffer","fromPoint","fromString","str","encoding","getValidationError","error","e","isValid","toObject","toJSON","getX","toString","getY","toBuffer","toDER","size","prefix","concat","_getID","sha256ripemd160","toAddress","Address","fromPublicKey","inspect","module","exports"],"sources":["C:/Users/Elton/OneDrive/Desktop/baseapp-2024/node_modules/bitcoincashjs/src/publickey.js"],"sourcesContent":["'use strict';\n\nvar BN = require('./crypto/bn');\nvar Point = require('./crypto/point');\nvar Hash = require('./crypto/hash');\nvar JSUtil = require('./util/js');\nvar Network = require('./networks');\nvar _ = require('lodash');\nvar $ = require('./util/preconditions');\n\n/**\n * Instantiate a PublicKey from a {@link PrivateKey}, {@link Point}, `string`, or `Buffer`.\n *\n * There are two internal properties, `network` and `compressed`, that deal with importing\n * a PublicKey from a PrivateKey in WIF format. More details described on {@link PrivateKey}\n *\n * @example\n * ```javascript\n * // instantiate from a private key\n * var key = PublicKey(privateKey, true);\n *\n * // export to as a DER hex encoded string\n * var exported = key.toString();\n *\n * // import the public key\n * var imported = PublicKey.fromString(exported);\n * ```\n *\n * @param {string} data - The encoded data in various formats\n * @param {Object} extra - additional options\n * @param {Network=} extra.network - Which network should the address for this public key be for\n * @param {String=} extra.compressed - If the public key is compressed\n * @returns {PublicKey} A new valid instance of an PublicKey\n * @constructor\n */\nfunction PublicKey(data, extra) {\n\n  if (!(this instanceof PublicKey)) {\n    return new PublicKey(data, extra);\n  }\n\n  $.checkArgument(data, 'First argument is required, please include public key data.');\n\n  if (data instanceof PublicKey) {\n    // Return copy, but as it's an immutable object, return same argument\n    return data;\n  }\n  extra = extra || {};\n\n  var info = this._classifyArgs(data, extra);\n\n  // validation\n  info.point.validate();\n\n  JSUtil.defineImmutable(this, {\n    point: info.point,\n    compressed: info.compressed,\n    network: info.network || Network.defaultNetwork\n  });\n\n  return this;\n};\n\n/**\n * Internal function to differentiate between arguments passed to the constructor\n * @param {*} data\n * @param {Object} extra\n */\nPublicKey.prototype._classifyArgs = function(data, extra) {\n  /* jshint maxcomplexity: 10 */\n  var info = {\n    compressed: _.isUndefined(extra.compressed) || extra.compressed\n  };\n\n  // detect type of data\n  if (data instanceof Point) {\n    info.point = data;\n  } else if (data.x && data.y) {\n    info = PublicKey._transformObject(data);\n  } else if (typeof(data) === 'string') {\n    info = PublicKey._transformDER(new Buffer(data, 'hex'));\n  } else if (PublicKey._isBuffer(data)) {\n    info = PublicKey._transformDER(data);\n  } else if (PublicKey._isPrivateKey(data)) {\n    info = PublicKey._transformPrivateKey(data);\n  } else {\n    throw new TypeError('First argument is an unrecognized data format.');\n  }\n  if (!info.network) {\n    info.network = _.isUndefined(extra.network) ? undefined : Network.get(extra.network);\n  }\n  return info;\n};\n\n/**\n * Internal function to detect if an object is a {@link PrivateKey}\n *\n * @param {*} param - object to test\n * @returns {boolean}\n * @private\n */\nPublicKey._isPrivateKey = function(param) {\n  var PrivateKey = require('./privatekey');\n  return param instanceof PrivateKey;\n};\n\n/**\n * Internal function to detect if an object is a Buffer\n *\n * @param {*} param - object to test\n * @returns {boolean}\n * @private\n */\nPublicKey._isBuffer = function(param) {\n  return (param instanceof Buffer) || (param instanceof Uint8Array);\n};\n\n/**\n * Internal function to transform a private key into a public key point\n *\n * @param {PrivateKey} privkey - An instance of PrivateKey\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\nPublicKey._transformPrivateKey = function(privkey) {\n  $.checkArgument(PublicKey._isPrivateKey(privkey), 'Must be an instance of PrivateKey');\n  var info = {};\n  info.point = Point.getG().mul(privkey.bn);\n  info.compressed = privkey.compressed;\n  info.network = privkey.network;\n  return info;\n};\n\n/**\n * Internal function to transform DER into a public key point\n *\n * @param {Buffer} buf - An hex encoded buffer\n * @param {bool=} strict - if set to false, will loosen some conditions\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\nPublicKey._transformDER = function(buf, strict) {\n  /* jshint maxstatements: 30 */\n  /* jshint maxcomplexity: 12 */\n  $.checkArgument(PublicKey._isBuffer(buf), 'Must be a hex buffer of DER encoded public key');\n  var info = {};\n\n  strict = _.isUndefined(strict) ? true : strict;\n\n  var x;\n  var y;\n  var xbuf;\n  var ybuf;\n\n  if (buf[0] === 0x04 || (!strict && (buf[0] === 0x06 || buf[0] === 0x07))) {\n    xbuf = buf.slice(1, 33);\n    ybuf = buf.slice(33, 65);\n    if (xbuf.length !== 32 || ybuf.length !== 32 || buf.length !== 65) {\n      throw new TypeError('Length of x and y must be 32 bytes');\n    }\n    x = new BN(xbuf);\n    y = new BN(ybuf);\n    info.point = new Point(x, y);\n    info.compressed = false;\n  } else if (buf[0] === 0x03) {\n    xbuf = buf.slice(1);\n    x = new BN(xbuf);\n    info = PublicKey._transformX(true, x);\n    info.compressed = true;\n  } else if (buf[0] === 0x02) {\n    xbuf = buf.slice(1);\n    x = new BN(xbuf);\n    info = PublicKey._transformX(false, x);\n    info.compressed = true;\n  } else {\n    throw new TypeError('Invalid DER format public key');\n  }\n  return info;\n};\n\n/**\n * Internal function to transform X into a public key point\n *\n * @param {Boolean} odd - If the point is above or below the x axis\n * @param {Point} x - The x point\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\nPublicKey._transformX = function(odd, x) {\n  $.checkArgument(typeof odd === 'boolean', 'Must specify whether y is odd or not (true or false)');\n  var info = {};\n  info.point = Point.fromX(odd, x);\n  return info;\n};\n\n/**\n * Internal function to transform a JSON into a public key point\n *\n * @param {String|Object} json - a JSON string or plain object\n * @returns {Object} An object with keys: point and compressed\n * @private\n */\nPublicKey._transformObject = function(json) {\n  var x = new BN(json.x, 'hex');\n  var y = new BN(json.y, 'hex');\n  var point = new Point(x, y);\n  return new PublicKey(point, {\n    compressed: json.compressed\n  });\n};\n\n/**\n * Instantiate a PublicKey from a PrivateKey\n *\n * @param {PrivateKey} privkey - An instance of PrivateKey\n * @returns {PublicKey} A new valid instance of PublicKey\n */\nPublicKey.fromPrivateKey = function(privkey) {\n  $.checkArgument(PublicKey._isPrivateKey(privkey), 'Must be an instance of PrivateKey');\n  var info = PublicKey._transformPrivateKey(privkey);\n  return new PublicKey(info.point, {\n    compressed: info.compressed,\n    network: info.network\n  });\n};\n\n/**\n * Instantiate a PublicKey from a Buffer\n * @param {Buffer} buf - A DER hex buffer\n * @param {bool=} strict - if set to false, will loosen some conditions\n * @returns {PublicKey} A new valid instance of PublicKey\n */\nPublicKey.fromDER = PublicKey.fromBuffer = function(buf, strict) {\n  $.checkArgument(PublicKey._isBuffer(buf), 'Must be a hex buffer of DER encoded public key');\n  var info = PublicKey._transformDER(buf, strict);\n  return new PublicKey(info.point, {\n    compressed: info.compressed\n  });\n};\n\n/**\n * Instantiate a PublicKey from a Point\n *\n * @param {Point} point - A Point instance\n * @param {boolean=} compressed - whether to store this public key as compressed format\n * @returns {PublicKey} A new valid instance of PublicKey\n */\nPublicKey.fromPoint = function(point, compressed) {\n  $.checkArgument(point instanceof Point, 'First argument must be an instance of Point.');\n  return new PublicKey(point, {\n    compressed: compressed\n  });\n};\n\n/**\n * Instantiate a PublicKey from a DER hex encoded string\n *\n * @param {string} str - A DER hex string\n * @param {String=} encoding - The type of string encoding\n * @returns {PublicKey} A new valid instance of PublicKey\n */\nPublicKey.fromString = function(str, encoding) {\n  var buf = new Buffer(str, encoding || 'hex');\n  var info = PublicKey._transformDER(buf);\n  return new PublicKey(info.point, {\n    compressed: info.compressed\n  });\n};\n\n/**\n * Instantiate a PublicKey from an X Point\n *\n * @param {Boolean} odd - If the point is above or below the x axis\n * @param {Point} x - The x point\n * @returns {PublicKey} A new valid instance of PublicKey\n */\nPublicKey.fromX = function(odd, x) {\n  var info = PublicKey._transformX(odd, x);\n  return new PublicKey(info.point, {\n    compressed: info.compressed\n  });\n};\n\n/**\n * Check if there would be any errors when initializing a PublicKey\n *\n * @param {string} data - The encoded data in various formats\n * @returns {null|Error} An error if exists\n */\nPublicKey.getValidationError = function(data) {\n  var error;\n  try {\n    /* jshint nonew: false */\n    new PublicKey(data);\n  } catch (e) {\n    error = e;\n  }\n  return error;\n};\n\n/**\n * Check if the parameters are valid\n *\n * @param {string} data - The encoded data in various formats\n * @returns {Boolean} If the public key would be valid\n */\nPublicKey.isValid = function(data) {\n  return !PublicKey.getValidationError(data);\n};\n\n/**\n * @returns {Object} A plain object of the PublicKey\n */\nPublicKey.prototype.toObject = PublicKey.prototype.toJSON = function toObject() {\n  return {\n    x: this.point.getX().toString('hex', 2),\n    y: this.point.getY().toString('hex', 2),\n    compressed: this.compressed\n  };\n};\n\n/**\n * Will output the PublicKey to a DER Buffer\n *\n * @returns {Buffer} A DER hex encoded buffer\n */\nPublicKey.prototype.toBuffer = PublicKey.prototype.toDER = function() {\n  var x = this.point.getX();\n  var y = this.point.getY();\n\n  var xbuf = x.toBuffer({\n    size: 32\n  });\n  var ybuf = y.toBuffer({\n    size: 32\n  });\n\n  var prefix;\n  if (!this.compressed) {\n    prefix = new Buffer([0x04]);\n    return Buffer.concat([prefix, xbuf, ybuf]);\n  } else {\n    var odd = ybuf[ybuf.length - 1] % 2;\n    if (odd) {\n      prefix = new Buffer([0x03]);\n    } else {\n      prefix = new Buffer([0x02]);\n    }\n    return Buffer.concat([prefix, xbuf]);\n  }\n};\n\n/**\n * Will return a sha256 + ripemd160 hash of the serialized public key\n * @see https://github.com/bitcoin/bitcoin/blob/master/src/pubkey.h#L141\n * @returns {Buffer}\n */\nPublicKey.prototype._getID = function _getID() {\n  return Hash.sha256ripemd160(this.toBuffer());\n};\n\n/**\n * Will return an address for the public key\n *\n * @param {String|Network=} network - Which network should the address be for\n * @returns {Address} An address generated from the public key\n */\nPublicKey.prototype.toAddress = function(network) {\n  var Address = require('./address');\n  return Address.fromPublicKey(this, network || this.network);\n};\n\n/**\n * Will output the PublicKey to a DER encoded hex string\n *\n * @returns {string} A DER hex encoded string\n */\nPublicKey.prototype.toString = function() {\n  return this.toDER().toString('hex');\n};\n\n/**\n * Will return a string formatted for the console\n *\n * @returns {string} Public key\n */\nPublicKey.prototype.inspect = function() {\n  return '<PublicKey: ' + this.toString() +\n    (this.compressed ? '' : ', uncompressed') + '>';\n};\n\n\nmodule.exports = PublicKey;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}