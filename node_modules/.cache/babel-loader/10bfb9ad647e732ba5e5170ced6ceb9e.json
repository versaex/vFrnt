{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.bottom = bottom;\nexports.cloneLayout = cloneLayout;\nexports.cloneLayoutItem = cloneLayoutItem;\nexports.childrenEqual = childrenEqual;\nexports.fastPositionEqual = fastPositionEqual;\nexports.collides = collides;\nexports.compact = compact;\nexports.compactItem = compactItem;\nexports.correctBounds = correctBounds;\nexports.getLayoutItem = getLayoutItem;\nexports.getFirstCollision = getFirstCollision;\nexports.getAllCollisions = getAllCollisions;\nexports.getStatics = getStatics;\nexports.moveElement = moveElement;\nexports.moveElementAwayFromCollision = moveElementAwayFromCollision;\nexports.perc = perc;\nexports.setTransform = setTransform;\nexports.setTopLeft = setTopLeft;\nexports.sortLayoutItems = sortLayoutItems;\nexports.sortLayoutItemsByRowCol = sortLayoutItemsByRowCol;\nexports.sortLayoutItemsByColRow = sortLayoutItemsByColRow;\nexports.synchronizeLayoutWithChildren = synchronizeLayoutWithChildren;\nexports.validateLayout = validateLayout;\nexports.compactType = compactType;\nexports.autoBindHandlers = autoBindHandlers;\nexports.noop = exports.fastRGLPropsEqual = void 0;\nvar _lodash = _interopRequireDefault(require(\"lodash.isequal\"));\nvar _react = _interopRequireDefault(require(\"react\"));\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nvar isProduction = process.env.NODE_ENV === \"production\";\nvar DEBUG = false;\n/**\n * Return the bottom coordinate of the layout.\n *\n * @param  {Array} layout Layout array.\n * @return {Number}       Bottom coordinate.\n */\n\nfunction bottom(layout\n/*: Layout*/) /*: number*/\n{\n  var max = 0,\n    bottomY;\n  for (var i = 0, len = layout.length; i < len; i++) {\n    bottomY = layout[i].y + layout[i].h;\n    if (bottomY > max) max = bottomY;\n  }\n  return max;\n}\nfunction cloneLayout(layout\n/*: Layout*/) /*: Layout*/\n{\n  var newLayout = Array(layout.length);\n  for (var i = 0, len = layout.length; i < len; i++) {\n    newLayout[i] = cloneLayoutItem(layout[i]);\n  }\n  return newLayout;\n} // Fast path to cloning, since this is monomorphic\n\nfunction cloneLayoutItem(layoutItem\n/*: LayoutItem*/) /*: LayoutItem*/\n{\n  return {\n    w: layoutItem.w,\n    h: layoutItem.h,\n    x: layoutItem.x,\n    y: layoutItem.y,\n    i: layoutItem.i,\n    minW: layoutItem.minW,\n    maxW: layoutItem.maxW,\n    minH: layoutItem.minH,\n    maxH: layoutItem.maxH,\n    moved: Boolean(layoutItem.moved),\n    static: Boolean(layoutItem.static),\n    // These can be null\n    isDraggable: layoutItem.isDraggable,\n    isResizable: layoutItem.isResizable\n  };\n}\n/**\n * Comparing React `children` is a bit difficult. This is a good way to compare them.\n * This will catch differences in keys, order, and length.\n */\n\nfunction childrenEqual(a\n/*: ReactChildren*/, b\n/*: ReactChildren*/) /*: boolean*/\n{\n  return (0, _lodash.default)(_react.default.Children.map(a, function (c) {\n    return c.key;\n  }), _react.default.Children.map(b, function (c) {\n    return c.key;\n  }));\n}\n/**\n * See `fastRGLPropsEqual.js`.\n * We want this to run as fast as possible - it is called often - and to be\n * resilient to new props that we add. So rather than call lodash.isEqual,\n * which isn't suited to comparing props very well, we use this specialized\n * function in conjunction with preval to generate the fastest possible comparison\n * function, tuned for exactly our props.\n */\n\n/*:: type FastRGLPropsEqual = (Object, Object, Function) => boolean;*/\n\nvar fastRGLPropsEqual\n/*: FastRGLPropsEqual*/ = require(\"./fastRGLPropsEqual\"); // Like the above, but a lot simpler.\n\nexports.fastRGLPropsEqual = fastRGLPropsEqual;\nfunction fastPositionEqual(a\n/*: Position*/, b\n/*: Position*/) {\n  return a.left === b.left && a.top === b.top && a.width === b.width && a.height === b.height;\n}\n/**\n * Given two layoutitems, check if they collide.\n */\n\nfunction collides(l1\n/*: LayoutItem*/, l2\n/*: LayoutItem*/) /*: boolean*/\n{\n  if (l1.i === l2.i) return false; // same element\n\n  if (l1.x + l1.w <= l2.x) return false; // l1 is left of l2\n\n  if (l1.x >= l2.x + l2.w) return false; // l1 is right of l2\n\n  if (l1.y + l1.h <= l2.y) return false; // l1 is above l2\n\n  if (l1.y >= l2.y + l2.h) return false; // l1 is below l2\n\n  return true; // boxes overlap\n}\n/**\n * Given a layout, compact it. This involves going down each y coordinate and removing gaps\n * between items.\n *\n * Does not modify layout items (clones). Creates a new layout array.\n *\n * @param  {Array} layout Layout.\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\n *   vertically.\n * @return {Array}       Compacted Layout.\n */\n\nfunction compact(layout\n/*: Layout*/, compactType\n/*: CompactType*/, cols\n/*: number*/) /*: Layout*/\n{\n  // Statics go in the compareWith array right away so items flow around them.\n  var compareWith = getStatics(layout); // We go through the items by row and column.\n\n  var sorted = sortLayoutItems(layout, compactType); // Holding for new items.\n\n  var out = Array(layout.length);\n  for (var i = 0, len = sorted.length; i < len; i++) {\n    var l = cloneLayoutItem(sorted[i]); // Don't move static elements\n\n    if (!l.static) {\n      l = compactItem(compareWith, l, compactType, cols, sorted); // Add to comparison array. We only collide with items before this one.\n      // Statics are already in this array.\n\n      compareWith.push(l);\n    } // Add to output array to make sure they still come out in the right order.\n\n    out[layout.indexOf(sorted[i])] = l; // Clear moved flag, if it exists.\n\n    l.moved = false;\n  }\n  return out;\n}\nvar heightWidth = {\n  x: \"w\",\n  y: \"h\"\n};\n/**\n * Before moving item down, it will check if the movement will cause collisions and move those items down before.\n */\n\nfunction resolveCompactionCollision(layout\n/*: Layout*/, item\n/*: LayoutItem*/, moveToCoord\n/*: number*/, axis\n/*: \"x\" | \"y\"*/) {\n  var sizeProp = heightWidth[axis];\n  item[axis] += 1;\n  var itemIndex = layout.map(function (layoutItem) {\n    return layoutItem.i;\n  }).indexOf(item.i); // Go through each item we collide with.\n\n  for (var i = itemIndex + 1; i < layout.length; i++) {\n    var otherItem = layout[i]; // Ignore static items\n\n    if (otherItem.static) continue; // Optimization: we can break early if we know we're past this el\n    // We can do this b/c it's a sorted layout\n\n    if (otherItem.y > item.y + item.h) break;\n    if (collides(item, otherItem)) {\n      resolveCompactionCollision(layout, otherItem, moveToCoord + item[sizeProp], axis);\n    }\n  }\n  item[axis] = moveToCoord;\n}\n/**\n * Compact an item in the layout.\n *\n * Modifies item.\n *\n */\n\nfunction compactItem(compareWith\n/*: Layout*/, l\n/*: LayoutItem*/, compactType\n/*: CompactType*/, cols\n/*: number*/, fullLayout\n/*: Layout*/) /*: LayoutItem*/\n{\n  var compactV = compactType === \"vertical\";\n  var compactH = compactType === \"horizontal\";\n  if (compactV) {\n    // Bottom 'y' possible is the bottom of the layout.\n    // This allows you to do nice stuff like specify {y: Infinity}\n    // This is here because the layout must be sorted in order to get the correct bottom `y`.\n    l.y = Math.min(bottom(compareWith), l.y); // Move the element up as far as it can go without colliding.\n\n    while (l.y > 0 && !getFirstCollision(compareWith, l)) {\n      l.y--;\n    }\n  } else if (compactH) {\n    l.y = Math.min(bottom(compareWith), l.y); // Move the element left as far as it can go without colliding.\n\n    while (l.x > 0 && !getFirstCollision(compareWith, l)) {\n      l.x--;\n    }\n  } // Move it down, and keep moving it down if it's colliding.\n\n  var collides;\n  while (collides = getFirstCollision(compareWith, l)) {\n    if (compactH) {\n      resolveCompactionCollision(fullLayout, l, collides.x + collides.w, \"x\");\n    } else {\n      resolveCompactionCollision(fullLayout, l, collides.y + collides.h, \"y\");\n    } // Since we can't grow without bounds horizontally, if we've overflown, let's move it down and try again.\n\n    if (compactH && l.x + l.w > cols) {\n      l.x = cols - l.w;\n      l.y++;\n    }\n  }\n  return l;\n}\n/**\n * Given a layout, make sure all elements fit within its bounds.\n *\n * Modifies layout items.\n *\n * @param  {Array} layout Layout array.\n * @param  {Number} bounds Number of columns.\n */\n\nfunction correctBounds(layout\n/*: Layout*/, bounds\n/*: { cols: number }*/) /*: Layout*/\n{\n  var collidesWith = getStatics(layout);\n  for (var i = 0, len = layout.length; i < len; i++) {\n    var l = layout[i]; // Overflows right\n\n    if (l.x + l.w > bounds.cols) l.x = bounds.cols - l.w; // Overflows left\n\n    if (l.x < 0) {\n      l.x = 0;\n      l.w = bounds.cols;\n    }\n    if (!l.static) collidesWith.push(l);else {\n      // If this is static and collides with other statics, we must move it down.\n      // We have to do something nicer than just letting them overlap.\n      while (getFirstCollision(collidesWith, l)) {\n        l.y++;\n      }\n    }\n  }\n  return layout;\n}\n/**\n * Get a layout item by ID. Used so we can override later on if necessary.\n *\n * @param  {Array}  layout Layout array.\n * @param  {String} id     ID\n * @return {LayoutItem}    Item at ID.\n */\n\nfunction getLayoutItem(layout\n/*: Layout*/, id\n/*: string*/) /*: ?LayoutItem*/\n{\n  for (var i = 0, len = layout.length; i < len; i++) {\n    if (layout[i].i === id) return layout[i];\n  }\n}\n/**\n * Returns the first item this layout collides with.\n * It doesn't appear to matter which order we approach this from, although\n * perhaps that is the wrong thing to do.\n *\n * @param  {Object} layoutItem Layout item.\n * @return {Object|undefined}  A colliding layout item, or undefined.\n */\n\nfunction getFirstCollision(layout\n/*: Layout*/, layoutItem\n/*: LayoutItem*/) /*: ?LayoutItem*/\n{\n  for (var i = 0, len = layout.length; i < len; i++) {\n    if (collides(layout[i], layoutItem)) return layout[i];\n  }\n}\nfunction getAllCollisions(layout\n/*: Layout*/, layoutItem\n/*: LayoutItem*/) /*: Array<LayoutItem>*/\n{\n  return layout.filter(function (l) {\n    return collides(l, layoutItem);\n  });\n}\n/**\n * Get all static elements.\n * @param  {Array} layout Array of layout objects.\n * @return {Array}        Array of static layout items..\n */\n\nfunction getStatics(layout\n/*: Layout*/) /*: Array<LayoutItem>*/\n{\n  return layout.filter(function (l) {\n    return l.static;\n  });\n}\n/**\n * Move an element. Responsible for doing cascading movements of other elements.\n *\n * Modifies layout items.\n *\n * @param  {Array}      layout            Full layout to modify.\n * @param  {LayoutItem} l                 element to move.\n * @param  {Number}     [x]               X position in grid units.\n * @param  {Number}     [y]               Y position in grid units.\n */\n\nfunction moveElement(layout\n/*: Layout*/, l\n/*: LayoutItem*/, x\n/*: ?number*/, y\n/*: ?number*/, isUserAction\n/*: ?boolean*/, preventCollision\n/*: ?boolean*/, compactType\n/*: CompactType*/, cols\n/*: number*/) /*: Layout*/\n{\n  // If this is static and not explicitly enabled as draggable,\n  // no move is possible, so we can short-circuit this immediately.\n  if (l.static && l.isDraggable !== true) return layout; // Short-circuit if nothing to do.\n\n  if (l.y === y && l.x === x) return layout;\n  log(\"Moving element \".concat(l.i, \" to [\").concat(String(x), \",\").concat(String(y), \"] from [\").concat(l.x, \",\").concat(l.y, \"]\"));\n  var oldX = l.x;\n  var oldY = l.y; // This is quite a bit faster than extending the object\n\n  if (typeof x === \"number\") l.x = x;\n  if (typeof y === \"number\") l.y = y;\n  l.moved = true; // If this collides with anything, move it.\n  // When doing this comparison, we have to sort the items we compare with\n  // to ensure, in the case of multiple collisions, that we're getting the\n  // nearest collision.\n\n  var sorted = sortLayoutItems(layout, compactType);\n  var movingUp = compactType === \"vertical\" && typeof y === \"number\" ? oldY >= y : compactType === \"horizontal\" && typeof x === \"number\" ? oldX >= x : false; // $FlowIgnore acceptable modification of read-only array as it was recently cloned\n\n  if (movingUp) sorted = sorted.reverse();\n  var collisions = getAllCollisions(sorted, l); // There was a collision; abort\n\n  if (preventCollision && collisions.length) {\n    log(\"Collision prevented on \".concat(l.i, \", reverting.\"));\n    l.x = oldX;\n    l.y = oldY;\n    l.moved = false;\n    return layout;\n  } // Move each item that collides away from this element.\n\n  for (var i = 0, len = collisions.length; i < len; i++) {\n    var collision = collisions[i];\n    log(\"Resolving collision between \".concat(l.i, \" at [\").concat(l.x, \",\").concat(l.y, \"] and \").concat(collision.i, \" at [\").concat(collision.x, \",\").concat(collision.y, \"]\")); // Short circuit so we can't infinite loop\n\n    if (collision.moved) continue; // Don't move static items - we have to move *this* element away\n\n    if (collision.static) {\n      layout = moveElementAwayFromCollision(layout, collision, l, isUserAction, compactType, cols);\n    } else {\n      layout = moveElementAwayFromCollision(layout, l, collision, isUserAction, compactType, cols);\n    }\n  }\n  return layout;\n}\n/**\n * This is where the magic needs to happen - given a collision, move an element away from the collision.\n * We attempt to move it up if there's room, otherwise it goes below.\n *\n * @param  {Array} layout            Full layout to modify.\n * @param  {LayoutItem} collidesWith Layout item we're colliding with.\n * @param  {LayoutItem} itemToMove   Layout item we're moving.\n */\n\nfunction moveElementAwayFromCollision(layout\n/*: Layout*/, collidesWith\n/*: LayoutItem*/, itemToMove\n/*: LayoutItem*/, isUserAction\n/*: ?boolean*/, compactType\n/*: CompactType*/, cols\n/*: number*/) /*: Layout*/\n{\n  var compactH = compactType === \"horizontal\"; // Compact vertically if not set to horizontal\n\n  var compactV = compactType !== \"horizontal\";\n  var preventCollision = collidesWith.static; // we're already colliding (not for static items)\n  // If there is enough space above the collision to put this element, move it there.\n  // We only do this on the main collision as this can get funky in cascades and cause\n  // unwanted swapping behavior.\n\n  if (isUserAction) {\n    // Reset isUserAction flag because we're not in the main collision anymore.\n    isUserAction = false; // Make a mock item so we don't modify the item here, only modify in moveElement.\n\n    var fakeItem\n    /*: LayoutItem*/ = {\n      x: compactH ? Math.max(collidesWith.x - itemToMove.w, 0) : itemToMove.x,\n      y: compactV ? Math.max(collidesWith.y - itemToMove.h, 0) : itemToMove.y,\n      w: itemToMove.w,\n      h: itemToMove.h,\n      i: \"-1\"\n    }; // No collision? If so, we can go up there; otherwise, we'll end up moving down as normal\n\n    if (!getFirstCollision(layout, fakeItem)) {\n      log(\"Doing reverse collision on \".concat(itemToMove.i, \" up to [\").concat(fakeItem.x, \",\").concat(fakeItem.y, \"].\"));\n      return moveElement(layout, itemToMove, compactH ? fakeItem.x : undefined, compactV ? fakeItem.y : undefined, isUserAction, preventCollision, compactType, cols);\n    }\n  }\n  return moveElement(layout, itemToMove, compactH ? itemToMove.x + 1 : undefined, compactV ? itemToMove.y + 1 : undefined, isUserAction, preventCollision, compactType, cols);\n}\n/**\n * Helper to convert a number to a percentage string.\n *\n * @param  {Number} num Any number\n * @return {String}     That number as a percentage.\n */\n\nfunction perc(num\n/*: number*/) /*: string*/\n{\n  return num * 100 + \"%\";\n}\nfunction setTransform(_ref) /*: Object*/\n{\n  var top = _ref.top,\n    left = _ref.left,\n    width = _ref.width,\n    height = _ref.height;\n  // Replace unitless items with px\n  var translate = \"translate(\".concat(left, \"px,\").concat(top, \"px)\");\n  return {\n    transform: translate,\n    WebkitTransform: translate,\n    MozTransform: translate,\n    msTransform: translate,\n    OTransform: translate,\n    width: \"\".concat(width, \"px\"),\n    height: \"\".concat(height, \"px\"),\n    position: \"absolute\"\n  };\n}\nfunction setTopLeft(_ref2) /*: Object*/\n{\n  var top = _ref2.top,\n    left = _ref2.left,\n    width = _ref2.width,\n    height = _ref2.height;\n  return {\n    top: \"\".concat(top, \"px\"),\n    left: \"\".concat(left, \"px\"),\n    width: \"\".concat(width, \"px\"),\n    height: \"\".concat(height, \"px\"),\n    position: \"absolute\"\n  };\n}\n/**\n * Get layout items sorted from top left to right and down.\n *\n * @return {Array} Array of layout objects.\n * @return {Array}        Layout, sorted static items first.\n */\n\nfunction sortLayoutItems(layout\n/*: Layout*/, compactType\n/*: CompactType*/) /*: Layout*/\n{\n  if (compactType === \"horizontal\") return sortLayoutItemsByColRow(layout);else return sortLayoutItemsByRowCol(layout);\n}\n/**\n * Sort layout items by row ascending and column ascending.\n *\n * Does not modify Layout.\n */\n\nfunction sortLayoutItemsByRowCol(layout\n/*: Layout*/) /*: Layout*/\n{\n  // Slice to clone array as sort modifies\n  return layout.slice(0).sort(function (a, b) {\n    if (a.y > b.y || a.y === b.y && a.x > b.x) {\n      return 1;\n    } else if (a.y === b.y && a.x === b.x) {\n      // Without this, we can get different sort results in IE vs. Chrome/FF\n      return 0;\n    }\n    return -1;\n  });\n}\n/**\n * Sort layout items by column ascending then row ascending.\n *\n * Does not modify Layout.\n */\n\nfunction sortLayoutItemsByColRow(layout\n/*: Layout*/) /*: Layout*/\n{\n  return layout.slice(0).sort(function (a, b) {\n    if (a.x > b.x || a.x === b.x && a.y > b.y) {\n      return 1;\n    }\n    return -1;\n  });\n}\n/**\n * Generate a layout using the initialLayout and children as a template.\n * Missing entries will be added, extraneous ones will be truncated.\n *\n * Does not modify initialLayout.\n *\n * @param  {Array}  initialLayout Layout passed in through props.\n * @param  {String} breakpoint    Current responsive breakpoint.\n * @param  {?String} compact      Compaction option.\n * @return {Array}                Working layout.\n */\n\nfunction synchronizeLayoutWithChildren(initialLayout\n/*: Layout*/, children\n/*: ReactChildren*/, cols\n/*: number*/, compactType\n/*: CompactType*/) /*: Layout*/\n{\n  initialLayout = initialLayout || []; // Generate one layout item per child.\n\n  var layout\n  /*: LayoutItem[]*/ = [];\n  _react.default.Children.forEach(children, function (child\n  /*: ReactElement<any>*/, i\n  /*: number*/) {\n    // Don't overwrite if it already exists.\n    var exists = getLayoutItem(initialLayout, String(child.key));\n    if (exists) {\n      layout[i] = cloneLayoutItem(exists);\n    } else {\n      if (!isProduction && child.props._grid) {\n        console.warn(\"`_grid` properties on children have been deprecated as of React 15.2. \" +\n        // eslint-disable-line\n        \"Please use `data-grid` or add your properties directly to the `layout`.\");\n      }\n      var g = child.props[\"data-grid\"] || child.props._grid; // Hey, this item has a data-grid property, use it.\n\n      if (g) {\n        if (!isProduction) {\n          validateLayout([g], \"ReactGridLayout.children\");\n        }\n        layout[i] = cloneLayoutItem(_objectSpread({}, g, {\n          i: child.key\n        }));\n      } else {\n        // Nothing provided: ensure this is added to the bottom\n        layout[i] = cloneLayoutItem({\n          w: 1,\n          h: 1,\n          x: 0,\n          y: bottom(layout),\n          i: String(child.key)\n        });\n      }\n    }\n  }); // Correct the layout.\n\n  var correctedLayout = correctBounds(layout, {\n    cols: cols\n  });\n  return compact(correctedLayout, compactType, cols);\n}\n/**\n * Validate a layout. Throws errors.\n *\n * @param  {Array}  layout        Array of layout items.\n * @param  {String} [contextName] Context name for errors.\n * @throw  {Error}                Validation error.\n */\n\nfunction validateLayout(layout\n/*: Layout*/) /*: void*/\n{\n  var contextName\n  /*: string*/ = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"Layout\";\n  var subProps = [\"x\", \"y\", \"w\", \"h\"];\n  if (!Array.isArray(layout)) throw new Error(contextName + \" must be an array!\");\n  for (var i = 0, len = layout.length; i < len; i++) {\n    var item = layout[i];\n    for (var j = 0; j < subProps.length; j++) {\n      if (typeof item[subProps[j]] !== \"number\") {\n        throw new Error(\"ReactGridLayout: \" + contextName + \"[\" + i + \"].\" + subProps[j] + \" must be a number!\");\n      }\n    }\n    if (item.i && typeof item.i !== \"string\") {\n      throw new Error(\"ReactGridLayout: \" + contextName + \"[\" + i + \"].i must be a string!\");\n    }\n    if (item.static !== undefined && typeof item.static !== \"boolean\") {\n      throw new Error(\"ReactGridLayout: \" + contextName + \"[\" + i + \"].static must be a boolean!\");\n    }\n  }\n} // Legacy support for verticalCompact: false\n\nfunction compactType(props\n/*: ?{ verticalCompact: boolean, compactType: CompactType }*/) /*: CompactType*/\n{\n  var _ref3 = props || {},\n    verticalCompact = _ref3.verticalCompact,\n    compactType = _ref3.compactType;\n  return verticalCompact === false ? null : compactType;\n} // Flow can't really figure this out, so we just use Object\n\nfunction autoBindHandlers(el\n/*: Object*/, fns\n/*: Array<string>*/) /*: void*/\n{\n  fns.forEach(function (key) {\n    return el[key] = el[key].bind(el);\n  });\n}\nfunction log() {\n  var _console;\n  if (!DEBUG) return; // eslint-disable-next-line no-console\n\n  (_console = console).log.apply(_console, arguments);\n}\nvar noop = function noop() {};\nexports.noop = noop;","map":{"version":3,"names":["Object","defineProperty","exports","value","bottom","cloneLayout","cloneLayoutItem","childrenEqual","fastPositionEqual","collides","compact","compactItem","correctBounds","getLayoutItem","getFirstCollision","getAllCollisions","getStatics","moveElement","moveElementAwayFromCollision","perc","setTransform","setTopLeft","sortLayoutItems","sortLayoutItemsByRowCol","sortLayoutItemsByColRow","synchronizeLayoutWithChildren","validateLayout","compactType","autoBindHandlers","noop","fastRGLPropsEqual","_lodash","_interopRequireDefault","require","_react","obj","__esModule","default","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","i","arguments","length","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","configurable","writable","isProduction","process","env","NODE_ENV","DEBUG","layout","max","bottomY","len","y","h","newLayout","Array","layoutItem","w","x","minW","maxW","minH","maxH","moved","Boolean","static","isDraggable","isResizable","a","b","Children","map","c","left","top","width","height","l1","l2","cols","compareWith","sorted","out","l","indexOf","heightWidth","resolveCompactionCollision","item","moveToCoord","axis","sizeProp","itemIndex","otherItem","fullLayout","compactV","compactH","Math","min","bounds","collidesWith","id","isUserAction","preventCollision","log","concat","String","oldX","oldY","movingUp","reverse","collisions","collision","itemToMove","fakeItem","undefined","num","_ref","translate","transform","WebkitTransform","MozTransform","msTransform","OTransform","position","_ref2","slice","sort","initialLayout","children","child","exists","props","_grid","console","warn","g","correctedLayout","contextName","subProps","isArray","Error","j","_ref3","verticalCompact","el","fns","bind","_console"],"sources":["C:/Users/Elton/OneDrive/Desktop/baseapp-2024/node_modules/react-grid-layout/build/utils.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.bottom = bottom;\nexports.cloneLayout = cloneLayout;\nexports.cloneLayoutItem = cloneLayoutItem;\nexports.childrenEqual = childrenEqual;\nexports.fastPositionEqual = fastPositionEqual;\nexports.collides = collides;\nexports.compact = compact;\nexports.compactItem = compactItem;\nexports.correctBounds = correctBounds;\nexports.getLayoutItem = getLayoutItem;\nexports.getFirstCollision = getFirstCollision;\nexports.getAllCollisions = getAllCollisions;\nexports.getStatics = getStatics;\nexports.moveElement = moveElement;\nexports.moveElementAwayFromCollision = moveElementAwayFromCollision;\nexports.perc = perc;\nexports.setTransform = setTransform;\nexports.setTopLeft = setTopLeft;\nexports.sortLayoutItems = sortLayoutItems;\nexports.sortLayoutItemsByRowCol = sortLayoutItemsByRowCol;\nexports.sortLayoutItemsByColRow = sortLayoutItemsByColRow;\nexports.synchronizeLayoutWithChildren = synchronizeLayoutWithChildren;\nexports.validateLayout = validateLayout;\nexports.compactType = compactType;\nexports.autoBindHandlers = autoBindHandlers;\nexports.noop = exports.fastRGLPropsEqual = void 0;\n\nvar _lodash = _interopRequireDefault(require(\"lodash.isequal\"));\n\nvar _react = _interopRequireDefault(require(\"react\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nvar isProduction = process.env.NODE_ENV === \"production\";\nvar DEBUG = false;\n/**\n * Return the bottom coordinate of the layout.\n *\n * @param  {Array} layout Layout array.\n * @return {Number}       Bottom coordinate.\n */\n\nfunction bottom(layout\n/*: Layout*/\n)\n/*: number*/\n{\n  var max = 0,\n      bottomY;\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    bottomY = layout[i].y + layout[i].h;\n    if (bottomY > max) max = bottomY;\n  }\n\n  return max;\n}\n\nfunction cloneLayout(layout\n/*: Layout*/\n)\n/*: Layout*/\n{\n  var newLayout = Array(layout.length);\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    newLayout[i] = cloneLayoutItem(layout[i]);\n  }\n\n  return newLayout;\n} // Fast path to cloning, since this is monomorphic\n\n\nfunction cloneLayoutItem(layoutItem\n/*: LayoutItem*/\n)\n/*: LayoutItem*/\n{\n  return {\n    w: layoutItem.w,\n    h: layoutItem.h,\n    x: layoutItem.x,\n    y: layoutItem.y,\n    i: layoutItem.i,\n    minW: layoutItem.minW,\n    maxW: layoutItem.maxW,\n    minH: layoutItem.minH,\n    maxH: layoutItem.maxH,\n    moved: Boolean(layoutItem.moved),\n    static: Boolean(layoutItem.static),\n    // These can be null\n    isDraggable: layoutItem.isDraggable,\n    isResizable: layoutItem.isResizable\n  };\n}\n/**\n * Comparing React `children` is a bit difficult. This is a good way to compare them.\n * This will catch differences in keys, order, and length.\n */\n\n\nfunction childrenEqual(a\n/*: ReactChildren*/\n, b\n/*: ReactChildren*/\n)\n/*: boolean*/\n{\n  return (0, _lodash.default)(_react.default.Children.map(a, function (c) {\n    return c.key;\n  }), _react.default.Children.map(b, function (c) {\n    return c.key;\n  }));\n}\n/**\n * See `fastRGLPropsEqual.js`.\n * We want this to run as fast as possible - it is called often - and to be\n * resilient to new props that we add. So rather than call lodash.isEqual,\n * which isn't suited to comparing props very well, we use this specialized\n * function in conjunction with preval to generate the fastest possible comparison\n * function, tuned for exactly our props.\n */\n\n/*:: type FastRGLPropsEqual = (Object, Object, Function) => boolean;*/\n\n\nvar fastRGLPropsEqual\n/*: FastRGLPropsEqual*/\n= require(\"./fastRGLPropsEqual\"); // Like the above, but a lot simpler.\n\n\nexports.fastRGLPropsEqual = fastRGLPropsEqual;\n\nfunction fastPositionEqual(a\n/*: Position*/\n, b\n/*: Position*/\n) {\n  return a.left === b.left && a.top === b.top && a.width === b.width && a.height === b.height;\n}\n/**\n * Given two layoutitems, check if they collide.\n */\n\n\nfunction collides(l1\n/*: LayoutItem*/\n, l2\n/*: LayoutItem*/\n)\n/*: boolean*/\n{\n  if (l1.i === l2.i) return false; // same element\n\n  if (l1.x + l1.w <= l2.x) return false; // l1 is left of l2\n\n  if (l1.x >= l2.x + l2.w) return false; // l1 is right of l2\n\n  if (l1.y + l1.h <= l2.y) return false; // l1 is above l2\n\n  if (l1.y >= l2.y + l2.h) return false; // l1 is below l2\n\n  return true; // boxes overlap\n}\n/**\n * Given a layout, compact it. This involves going down each y coordinate and removing gaps\n * between items.\n *\n * Does not modify layout items (clones). Creates a new layout array.\n *\n * @param  {Array} layout Layout.\n * @param  {Boolean} verticalCompact Whether or not to compact the layout\n *   vertically.\n * @return {Array}       Compacted Layout.\n */\n\n\nfunction compact(layout\n/*: Layout*/\n, compactType\n/*: CompactType*/\n, cols\n/*: number*/\n)\n/*: Layout*/\n{\n  // Statics go in the compareWith array right away so items flow around them.\n  var compareWith = getStatics(layout); // We go through the items by row and column.\n\n  var sorted = sortLayoutItems(layout, compactType); // Holding for new items.\n\n  var out = Array(layout.length);\n\n  for (var i = 0, len = sorted.length; i < len; i++) {\n    var l = cloneLayoutItem(sorted[i]); // Don't move static elements\n\n    if (!l.static) {\n      l = compactItem(compareWith, l, compactType, cols, sorted); // Add to comparison array. We only collide with items before this one.\n      // Statics are already in this array.\n\n      compareWith.push(l);\n    } // Add to output array to make sure they still come out in the right order.\n\n\n    out[layout.indexOf(sorted[i])] = l; // Clear moved flag, if it exists.\n\n    l.moved = false;\n  }\n\n  return out;\n}\n\nvar heightWidth = {\n  x: \"w\",\n  y: \"h\"\n};\n/**\n * Before moving item down, it will check if the movement will cause collisions and move those items down before.\n */\n\nfunction resolveCompactionCollision(layout\n/*: Layout*/\n, item\n/*: LayoutItem*/\n, moveToCoord\n/*: number*/\n, axis\n/*: \"x\" | \"y\"*/\n) {\n  var sizeProp = heightWidth[axis];\n  item[axis] += 1;\n  var itemIndex = layout.map(function (layoutItem) {\n    return layoutItem.i;\n  }).indexOf(item.i); // Go through each item we collide with.\n\n  for (var i = itemIndex + 1; i < layout.length; i++) {\n    var otherItem = layout[i]; // Ignore static items\n\n    if (otherItem.static) continue; // Optimization: we can break early if we know we're past this el\n    // We can do this b/c it's a sorted layout\n\n    if (otherItem.y > item.y + item.h) break;\n\n    if (collides(item, otherItem)) {\n      resolveCompactionCollision(layout, otherItem, moveToCoord + item[sizeProp], axis);\n    }\n  }\n\n  item[axis] = moveToCoord;\n}\n/**\n * Compact an item in the layout.\n *\n * Modifies item.\n *\n */\n\n\nfunction compactItem(compareWith\n/*: Layout*/\n, l\n/*: LayoutItem*/\n, compactType\n/*: CompactType*/\n, cols\n/*: number*/\n, fullLayout\n/*: Layout*/\n)\n/*: LayoutItem*/\n{\n  var compactV = compactType === \"vertical\";\n  var compactH = compactType === \"horizontal\";\n\n  if (compactV) {\n    // Bottom 'y' possible is the bottom of the layout.\n    // This allows you to do nice stuff like specify {y: Infinity}\n    // This is here because the layout must be sorted in order to get the correct bottom `y`.\n    l.y = Math.min(bottom(compareWith), l.y); // Move the element up as far as it can go without colliding.\n\n    while (l.y > 0 && !getFirstCollision(compareWith, l)) {\n      l.y--;\n    }\n  } else if (compactH) {\n    l.y = Math.min(bottom(compareWith), l.y); // Move the element left as far as it can go without colliding.\n\n    while (l.x > 0 && !getFirstCollision(compareWith, l)) {\n      l.x--;\n    }\n  } // Move it down, and keep moving it down if it's colliding.\n\n\n  var collides;\n\n  while (collides = getFirstCollision(compareWith, l)) {\n    if (compactH) {\n      resolveCompactionCollision(fullLayout, l, collides.x + collides.w, \"x\");\n    } else {\n      resolveCompactionCollision(fullLayout, l, collides.y + collides.h, \"y\");\n    } // Since we can't grow without bounds horizontally, if we've overflown, let's move it down and try again.\n\n\n    if (compactH && l.x + l.w > cols) {\n      l.x = cols - l.w;\n      l.y++;\n    }\n  }\n\n  return l;\n}\n/**\n * Given a layout, make sure all elements fit within its bounds.\n *\n * Modifies layout items.\n *\n * @param  {Array} layout Layout array.\n * @param  {Number} bounds Number of columns.\n */\n\n\nfunction correctBounds(layout\n/*: Layout*/\n, bounds\n/*: { cols: number }*/\n)\n/*: Layout*/\n{\n  var collidesWith = getStatics(layout);\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    var l = layout[i]; // Overflows right\n\n    if (l.x + l.w > bounds.cols) l.x = bounds.cols - l.w; // Overflows left\n\n    if (l.x < 0) {\n      l.x = 0;\n      l.w = bounds.cols;\n    }\n\n    if (!l.static) collidesWith.push(l);else {\n      // If this is static and collides with other statics, we must move it down.\n      // We have to do something nicer than just letting them overlap.\n      while (getFirstCollision(collidesWith, l)) {\n        l.y++;\n      }\n    }\n  }\n\n  return layout;\n}\n/**\n * Get a layout item by ID. Used so we can override later on if necessary.\n *\n * @param  {Array}  layout Layout array.\n * @param  {String} id     ID\n * @return {LayoutItem}    Item at ID.\n */\n\n\nfunction getLayoutItem(layout\n/*: Layout*/\n, id\n/*: string*/\n)\n/*: ?LayoutItem*/\n{\n  for (var i = 0, len = layout.length; i < len; i++) {\n    if (layout[i].i === id) return layout[i];\n  }\n}\n/**\n * Returns the first item this layout collides with.\n * It doesn't appear to matter which order we approach this from, although\n * perhaps that is the wrong thing to do.\n *\n * @param  {Object} layoutItem Layout item.\n * @return {Object|undefined}  A colliding layout item, or undefined.\n */\n\n\nfunction getFirstCollision(layout\n/*: Layout*/\n, layoutItem\n/*: LayoutItem*/\n)\n/*: ?LayoutItem*/\n{\n  for (var i = 0, len = layout.length; i < len; i++) {\n    if (collides(layout[i], layoutItem)) return layout[i];\n  }\n}\n\nfunction getAllCollisions(layout\n/*: Layout*/\n, layoutItem\n/*: LayoutItem*/\n)\n/*: Array<LayoutItem>*/\n{\n  return layout.filter(function (l) {\n    return collides(l, layoutItem);\n  });\n}\n/**\n * Get all static elements.\n * @param  {Array} layout Array of layout objects.\n * @return {Array}        Array of static layout items..\n */\n\n\nfunction getStatics(layout\n/*: Layout*/\n)\n/*: Array<LayoutItem>*/\n{\n  return layout.filter(function (l) {\n    return l.static;\n  });\n}\n/**\n * Move an element. Responsible for doing cascading movements of other elements.\n *\n * Modifies layout items.\n *\n * @param  {Array}      layout            Full layout to modify.\n * @param  {LayoutItem} l                 element to move.\n * @param  {Number}     [x]               X position in grid units.\n * @param  {Number}     [y]               Y position in grid units.\n */\n\n\nfunction moveElement(layout\n/*: Layout*/\n, l\n/*: LayoutItem*/\n, x\n/*: ?number*/\n, y\n/*: ?number*/\n, isUserAction\n/*: ?boolean*/\n, preventCollision\n/*: ?boolean*/\n, compactType\n/*: CompactType*/\n, cols\n/*: number*/\n)\n/*: Layout*/\n{\n  // If this is static and not explicitly enabled as draggable,\n  // no move is possible, so we can short-circuit this immediately.\n  if (l.static && l.isDraggable !== true) return layout; // Short-circuit if nothing to do.\n\n  if (l.y === y && l.x === x) return layout;\n  log(\"Moving element \".concat(l.i, \" to [\").concat(String(x), \",\").concat(String(y), \"] from [\").concat(l.x, \",\").concat(l.y, \"]\"));\n  var oldX = l.x;\n  var oldY = l.y; // This is quite a bit faster than extending the object\n\n  if (typeof x === \"number\") l.x = x;\n  if (typeof y === \"number\") l.y = y;\n  l.moved = true; // If this collides with anything, move it.\n  // When doing this comparison, we have to sort the items we compare with\n  // to ensure, in the case of multiple collisions, that we're getting the\n  // nearest collision.\n\n  var sorted = sortLayoutItems(layout, compactType);\n  var movingUp = compactType === \"vertical\" && typeof y === \"number\" ? oldY >= y : compactType === \"horizontal\" && typeof x === \"number\" ? oldX >= x : false; // $FlowIgnore acceptable modification of read-only array as it was recently cloned\n\n  if (movingUp) sorted = sorted.reverse();\n  var collisions = getAllCollisions(sorted, l); // There was a collision; abort\n\n  if (preventCollision && collisions.length) {\n    log(\"Collision prevented on \".concat(l.i, \", reverting.\"));\n    l.x = oldX;\n    l.y = oldY;\n    l.moved = false;\n    return layout;\n  } // Move each item that collides away from this element.\n\n\n  for (var i = 0, len = collisions.length; i < len; i++) {\n    var collision = collisions[i];\n    log(\"Resolving collision between \".concat(l.i, \" at [\").concat(l.x, \",\").concat(l.y, \"] and \").concat(collision.i, \" at [\").concat(collision.x, \",\").concat(collision.y, \"]\")); // Short circuit so we can't infinite loop\n\n    if (collision.moved) continue; // Don't move static items - we have to move *this* element away\n\n    if (collision.static) {\n      layout = moveElementAwayFromCollision(layout, collision, l, isUserAction, compactType, cols);\n    } else {\n      layout = moveElementAwayFromCollision(layout, l, collision, isUserAction, compactType, cols);\n    }\n  }\n\n  return layout;\n}\n/**\n * This is where the magic needs to happen - given a collision, move an element away from the collision.\n * We attempt to move it up if there's room, otherwise it goes below.\n *\n * @param  {Array} layout            Full layout to modify.\n * @param  {LayoutItem} collidesWith Layout item we're colliding with.\n * @param  {LayoutItem} itemToMove   Layout item we're moving.\n */\n\n\nfunction moveElementAwayFromCollision(layout\n/*: Layout*/\n, collidesWith\n/*: LayoutItem*/\n, itemToMove\n/*: LayoutItem*/\n, isUserAction\n/*: ?boolean*/\n, compactType\n/*: CompactType*/\n, cols\n/*: number*/\n)\n/*: Layout*/\n{\n  var compactH = compactType === \"horizontal\"; // Compact vertically if not set to horizontal\n\n  var compactV = compactType !== \"horizontal\";\n  var preventCollision = collidesWith.static; // we're already colliding (not for static items)\n  // If there is enough space above the collision to put this element, move it there.\n  // We only do this on the main collision as this can get funky in cascades and cause\n  // unwanted swapping behavior.\n\n  if (isUserAction) {\n    // Reset isUserAction flag because we're not in the main collision anymore.\n    isUserAction = false; // Make a mock item so we don't modify the item here, only modify in moveElement.\n\n    var fakeItem\n    /*: LayoutItem*/\n    = {\n      x: compactH ? Math.max(collidesWith.x - itemToMove.w, 0) : itemToMove.x,\n      y: compactV ? Math.max(collidesWith.y - itemToMove.h, 0) : itemToMove.y,\n      w: itemToMove.w,\n      h: itemToMove.h,\n      i: \"-1\"\n    }; // No collision? If so, we can go up there; otherwise, we'll end up moving down as normal\n\n    if (!getFirstCollision(layout, fakeItem)) {\n      log(\"Doing reverse collision on \".concat(itemToMove.i, \" up to [\").concat(fakeItem.x, \",\").concat(fakeItem.y, \"].\"));\n      return moveElement(layout, itemToMove, compactH ? fakeItem.x : undefined, compactV ? fakeItem.y : undefined, isUserAction, preventCollision, compactType, cols);\n    }\n  }\n\n  return moveElement(layout, itemToMove, compactH ? itemToMove.x + 1 : undefined, compactV ? itemToMove.y + 1 : undefined, isUserAction, preventCollision, compactType, cols);\n}\n/**\n * Helper to convert a number to a percentage string.\n *\n * @param  {Number} num Any number\n * @return {String}     That number as a percentage.\n */\n\n\nfunction perc(num\n/*: number*/\n)\n/*: string*/\n{\n  return num * 100 + \"%\";\n}\n\nfunction setTransform(_ref)\n/*: Object*/\n{\n  var top = _ref.top,\n      left = _ref.left,\n      width = _ref.width,\n      height = _ref.height;\n  // Replace unitless items with px\n  var translate = \"translate(\".concat(left, \"px,\").concat(top, \"px)\");\n  return {\n    transform: translate,\n    WebkitTransform: translate,\n    MozTransform: translate,\n    msTransform: translate,\n    OTransform: translate,\n    width: \"\".concat(width, \"px\"),\n    height: \"\".concat(height, \"px\"),\n    position: \"absolute\"\n  };\n}\n\nfunction setTopLeft(_ref2)\n/*: Object*/\n{\n  var top = _ref2.top,\n      left = _ref2.left,\n      width = _ref2.width,\n      height = _ref2.height;\n  return {\n    top: \"\".concat(top, \"px\"),\n    left: \"\".concat(left, \"px\"),\n    width: \"\".concat(width, \"px\"),\n    height: \"\".concat(height, \"px\"),\n    position: \"absolute\"\n  };\n}\n/**\n * Get layout items sorted from top left to right and down.\n *\n * @return {Array} Array of layout objects.\n * @return {Array}        Layout, sorted static items first.\n */\n\n\nfunction sortLayoutItems(layout\n/*: Layout*/\n, compactType\n/*: CompactType*/\n)\n/*: Layout*/\n{\n  if (compactType === \"horizontal\") return sortLayoutItemsByColRow(layout);else return sortLayoutItemsByRowCol(layout);\n}\n/**\n * Sort layout items by row ascending and column ascending.\n *\n * Does not modify Layout.\n */\n\n\nfunction sortLayoutItemsByRowCol(layout\n/*: Layout*/\n)\n/*: Layout*/\n{\n  // Slice to clone array as sort modifies\n  return layout.slice(0).sort(function (a, b) {\n    if (a.y > b.y || a.y === b.y && a.x > b.x) {\n      return 1;\n    } else if (a.y === b.y && a.x === b.x) {\n      // Without this, we can get different sort results in IE vs. Chrome/FF\n      return 0;\n    }\n\n    return -1;\n  });\n}\n/**\n * Sort layout items by column ascending then row ascending.\n *\n * Does not modify Layout.\n */\n\n\nfunction sortLayoutItemsByColRow(layout\n/*: Layout*/\n)\n/*: Layout*/\n{\n  return layout.slice(0).sort(function (a, b) {\n    if (a.x > b.x || a.x === b.x && a.y > b.y) {\n      return 1;\n    }\n\n    return -1;\n  });\n}\n/**\n * Generate a layout using the initialLayout and children as a template.\n * Missing entries will be added, extraneous ones will be truncated.\n *\n * Does not modify initialLayout.\n *\n * @param  {Array}  initialLayout Layout passed in through props.\n * @param  {String} breakpoint    Current responsive breakpoint.\n * @param  {?String} compact      Compaction option.\n * @return {Array}                Working layout.\n */\n\n\nfunction synchronizeLayoutWithChildren(initialLayout\n/*: Layout*/\n, children\n/*: ReactChildren*/\n, cols\n/*: number*/\n, compactType\n/*: CompactType*/\n)\n/*: Layout*/\n{\n  initialLayout = initialLayout || []; // Generate one layout item per child.\n\n  var layout\n  /*: LayoutItem[]*/\n  = [];\n\n  _react.default.Children.forEach(children, function (child\n  /*: ReactElement<any>*/\n  , i\n  /*: number*/\n  ) {\n    // Don't overwrite if it already exists.\n    var exists = getLayoutItem(initialLayout, String(child.key));\n\n    if (exists) {\n      layout[i] = cloneLayoutItem(exists);\n    } else {\n      if (!isProduction && child.props._grid) {\n        console.warn(\"`_grid` properties on children have been deprecated as of React 15.2. \" + // eslint-disable-line\n        \"Please use `data-grid` or add your properties directly to the `layout`.\");\n      }\n\n      var g = child.props[\"data-grid\"] || child.props._grid; // Hey, this item has a data-grid property, use it.\n\n      if (g) {\n        if (!isProduction) {\n          validateLayout([g], \"ReactGridLayout.children\");\n        }\n\n        layout[i] = cloneLayoutItem(_objectSpread({}, g, {\n          i: child.key\n        }));\n      } else {\n        // Nothing provided: ensure this is added to the bottom\n        layout[i] = cloneLayoutItem({\n          w: 1,\n          h: 1,\n          x: 0,\n          y: bottom(layout),\n          i: String(child.key)\n        });\n      }\n    }\n  }); // Correct the layout.\n\n\n  var correctedLayout = correctBounds(layout, {\n    cols: cols\n  });\n  return compact(correctedLayout, compactType, cols);\n}\n/**\n * Validate a layout. Throws errors.\n *\n * @param  {Array}  layout        Array of layout items.\n * @param  {String} [contextName] Context name for errors.\n * @throw  {Error}                Validation error.\n */\n\n\nfunction validateLayout(layout\n/*: Layout*/\n)\n/*: void*/\n{\n  var contextName\n  /*: string*/\n  = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"Layout\";\n  var subProps = [\"x\", \"y\", \"w\", \"h\"];\n  if (!Array.isArray(layout)) throw new Error(contextName + \" must be an array!\");\n\n  for (var i = 0, len = layout.length; i < len; i++) {\n    var item = layout[i];\n\n    for (var j = 0; j < subProps.length; j++) {\n      if (typeof item[subProps[j]] !== \"number\") {\n        throw new Error(\"ReactGridLayout: \" + contextName + \"[\" + i + \"].\" + subProps[j] + \" must be a number!\");\n      }\n    }\n\n    if (item.i && typeof item.i !== \"string\") {\n      throw new Error(\"ReactGridLayout: \" + contextName + \"[\" + i + \"].i must be a string!\");\n    }\n\n    if (item.static !== undefined && typeof item.static !== \"boolean\") {\n      throw new Error(\"ReactGridLayout: \" + contextName + \"[\" + i + \"].static must be a boolean!\");\n    }\n  }\n} // Legacy support for verticalCompact: false\n\n\nfunction compactType(props\n/*: ?{ verticalCompact: boolean, compactType: CompactType }*/\n)\n/*: CompactType*/\n{\n  var _ref3 = props || {},\n      verticalCompact = _ref3.verticalCompact,\n      compactType = _ref3.compactType;\n\n  return verticalCompact === false ? null : compactType;\n} // Flow can't really figure this out, so we just use Object\n\n\nfunction autoBindHandlers(el\n/*: Object*/\n, fns\n/*: Array<string>*/\n)\n/*: void*/\n{\n  fns.forEach(function (key) {\n    return el[key] = el[key].bind(el);\n  });\n}\n\nfunction log() {\n  var _console;\n\n  if (!DEBUG) return; // eslint-disable-next-line no-console\n\n  (_console = console).log.apply(_console, arguments);\n}\n\nvar noop = function noop() {};\n\nexports.noop = noop;"],"mappings":"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"},"metadata":{},"sourceType":"script"}