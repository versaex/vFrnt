{"ast":null,"code":"'use strict';\n\nvar assert = require('assert');\nvar buffer = require('buffer');\nvar _ = require('lodash');\nvar $ = require('./util/preconditions');\nvar BN = require('./crypto/bn');\nvar Base58 = require('./encoding/base58');\nvar Base58Check = require('./encoding/base58check');\nvar Hash = require('./crypto/hash');\nvar Network = require('./networks');\nvar Point = require('./crypto/point');\nvar PrivateKey = require('./privatekey');\nvar Random = require('./crypto/random');\nvar errors = require('./errors');\nvar hdErrors = errors.HDPrivateKey;\nvar BufferUtil = require('./util/buffer');\nvar JSUtil = require('./util/js');\nvar MINIMUM_ENTROPY_BITS = 128;\nvar BITS_TO_BYTES = 1 / 8;\nvar MAXIMUM_ENTROPY_BITS = 512;\n\n/**\n * Represents an instance of an hierarchically derived private key.\n *\n * More info on https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\n *\n * @constructor\n * @param {string|Buffer|Object} arg\n */\nfunction HDPrivateKey(arg) {\n  /* jshint maxcomplexity: 10 */\n  if (arg instanceof HDPrivateKey) {\n    return arg;\n  }\n  if (!(this instanceof HDPrivateKey)) {\n    return new HDPrivateKey(arg);\n  }\n  if (!arg) {\n    return this._generateRandomly();\n  }\n  if (Network.get(arg)) {\n    return this._generateRandomly(arg);\n  } else if (_.isString(arg) || BufferUtil.isBuffer(arg)) {\n    if (HDPrivateKey.isValidSerialized(arg)) {\n      this._buildFromSerialized(arg);\n    } else if (JSUtil.isValidJSON(arg)) {\n      this._buildFromJSON(arg);\n    } else if (BufferUtil.isBuffer(arg) && HDPrivateKey.isValidSerialized(arg.toString())) {\n      this._buildFromSerialized(arg.toString());\n    } else {\n      throw HDPrivateKey.getSerializedError(arg);\n    }\n  } else if (_.isObject(arg)) {\n    this._buildFromObject(arg);\n  } else {\n    throw new hdErrors.UnrecognizedArgument(arg);\n  }\n}\n\n/**\n * Verifies that a given path is valid.\n *\n * @param {string|number} arg\n * @param {boolean?} hardened\n * @return {boolean}\n */\nHDPrivateKey.isValidPath = function (arg, hardened) {\n  if (_.isString(arg)) {\n    var indexes = HDPrivateKey._getDerivationIndexes(arg);\n    return indexes !== null && _.every(indexes, HDPrivateKey.isValidPath);\n  }\n  if (_.isNumber(arg)) {\n    if (arg < HDPrivateKey.Hardened && hardened === true) {\n      arg += HDPrivateKey.Hardened;\n    }\n    return arg >= 0 && arg < HDPrivateKey.MaxIndex;\n  }\n  return false;\n};\n\n/**\n * Internal function that splits a string path into a derivation index array.\n * It will return null if the string path is malformed.\n * It does not validate if indexes are in bounds.\n *\n * @param {string} path\n * @return {Array}\n */\nHDPrivateKey._getDerivationIndexes = function (path) {\n  var steps = path.split('/');\n\n  // Special cases:\n  if (_.includes(HDPrivateKey.RootElementAlias, path)) {\n    return [];\n  }\n  if (!_.includes(HDPrivateKey.RootElementAlias, steps[0])) {\n    return null;\n  }\n  var indexes = steps.slice(1).map(function (step) {\n    var isHardened = step.slice(-1) === '\\'';\n    if (isHardened) {\n      step = step.slice(0, -1);\n    }\n    if (!step || step[0] === '-') {\n      return NaN;\n    }\n    var index = +step; // cast to number\n    if (isHardened) {\n      index += HDPrivateKey.Hardened;\n    }\n    return index;\n  });\n  return _.some(indexes, isNaN) ? null : indexes;\n};\n\n/**\n * WARNING: This method is deprecated. Use deriveChild or deriveNonCompliantChild instead. This is not BIP32 compliant\n *\n *\n * Get a derived child based on a string or number.\n *\n * If the first argument is a string, it's parsed as the full path of\n * derivation. Valid values for this argument include \"m\" (which returns the\n * same private key), \"m/0/1/40/2'/1000\", where the ' quote means a hardened\n * derivation.\n *\n * If the first argument is a number, the child with that index will be\n * derived. If the second argument is truthy, the hardened version will be\n * derived. See the example usage for clarification.\n *\n * @example\n * ```javascript\n * var parent = new HDPrivateKey('xprv...');\n * var child_0_1_2h = parent.derive(0).derive(1).derive(2, true);\n * var copy_of_child_0_1_2h = parent.derive(\"m/0/1/2'\");\n * assert(child_0_1_2h.xprivkey === copy_of_child_0_1_2h);\n * ```\n *\n * @param {string|number} arg\n * @param {boolean?} hardened\n */\nHDPrivateKey.prototype.derive = function (arg, hardened) {\n  return this.deriveNonCompliantChild(arg, hardened);\n};\n\n/**\n * WARNING: This method will not be officially supported until v1.0.0.\n *\n *\n * Get a derived child based on a string or number.\n *\n * If the first argument is a string, it's parsed as the full path of\n * derivation. Valid values for this argument include \"m\" (which returns the\n * same private key), \"m/0/1/40/2'/1000\", where the ' quote means a hardened\n * derivation.\n *\n * If the first argument is a number, the child with that index will be\n * derived. If the second argument is truthy, the hardened version will be\n * derived. See the example usage for clarification.\n *\n * WARNING: The `nonCompliant` option should NOT be used, except for older implementation\n * that used a derivation strategy that used a non-zero padded private key.\n *\n * @example\n * ```javascript\n * var parent = new HDPrivateKey('xprv...');\n * var child_0_1_2h = parent.deriveChild(0).deriveChild(1).deriveChild(2, true);\n * var copy_of_child_0_1_2h = parent.deriveChild(\"m/0/1/2'\");\n * assert(child_0_1_2h.xprivkey === copy_of_child_0_1_2h);\n * ```\n *\n * @param {string|number} arg\n * @param {boolean?} hardened\n */\nHDPrivateKey.prototype.deriveChild = function (arg, hardened) {\n  if (_.isNumber(arg)) {\n    return this._deriveWithNumber(arg, hardened);\n  } else if (_.isString(arg)) {\n    return this._deriveFromString(arg);\n  } else {\n    throw new hdErrors.InvalidDerivationArgument(arg);\n  }\n};\n\n/**\n * WARNING: This method will not be officially supported until v1.0.0\n *\n *\n * WARNING: If this is a new implementation you should NOT use this method, you should be using\n * `derive` instead.\n *\n * This method is explicitly for use and compatibility with an implementation that\n * was not compliant with BIP32 regarding the derivation algorithm. The private key\n * must be 32 bytes hashing, and this implementation will use the non-zero padded\n * serialization of a private key, such that it's still possible to derive the privateKey\n * to recover those funds.\n *\n * @param {string|number} arg\n * @param {boolean?} hardened\n */\nHDPrivateKey.prototype.deriveNonCompliantChild = function (arg, hardened) {\n  if (_.isNumber(arg)) {\n    return this._deriveWithNumber(arg, hardened, true);\n  } else if (_.isString(arg)) {\n    return this._deriveFromString(arg, true);\n  } else {\n    throw new hdErrors.InvalidDerivationArgument(arg);\n  }\n};\nHDPrivateKey.prototype._deriveWithNumber = function (index, hardened, nonCompliant) {\n  /* jshint maxstatements: 20 */\n  /* jshint maxcomplexity: 10 */\n  if (!HDPrivateKey.isValidPath(index, hardened)) {\n    throw new hdErrors.InvalidPath(index);\n  }\n  hardened = index >= HDPrivateKey.Hardened ? true : hardened;\n  if (index < HDPrivateKey.Hardened && hardened === true) {\n    index += HDPrivateKey.Hardened;\n  }\n  var indexBuffer = BufferUtil.integerAsBuffer(index);\n  var data;\n  if (hardened && nonCompliant) {\n    // The private key serialization in this case will not be exactly 32 bytes and can be\n    // any value less, and the value is not zero-padded.\n    var nonZeroPadded = this.privateKey.bn.toBuffer();\n    data = BufferUtil.concat([new buffer.Buffer([0]), nonZeroPadded, indexBuffer]);\n  } else if (hardened) {\n    // This will use a 32 byte zero padded serialization of the private key\n    var privateKeyBuffer = this.privateKey.bn.toBuffer({\n      size: 32\n    });\n    assert(privateKeyBuffer.length === 32, 'length of private key buffer is expected to be 32 bytes');\n    data = BufferUtil.concat([new buffer.Buffer([0]), privateKeyBuffer, indexBuffer]);\n  } else {\n    data = BufferUtil.concat([this.publicKey.toBuffer(), indexBuffer]);\n  }\n  var hash = Hash.sha512hmac(data, this._buffers.chainCode);\n  var leftPart = BN.fromBuffer(hash.slice(0, 32), {\n    size: 32\n  });\n  var chainCode = hash.slice(32, 64);\n  var privateKey = leftPart.add(this.privateKey.toBigNumber()).mod(Point.getN()).toBuffer({\n    size: 32\n  });\n  if (!PrivateKey.isValid(privateKey)) {\n    // Index at this point is already hardened, we can pass null as the hardened arg\n    return this._deriveWithNumber(index + 1, null, nonCompliant);\n  }\n  var derived = new HDPrivateKey({\n    network: this.network,\n    depth: this.depth + 1,\n    parentFingerPrint: this.fingerPrint,\n    childIndex: index,\n    chainCode: chainCode,\n    privateKey: privateKey\n  });\n  return derived;\n};\nHDPrivateKey.prototype._deriveFromString = function (path, nonCompliant) {\n  if (!HDPrivateKey.isValidPath(path)) {\n    throw new hdErrors.InvalidPath(path);\n  }\n  var indexes = HDPrivateKey._getDerivationIndexes(path);\n  var derived = indexes.reduce(function (prev, index) {\n    return prev._deriveWithNumber(index, null, nonCompliant);\n  }, this);\n  return derived;\n};\n\n/**\n * Verifies that a given serialized private key in base58 with checksum format\n * is valid.\n *\n * @param {string|Buffer} data - the serialized private key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {boolean}\n */\nHDPrivateKey.isValidSerialized = function (data, network) {\n  return !HDPrivateKey.getSerializedError(data, network);\n};\n\n/**\n * Checks what's the error that causes the validation of a serialized private key\n * in base58 with checksum to fail.\n *\n * @param {string|Buffer} data - the serialized private key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {errors.InvalidArgument|null}\n */\nHDPrivateKey.getSerializedError = function (data, network) {\n  /* jshint maxcomplexity: 10 */\n  if (!(_.isString(data) || BufferUtil.isBuffer(data))) {\n    return new hdErrors.UnrecognizedArgument('Expected string or buffer');\n  }\n  if (!Base58.validCharacters(data)) {\n    return new errors.InvalidB58Char('(unknown)', data);\n  }\n  try {\n    data = Base58Check.decode(data);\n  } catch (e) {\n    return new errors.InvalidB58Checksum(data);\n  }\n  if (data.length !== HDPrivateKey.DataLength) {\n    return new hdErrors.InvalidLength(data);\n  }\n  if (!_.isUndefined(network)) {\n    var error = HDPrivateKey._validateNetwork(data, network);\n    if (error) {\n      return error;\n    }\n  }\n  return null;\n};\nHDPrivateKey._validateNetwork = function (data, networkArg) {\n  var network = Network.get(networkArg);\n  if (!network) {\n    return new errors.InvalidNetworkArgument(networkArg);\n  }\n  var version = data.slice(0, 4);\n  if (BufferUtil.integerFromBuffer(version) !== network.xprivkey) {\n    return new errors.InvalidNetwork(version);\n  }\n  return null;\n};\nHDPrivateKey.fromString = function (arg) {\n  $.checkArgument(_.isString(arg), 'No valid string was provided');\n  return new HDPrivateKey(arg);\n};\nHDPrivateKey.fromObject = function (arg) {\n  $.checkArgument(_.isObject(arg), 'No valid argument was provided');\n  return new HDPrivateKey(arg);\n};\nHDPrivateKey.prototype._buildFromJSON = function (arg) {\n  return this._buildFromObject(JSON.parse(arg));\n};\nHDPrivateKey.prototype._buildFromObject = function (arg) {\n  /* jshint maxcomplexity: 12 */\n  // TODO: Type validation\n  var buffers = {\n    version: arg.network ? BufferUtil.integerAsBuffer(Network.get(arg.network).xprivkey) : arg.version,\n    depth: _.isNumber(arg.depth) ? BufferUtil.integerAsSingleByteBuffer(arg.depth) : arg.depth,\n    parentFingerPrint: _.isNumber(arg.parentFingerPrint) ? BufferUtil.integerAsBuffer(arg.parentFingerPrint) : arg.parentFingerPrint,\n    childIndex: _.isNumber(arg.childIndex) ? BufferUtil.integerAsBuffer(arg.childIndex) : arg.childIndex,\n    chainCode: _.isString(arg.chainCode) ? BufferUtil.hexToBuffer(arg.chainCode) : arg.chainCode,\n    privateKey: _.isString(arg.privateKey) && JSUtil.isHexa(arg.privateKey) ? BufferUtil.hexToBuffer(arg.privateKey) : arg.privateKey,\n    checksum: arg.checksum ? arg.checksum.length ? arg.checksum : BufferUtil.integerAsBuffer(arg.checksum) : undefined\n  };\n  return this._buildFromBuffers(buffers);\n};\nHDPrivateKey.prototype._buildFromSerialized = function (arg) {\n  var decoded = Base58Check.decode(arg);\n  var buffers = {\n    version: decoded.slice(HDPrivateKey.VersionStart, HDPrivateKey.VersionEnd),\n    depth: decoded.slice(HDPrivateKey.DepthStart, HDPrivateKey.DepthEnd),\n    parentFingerPrint: decoded.slice(HDPrivateKey.ParentFingerPrintStart, HDPrivateKey.ParentFingerPrintEnd),\n    childIndex: decoded.slice(HDPrivateKey.ChildIndexStart, HDPrivateKey.ChildIndexEnd),\n    chainCode: decoded.slice(HDPrivateKey.ChainCodeStart, HDPrivateKey.ChainCodeEnd),\n    privateKey: decoded.slice(HDPrivateKey.PrivateKeyStart, HDPrivateKey.PrivateKeyEnd),\n    checksum: decoded.slice(HDPrivateKey.ChecksumStart, HDPrivateKey.ChecksumEnd),\n    xprivkey: arg\n  };\n  return this._buildFromBuffers(buffers);\n};\nHDPrivateKey.prototype._generateRandomly = function (network) {\n  return HDPrivateKey.fromSeed(Random.getRandomBuffer(64), network);\n};\n\n/**\n * Generate a private key from a seed, as described in BIP32\n *\n * @param {string|Buffer} hexa\n * @param {*} network\n * @return HDPrivateKey\n */\nHDPrivateKey.fromSeed = function (hexa, network) {\n  /* jshint maxcomplexity: 8 */\n  if (JSUtil.isHexaString(hexa)) {\n    hexa = BufferUtil.hexToBuffer(hexa);\n  }\n  if (!Buffer.isBuffer(hexa)) {\n    throw new hdErrors.InvalidEntropyArgument(hexa);\n  }\n  if (hexa.length < MINIMUM_ENTROPY_BITS * BITS_TO_BYTES) {\n    throw new hdErrors.InvalidEntropyArgument.NotEnoughEntropy(hexa);\n  }\n  if (hexa.length > MAXIMUM_ENTROPY_BITS * BITS_TO_BYTES) {\n    throw new hdErrors.InvalidEntropyArgument.TooMuchEntropy(hexa);\n  }\n  var hash = Hash.sha512hmac(hexa, new buffer.Buffer('Bitcoin seed'));\n  return new HDPrivateKey({\n    network: Network.get(network) || Network.defaultNetwork,\n    depth: 0,\n    parentFingerPrint: 0,\n    childIndex: 0,\n    privateKey: hash.slice(0, 32),\n    chainCode: hash.slice(32, 64)\n  });\n};\nHDPrivateKey.prototype._calcHDPublicKey = function () {\n  if (!this._hdPublicKey) {\n    var HDPublicKey = require('./hdpublickey');\n    this._hdPublicKey = new HDPublicKey(this);\n  }\n};\n\n/**\n * Receives a object with buffers in all the properties and populates the\n * internal structure\n *\n * @param {Object} arg\n * @param {buffer.Buffer} arg.version\n * @param {buffer.Buffer} arg.depth\n * @param {buffer.Buffer} arg.parentFingerPrint\n * @param {buffer.Buffer} arg.childIndex\n * @param {buffer.Buffer} arg.chainCode\n * @param {buffer.Buffer} arg.privateKey\n * @param {buffer.Buffer} arg.checksum\n * @param {string=} arg.xprivkey - if set, don't recalculate the base58\n *      representation\n * @return {HDPrivateKey} this\n */\nHDPrivateKey.prototype._buildFromBuffers = function (arg) {\n  /* jshint maxcomplexity: 8 */\n  /* jshint maxstatements: 20 */\n\n  HDPrivateKey._validateBufferArguments(arg);\n  JSUtil.defineImmutable(this, {\n    _buffers: arg\n  });\n  var sequence = [arg.version, arg.depth, arg.parentFingerPrint, arg.childIndex, arg.chainCode, BufferUtil.emptyBuffer(1), arg.privateKey];\n  var concat = buffer.Buffer.concat(sequence);\n  if (!arg.checksum || !arg.checksum.length) {\n    arg.checksum = Base58Check.checksum(concat);\n  } else {\n    if (arg.checksum.toString() !== Base58Check.checksum(concat).toString()) {\n      throw new errors.InvalidB58Checksum(concat);\n    }\n  }\n  var network = Network.get(BufferUtil.integerFromBuffer(arg.version));\n  var xprivkey;\n  xprivkey = Base58Check.encode(buffer.Buffer.concat(sequence));\n  arg.xprivkey = new Buffer(xprivkey);\n  var privateKey = new PrivateKey(BN.fromBuffer(arg.privateKey), network);\n  var publicKey = privateKey.toPublicKey();\n  var size = HDPrivateKey.ParentFingerPrintSize;\n  var fingerPrint = Hash.sha256ripemd160(publicKey.toBuffer()).slice(0, size);\n  JSUtil.defineImmutable(this, {\n    xprivkey: xprivkey,\n    network: network,\n    depth: BufferUtil.integerFromSingleByteBuffer(arg.depth),\n    privateKey: privateKey,\n    publicKey: publicKey,\n    fingerPrint: fingerPrint\n  });\n  this._hdPublicKey = null;\n  Object.defineProperty(this, 'hdPublicKey', {\n    configurable: false,\n    enumerable: true,\n    get: function get() {\n      this._calcHDPublicKey();\n      return this._hdPublicKey;\n    }\n  });\n  Object.defineProperty(this, 'xpubkey', {\n    configurable: false,\n    enumerable: true,\n    get: function get() {\n      this._calcHDPublicKey();\n      return this._hdPublicKey.xpubkey;\n    }\n  });\n  return this;\n};\nHDPrivateKey._validateBufferArguments = function (arg) {\n  var checkBuffer = function checkBuffer(name, size) {\n    var buff = arg[name];\n    assert(BufferUtil.isBuffer(buff), name + ' argument is not a buffer');\n    assert(buff.length === size, name + ' has not the expected size: found ' + buff.length + ', expected ' + size);\n  };\n  checkBuffer('version', HDPrivateKey.VersionSize);\n  checkBuffer('depth', HDPrivateKey.DepthSize);\n  checkBuffer('parentFingerPrint', HDPrivateKey.ParentFingerPrintSize);\n  checkBuffer('childIndex', HDPrivateKey.ChildIndexSize);\n  checkBuffer('chainCode', HDPrivateKey.ChainCodeSize);\n  checkBuffer('privateKey', HDPrivateKey.PrivateKeySize);\n  if (arg.checksum && arg.checksum.length) {\n    checkBuffer('checksum', HDPrivateKey.CheckSumSize);\n  }\n};\n\n/**\n * Returns the string representation of this private key (a string starting\n * with \"xprv...\"\n *\n * @return string\n */\nHDPrivateKey.prototype.toString = function () {\n  return this.xprivkey;\n};\n\n/**\n * Returns the console representation of this extended private key.\n * @return string\n */\nHDPrivateKey.prototype.inspect = function () {\n  return '<HDPrivateKey: ' + this.xprivkey + '>';\n};\n\n/**\n * Returns a plain object with a representation of this private key.\n *\n * Fields include:<ul>\n * <li> network: either 'livenet' or 'testnet'\n * <li> depth: a number ranging from 0 to 255\n * <li> fingerPrint: a number ranging from 0 to 2^32-1, taken from the hash of the\n * <li>     associated public key\n * <li> parentFingerPrint: a number ranging from 0 to 2^32-1, taken from the hash\n * <li>     of this parent's associated public key or zero.\n * <li> childIndex: the index from which this child was derived (or zero)\n * <li> chainCode: an hexa string representing a number used in the derivation\n * <li> privateKey: the private key associated, in hexa representation\n * <li> xprivkey: the representation of this extended private key in checksum\n * <li>     base58 format\n * <li> checksum: the base58 checksum of xprivkey\n * </ul>\n *  @return {Object}\n */\nHDPrivateKey.prototype.toObject = HDPrivateKey.prototype.toJSON = function toObject() {\n  return {\n    network: Network.get(BufferUtil.integerFromBuffer(this._buffers.version), 'xprivkey').name,\n    depth: BufferUtil.integerFromSingleByteBuffer(this._buffers.depth),\n    fingerPrint: BufferUtil.integerFromBuffer(this.fingerPrint),\n    parentFingerPrint: BufferUtil.integerFromBuffer(this._buffers.parentFingerPrint),\n    childIndex: BufferUtil.integerFromBuffer(this._buffers.childIndex),\n    chainCode: BufferUtil.bufferToHex(this._buffers.chainCode),\n    privateKey: this.privateKey.toBuffer().toString('hex'),\n    checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),\n    xprivkey: this.xprivkey\n  };\n};\n\n/**\n * Build a HDPrivateKey from a buffer\n *\n * @param {Buffer} arg\n * @return {HDPrivateKey}\n */\nHDPrivateKey.fromBuffer = function (arg) {\n  return new HDPrivateKey(arg.toString());\n};\n\n/**\n * Returns a buffer representation of the HDPrivateKey\n *\n * @return {string}\n */\nHDPrivateKey.prototype.toBuffer = function () {\n  return BufferUtil.copy(this._buffers.xprivkey);\n};\nHDPrivateKey.DefaultDepth = 0;\nHDPrivateKey.DefaultFingerprint = 0;\nHDPrivateKey.DefaultChildIndex = 0;\nHDPrivateKey.Hardened = 0x80000000;\nHDPrivateKey.MaxIndex = 2 * HDPrivateKey.Hardened;\nHDPrivateKey.RootElementAlias = ['m', 'M', 'm\\'', 'M\\''];\nHDPrivateKey.VersionSize = 4;\nHDPrivateKey.DepthSize = 1;\nHDPrivateKey.ParentFingerPrintSize = 4;\nHDPrivateKey.ChildIndexSize = 4;\nHDPrivateKey.ChainCodeSize = 32;\nHDPrivateKey.PrivateKeySize = 32;\nHDPrivateKey.CheckSumSize = 4;\nHDPrivateKey.DataLength = 78;\nHDPrivateKey.SerializedByteSize = 82;\nHDPrivateKey.VersionStart = 0;\nHDPrivateKey.VersionEnd = HDPrivateKey.VersionStart + HDPrivateKey.VersionSize;\nHDPrivateKey.DepthStart = HDPrivateKey.VersionEnd;\nHDPrivateKey.DepthEnd = HDPrivateKey.DepthStart + HDPrivateKey.DepthSize;\nHDPrivateKey.ParentFingerPrintStart = HDPrivateKey.DepthEnd;\nHDPrivateKey.ParentFingerPrintEnd = HDPrivateKey.ParentFingerPrintStart + HDPrivateKey.ParentFingerPrintSize;\nHDPrivateKey.ChildIndexStart = HDPrivateKey.ParentFingerPrintEnd;\nHDPrivateKey.ChildIndexEnd = HDPrivateKey.ChildIndexStart + HDPrivateKey.ChildIndexSize;\nHDPrivateKey.ChainCodeStart = HDPrivateKey.ChildIndexEnd;\nHDPrivateKey.ChainCodeEnd = HDPrivateKey.ChainCodeStart + HDPrivateKey.ChainCodeSize;\nHDPrivateKey.PrivateKeyStart = HDPrivateKey.ChainCodeEnd + 1;\nHDPrivateKey.PrivateKeyEnd = HDPrivateKey.PrivateKeyStart + HDPrivateKey.PrivateKeySize;\nHDPrivateKey.ChecksumStart = HDPrivateKey.PrivateKeyEnd;\nHDPrivateKey.ChecksumEnd = HDPrivateKey.ChecksumStart + HDPrivateKey.CheckSumSize;\nassert(HDPrivateKey.ChecksumEnd === HDPrivateKey.SerializedByteSize);\nmodule.exports = HDPrivateKey;","map":{"version":3,"names":["assert","require","buffer","_","$","BN","Base58","Base58Check","Hash","Network","Point","PrivateKey","Random","errors","hdErrors","HDPrivateKey","BufferUtil","JSUtil","MINIMUM_ENTROPY_BITS","BITS_TO_BYTES","MAXIMUM_ENTROPY_BITS","arg","_generateRandomly","get","isString","isBuffer","isValidSerialized","_buildFromSerialized","isValidJSON","_buildFromJSON","toString","getSerializedError","isObject","_buildFromObject","UnrecognizedArgument","isValidPath","hardened","indexes","_getDerivationIndexes","every","isNumber","Hardened","MaxIndex","path","steps","split","includes","RootElementAlias","slice","map","step","isHardened","NaN","index","some","isNaN","prototype","derive","deriveNonCompliantChild","deriveChild","_deriveWithNumber","_deriveFromString","InvalidDerivationArgument","nonCompliant","InvalidPath","indexBuffer","integerAsBuffer","data","nonZeroPadded","privateKey","bn","toBuffer","concat","Buffer","privateKeyBuffer","size","length","publicKey","hash","sha512hmac","_buffers","chainCode","leftPart","fromBuffer","add","toBigNumber","mod","getN","isValid","derived","network","depth","parentFingerPrint","fingerPrint","childIndex","reduce","prev","validCharacters","InvalidB58Char","decode","e","InvalidB58Checksum","DataLength","InvalidLength","isUndefined","error","_validateNetwork","networkArg","InvalidNetworkArgument","version","integerFromBuffer","xprivkey","InvalidNetwork","fromString","checkArgument","fromObject","JSON","parse","buffers","integerAsSingleByteBuffer","hexToBuffer","isHexa","checksum","undefined","_buildFromBuffers","decoded","VersionStart","VersionEnd","DepthStart","DepthEnd","ParentFingerPrintStart","ParentFingerPrintEnd","ChildIndexStart","ChildIndexEnd","ChainCodeStart","ChainCodeEnd","PrivateKeyStart","PrivateKeyEnd","ChecksumStart","ChecksumEnd","fromSeed","getRandomBuffer","hexa","isHexaString","InvalidEntropyArgument","NotEnoughEntropy","TooMuchEntropy","defaultNetwork","_calcHDPublicKey","_hdPublicKey","HDPublicKey","_validateBufferArguments","defineImmutable","sequence","emptyBuffer","encode","toPublicKey","ParentFingerPrintSize","sha256ripemd160","integerFromSingleByteBuffer","Object","defineProperty","configurable","enumerable","xpubkey","checkBuffer","name","buff","VersionSize","DepthSize","ChildIndexSize","ChainCodeSize","PrivateKeySize","CheckSumSize","inspect","toObject","toJSON","bufferToHex","copy","DefaultDepth","DefaultFingerprint","DefaultChildIndex","SerializedByteSize","module","exports"],"sources":["C:/Users/Elton/OneDrive/Desktop/baseapp-2024/node_modules/bitcoincashjs/src/hdprivatekey.js"],"sourcesContent":["'use strict';\n\n\nvar assert = require('assert');\nvar buffer = require('buffer');\nvar _ = require('lodash');\nvar $ = require('./util/preconditions');\n\nvar BN = require('./crypto/bn');\nvar Base58 = require('./encoding/base58');\nvar Base58Check = require('./encoding/base58check');\nvar Hash = require('./crypto/hash');\nvar Network = require('./networks');\nvar Point = require('./crypto/point');\nvar PrivateKey = require('./privatekey');\nvar Random = require('./crypto/random');\n\nvar errors = require('./errors');\nvar hdErrors = errors.HDPrivateKey;\nvar BufferUtil = require('./util/buffer');\nvar JSUtil = require('./util/js');\n\nvar MINIMUM_ENTROPY_BITS = 128;\nvar BITS_TO_BYTES = 1 / 8;\nvar MAXIMUM_ENTROPY_BITS = 512;\n\n\n/**\n * Represents an instance of an hierarchically derived private key.\n *\n * More info on https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\n *\n * @constructor\n * @param {string|Buffer|Object} arg\n */\nfunction HDPrivateKey(arg) {\n  /* jshint maxcomplexity: 10 */\n  if (arg instanceof HDPrivateKey) {\n    return arg;\n  }\n  if (!(this instanceof HDPrivateKey)) {\n    return new HDPrivateKey(arg);\n  }\n  if (!arg) {\n    return this._generateRandomly();\n  }\n\n  if (Network.get(arg)) {\n    return this._generateRandomly(arg);\n  } else if (_.isString(arg) || BufferUtil.isBuffer(arg)) {\n    if (HDPrivateKey.isValidSerialized(arg)) {\n      this._buildFromSerialized(arg);\n    } else if (JSUtil.isValidJSON(arg)) {\n      this._buildFromJSON(arg);\n    } else if (BufferUtil.isBuffer(arg) && HDPrivateKey.isValidSerialized(arg.toString())) {\n      this._buildFromSerialized(arg.toString());\n    } else {\n      throw HDPrivateKey.getSerializedError(arg);\n    }\n  } else if (_.isObject(arg)) {\n    this._buildFromObject(arg);\n  } else {\n    throw new hdErrors.UnrecognizedArgument(arg);\n  }\n}\n\n/**\n * Verifies that a given path is valid.\n *\n * @param {string|number} arg\n * @param {boolean?} hardened\n * @return {boolean}\n */\nHDPrivateKey.isValidPath = function(arg, hardened) {\n  if (_.isString(arg)) {\n    var indexes = HDPrivateKey._getDerivationIndexes(arg);\n    return indexes !== null && _.every(indexes, HDPrivateKey.isValidPath);\n  }\n\n  if (_.isNumber(arg)) {\n    if (arg < HDPrivateKey.Hardened && hardened === true) {\n      arg += HDPrivateKey.Hardened;\n    }\n    return arg >= 0 && arg < HDPrivateKey.MaxIndex;\n  }\n\n  return false;\n};\n\n/**\n * Internal function that splits a string path into a derivation index array.\n * It will return null if the string path is malformed.\n * It does not validate if indexes are in bounds.\n *\n * @param {string} path\n * @return {Array}\n */\nHDPrivateKey._getDerivationIndexes = function(path) {\n  var steps = path.split('/');\n\n  // Special cases:\n  if (_.includes(HDPrivateKey.RootElementAlias, path)) {\n    return [];\n  }\n\n  if (!_.includes(HDPrivateKey.RootElementAlias, steps[0])) {\n    return null;\n  }\n\n  var indexes = steps.slice(1).map(function(step) {\n    var isHardened = step.slice(-1) === '\\'';\n    if (isHardened) {\n      step = step.slice(0, -1);\n    }\n    if (!step || step[0] === '-') {\n      return NaN;\n    }\n    var index = +step; // cast to number\n    if (isHardened) {\n      index += HDPrivateKey.Hardened;\n    }\n\n    return index;\n  });\n\n  return _.some(indexes, isNaN) ? null : indexes;\n};\n\n/**\n * WARNING: This method is deprecated. Use deriveChild or deriveNonCompliantChild instead. This is not BIP32 compliant\n *\n *\n * Get a derived child based on a string or number.\n *\n * If the first argument is a string, it's parsed as the full path of\n * derivation. Valid values for this argument include \"m\" (which returns the\n * same private key), \"m/0/1/40/2'/1000\", where the ' quote means a hardened\n * derivation.\n *\n * If the first argument is a number, the child with that index will be\n * derived. If the second argument is truthy, the hardened version will be\n * derived. See the example usage for clarification.\n *\n * @example\n * ```javascript\n * var parent = new HDPrivateKey('xprv...');\n * var child_0_1_2h = parent.derive(0).derive(1).derive(2, true);\n * var copy_of_child_0_1_2h = parent.derive(\"m/0/1/2'\");\n * assert(child_0_1_2h.xprivkey === copy_of_child_0_1_2h);\n * ```\n *\n * @param {string|number} arg\n * @param {boolean?} hardened\n */\nHDPrivateKey.prototype.derive = function(arg, hardened) {\n  return this.deriveNonCompliantChild(arg, hardened);\n};\n\n/**\n * WARNING: This method will not be officially supported until v1.0.0.\n *\n *\n * Get a derived child based on a string or number.\n *\n * If the first argument is a string, it's parsed as the full path of\n * derivation. Valid values for this argument include \"m\" (which returns the\n * same private key), \"m/0/1/40/2'/1000\", where the ' quote means a hardened\n * derivation.\n *\n * If the first argument is a number, the child with that index will be\n * derived. If the second argument is truthy, the hardened version will be\n * derived. See the example usage for clarification.\n *\n * WARNING: The `nonCompliant` option should NOT be used, except for older implementation\n * that used a derivation strategy that used a non-zero padded private key.\n *\n * @example\n * ```javascript\n * var parent = new HDPrivateKey('xprv...');\n * var child_0_1_2h = parent.deriveChild(0).deriveChild(1).deriveChild(2, true);\n * var copy_of_child_0_1_2h = parent.deriveChild(\"m/0/1/2'\");\n * assert(child_0_1_2h.xprivkey === copy_of_child_0_1_2h);\n * ```\n *\n * @param {string|number} arg\n * @param {boolean?} hardened\n */\nHDPrivateKey.prototype.deriveChild = function(arg, hardened) {\n  if (_.isNumber(arg)) {\n    return this._deriveWithNumber(arg, hardened);\n  } else if (_.isString(arg)) {\n    return this._deriveFromString(arg);\n  } else {\n    throw new hdErrors.InvalidDerivationArgument(arg);\n  }\n};\n\n/**\n * WARNING: This method will not be officially supported until v1.0.0\n *\n *\n * WARNING: If this is a new implementation you should NOT use this method, you should be using\n * `derive` instead.\n *\n * This method is explicitly for use and compatibility with an implementation that\n * was not compliant with BIP32 regarding the derivation algorithm. The private key\n * must be 32 bytes hashing, and this implementation will use the non-zero padded\n * serialization of a private key, such that it's still possible to derive the privateKey\n * to recover those funds.\n *\n * @param {string|number} arg\n * @param {boolean?} hardened\n */\nHDPrivateKey.prototype.deriveNonCompliantChild = function(arg, hardened) {\n  if (_.isNumber(arg)) {\n    return this._deriveWithNumber(arg, hardened, true);\n  } else if (_.isString(arg)) {\n    return this._deriveFromString(arg, true);\n  } else {\n    throw new hdErrors.InvalidDerivationArgument(arg);\n  }\n};\n\nHDPrivateKey.prototype._deriveWithNumber = function(index, hardened, nonCompliant) {\n  /* jshint maxstatements: 20 */\n  /* jshint maxcomplexity: 10 */\n  if (!HDPrivateKey.isValidPath(index, hardened)) {\n    throw new hdErrors.InvalidPath(index);\n  }\n\n  hardened = index >= HDPrivateKey.Hardened ? true : hardened;\n  if (index < HDPrivateKey.Hardened && hardened === true) {\n    index += HDPrivateKey.Hardened;\n  }\n\n  var indexBuffer = BufferUtil.integerAsBuffer(index);\n  var data;\n  if (hardened && nonCompliant) {\n    // The private key serialization in this case will not be exactly 32 bytes and can be\n    // any value less, and the value is not zero-padded.\n    var nonZeroPadded = this.privateKey.bn.toBuffer();\n    data = BufferUtil.concat([new buffer.Buffer([0]), nonZeroPadded, indexBuffer]);\n  } else if (hardened) {\n    // This will use a 32 byte zero padded serialization of the private key\n    var privateKeyBuffer = this.privateKey.bn.toBuffer({size: 32});\n    assert(privateKeyBuffer.length === 32, 'length of private key buffer is expected to be 32 bytes');\n    data = BufferUtil.concat([new buffer.Buffer([0]), privateKeyBuffer, indexBuffer]);\n  } else {\n    data = BufferUtil.concat([this.publicKey.toBuffer(), indexBuffer]);\n  }\n  var hash = Hash.sha512hmac(data, this._buffers.chainCode);\n  var leftPart = BN.fromBuffer(hash.slice(0, 32), {\n    size: 32\n  });\n  var chainCode = hash.slice(32, 64);\n\n  var privateKey = leftPart.add(this.privateKey.toBigNumber()).mod(Point.getN()).toBuffer({\n    size: 32\n  });\n\n  if (!PrivateKey.isValid(privateKey)) {\n    // Index at this point is already hardened, we can pass null as the hardened arg\n    return this._deriveWithNumber(index + 1, null, nonCompliant);\n  }\n\n  var derived = new HDPrivateKey({\n    network: this.network,\n    depth: this.depth + 1,\n    parentFingerPrint: this.fingerPrint,\n    childIndex: index,\n    chainCode: chainCode,\n    privateKey: privateKey\n  });\n\n  return derived;\n};\n\nHDPrivateKey.prototype._deriveFromString = function(path, nonCompliant) {\n  if (!HDPrivateKey.isValidPath(path)) {\n    throw new hdErrors.InvalidPath(path);\n  }\n\n  var indexes = HDPrivateKey._getDerivationIndexes(path);\n  var derived = indexes.reduce(function(prev, index) {\n    return prev._deriveWithNumber(index, null, nonCompliant);\n  }, this);\n\n  return derived;\n};\n\n/**\n * Verifies that a given serialized private key in base58 with checksum format\n * is valid.\n *\n * @param {string|Buffer} data - the serialized private key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {boolean}\n */\nHDPrivateKey.isValidSerialized = function(data, network) {\n  return !HDPrivateKey.getSerializedError(data, network);\n};\n\n/**\n * Checks what's the error that causes the validation of a serialized private key\n * in base58 with checksum to fail.\n *\n * @param {string|Buffer} data - the serialized private key\n * @param {string|Network=} network - optional, if present, checks that the\n *     network provided matches the network serialized.\n * @return {errors.InvalidArgument|null}\n */\nHDPrivateKey.getSerializedError = function(data, network) {\n  /* jshint maxcomplexity: 10 */\n  if (!(_.isString(data) || BufferUtil.isBuffer(data))) {\n    return new hdErrors.UnrecognizedArgument('Expected string or buffer');\n  }\n  if (!Base58.validCharacters(data)) {\n    return new errors.InvalidB58Char('(unknown)', data);\n  }\n  try {\n    data = Base58Check.decode(data);\n  } catch (e) {\n    return new errors.InvalidB58Checksum(data);\n  }\n  if (data.length !== HDPrivateKey.DataLength) {\n    return new hdErrors.InvalidLength(data);\n  }\n  if (!_.isUndefined(network)) {\n    var error = HDPrivateKey._validateNetwork(data, network);\n    if (error) {\n      return error;\n    }\n  }\n  return null;\n};\n\nHDPrivateKey._validateNetwork = function(data, networkArg) {\n  var network = Network.get(networkArg);\n  if (!network) {\n    return new errors.InvalidNetworkArgument(networkArg);\n  }\n  var version = data.slice(0, 4);\n  if (BufferUtil.integerFromBuffer(version) !== network.xprivkey) {\n    return new errors.InvalidNetwork(version);\n  }\n  return null;\n};\n\nHDPrivateKey.fromString = function(arg) {\n  $.checkArgument(_.isString(arg), 'No valid string was provided');\n  return new HDPrivateKey(arg);\n};\n\nHDPrivateKey.fromObject = function(arg) {\n  $.checkArgument(_.isObject(arg), 'No valid argument was provided');\n  return new HDPrivateKey(arg);\n};\n\nHDPrivateKey.prototype._buildFromJSON = function(arg) {\n  return this._buildFromObject(JSON.parse(arg));\n};\n\nHDPrivateKey.prototype._buildFromObject = function(arg) {\n  /* jshint maxcomplexity: 12 */\n  // TODO: Type validation\n  var buffers = {\n    version: arg.network ? BufferUtil.integerAsBuffer(Network.get(arg.network).xprivkey) : arg.version,\n    depth: _.isNumber(arg.depth) ? BufferUtil.integerAsSingleByteBuffer(arg.depth) : arg.depth,\n    parentFingerPrint: _.isNumber(arg.parentFingerPrint) ? BufferUtil.integerAsBuffer(arg.parentFingerPrint) : arg.parentFingerPrint,\n    childIndex: _.isNumber(arg.childIndex) ? BufferUtil.integerAsBuffer(arg.childIndex) : arg.childIndex,\n    chainCode: _.isString(arg.chainCode) ? BufferUtil.hexToBuffer(arg.chainCode) : arg.chainCode,\n    privateKey: (_.isString(arg.privateKey) && JSUtil.isHexa(arg.privateKey)) ? BufferUtil.hexToBuffer(arg.privateKey) : arg.privateKey,\n    checksum: arg.checksum ? (arg.checksum.length ? arg.checksum : BufferUtil.integerAsBuffer(arg.checksum)) : undefined\n  };\n  return this._buildFromBuffers(buffers);\n};\n\nHDPrivateKey.prototype._buildFromSerialized = function(arg) {\n  var decoded = Base58Check.decode(arg);\n  var buffers = {\n    version: decoded.slice(HDPrivateKey.VersionStart, HDPrivateKey.VersionEnd),\n    depth: decoded.slice(HDPrivateKey.DepthStart, HDPrivateKey.DepthEnd),\n    parentFingerPrint: decoded.slice(HDPrivateKey.ParentFingerPrintStart,\n      HDPrivateKey.ParentFingerPrintEnd),\n    childIndex: decoded.slice(HDPrivateKey.ChildIndexStart, HDPrivateKey.ChildIndexEnd),\n    chainCode: decoded.slice(HDPrivateKey.ChainCodeStart, HDPrivateKey.ChainCodeEnd),\n    privateKey: decoded.slice(HDPrivateKey.PrivateKeyStart, HDPrivateKey.PrivateKeyEnd),\n    checksum: decoded.slice(HDPrivateKey.ChecksumStart, HDPrivateKey.ChecksumEnd),\n    xprivkey: arg\n  };\n  return this._buildFromBuffers(buffers);\n};\n\nHDPrivateKey.prototype._generateRandomly = function(network) {\n  return HDPrivateKey.fromSeed(Random.getRandomBuffer(64), network);\n};\n\n/**\n * Generate a private key from a seed, as described in BIP32\n *\n * @param {string|Buffer} hexa\n * @param {*} network\n * @return HDPrivateKey\n */\nHDPrivateKey.fromSeed = function(hexa, network) {\n  /* jshint maxcomplexity: 8 */\n  if (JSUtil.isHexaString(hexa)) {\n    hexa = BufferUtil.hexToBuffer(hexa);\n  }\n  if (!Buffer.isBuffer(hexa)) {\n    throw new hdErrors.InvalidEntropyArgument(hexa);\n  }\n  if (hexa.length < MINIMUM_ENTROPY_BITS * BITS_TO_BYTES) {\n    throw new hdErrors.InvalidEntropyArgument.NotEnoughEntropy(hexa);\n  }\n  if (hexa.length > MAXIMUM_ENTROPY_BITS * BITS_TO_BYTES) {\n    throw new hdErrors.InvalidEntropyArgument.TooMuchEntropy(hexa);\n  }\n  var hash = Hash.sha512hmac(hexa, new buffer.Buffer('Bitcoin seed'));\n\n  return new HDPrivateKey({\n    network: Network.get(network) || Network.defaultNetwork,\n    depth: 0,\n    parentFingerPrint: 0,\n    childIndex: 0,\n    privateKey: hash.slice(0, 32),\n    chainCode: hash.slice(32, 64)\n  });\n};\n\n\n\nHDPrivateKey.prototype._calcHDPublicKey = function() {\n  if (!this._hdPublicKey) {\n    var HDPublicKey = require('./hdpublickey');\n    this._hdPublicKey = new HDPublicKey(this);\n  }\n};\n\n/**\n * Receives a object with buffers in all the properties and populates the\n * internal structure\n *\n * @param {Object} arg\n * @param {buffer.Buffer} arg.version\n * @param {buffer.Buffer} arg.depth\n * @param {buffer.Buffer} arg.parentFingerPrint\n * @param {buffer.Buffer} arg.childIndex\n * @param {buffer.Buffer} arg.chainCode\n * @param {buffer.Buffer} arg.privateKey\n * @param {buffer.Buffer} arg.checksum\n * @param {string=} arg.xprivkey - if set, don't recalculate the base58\n *      representation\n * @return {HDPrivateKey} this\n */\nHDPrivateKey.prototype._buildFromBuffers = function(arg) {\n  /* jshint maxcomplexity: 8 */\n  /* jshint maxstatements: 20 */\n\n  HDPrivateKey._validateBufferArguments(arg);\n\n  JSUtil.defineImmutable(this, {\n    _buffers: arg\n  });\n\n  var sequence = [\n    arg.version, arg.depth, arg.parentFingerPrint, arg.childIndex, arg.chainCode,\n    BufferUtil.emptyBuffer(1), arg.privateKey\n  ];\n  var concat = buffer.Buffer.concat(sequence);\n  if (!arg.checksum || !arg.checksum.length) {\n    arg.checksum = Base58Check.checksum(concat);\n  } else {\n    if (arg.checksum.toString() !== Base58Check.checksum(concat).toString()) {\n      throw new errors.InvalidB58Checksum(concat);\n    }\n  }\n\n  var network = Network.get(BufferUtil.integerFromBuffer(arg.version));\n  var xprivkey;\n  xprivkey = Base58Check.encode(buffer.Buffer.concat(sequence));\n  arg.xprivkey = new Buffer(xprivkey);\n\n  var privateKey = new PrivateKey(BN.fromBuffer(arg.privateKey), network);\n  var publicKey = privateKey.toPublicKey();\n  var size = HDPrivateKey.ParentFingerPrintSize;\n  var fingerPrint = Hash.sha256ripemd160(publicKey.toBuffer()).slice(0, size);\n\n  JSUtil.defineImmutable(this, {\n    xprivkey: xprivkey,\n    network: network,\n    depth: BufferUtil.integerFromSingleByteBuffer(arg.depth),\n    privateKey: privateKey,\n    publicKey: publicKey,\n    fingerPrint: fingerPrint\n  });\n\n  this._hdPublicKey = null;\n\n  Object.defineProperty(this, 'hdPublicKey', {\n    configurable: false,\n    enumerable: true,\n    get: function() {\n      this._calcHDPublicKey();\n      return this._hdPublicKey;\n    }\n  });\n  Object.defineProperty(this, 'xpubkey', {\n    configurable: false,\n    enumerable: true,\n    get: function() {\n      this._calcHDPublicKey();\n      return this._hdPublicKey.xpubkey;\n    }\n  });\n  return this;\n};\n\nHDPrivateKey._validateBufferArguments = function(arg) {\n  var checkBuffer = function(name, size) {\n    var buff = arg[name];\n    assert(BufferUtil.isBuffer(buff), name + ' argument is not a buffer');\n    assert(\n      buff.length === size,\n      name + ' has not the expected size: found ' + buff.length + ', expected ' + size\n    );\n  };\n  checkBuffer('version', HDPrivateKey.VersionSize);\n  checkBuffer('depth', HDPrivateKey.DepthSize);\n  checkBuffer('parentFingerPrint', HDPrivateKey.ParentFingerPrintSize);\n  checkBuffer('childIndex', HDPrivateKey.ChildIndexSize);\n  checkBuffer('chainCode', HDPrivateKey.ChainCodeSize);\n  checkBuffer('privateKey', HDPrivateKey.PrivateKeySize);\n  if (arg.checksum && arg.checksum.length) {\n    checkBuffer('checksum', HDPrivateKey.CheckSumSize);\n  }\n};\n\n/**\n * Returns the string representation of this private key (a string starting\n * with \"xprv...\"\n *\n * @return string\n */\nHDPrivateKey.prototype.toString = function() {\n  return this.xprivkey;\n};\n\n/**\n * Returns the console representation of this extended private key.\n * @return string\n */\nHDPrivateKey.prototype.inspect = function() {\n  return '<HDPrivateKey: ' + this.xprivkey + '>';\n};\n\n/**\n * Returns a plain object with a representation of this private key.\n *\n * Fields include:<ul>\n * <li> network: either 'livenet' or 'testnet'\n * <li> depth: a number ranging from 0 to 255\n * <li> fingerPrint: a number ranging from 0 to 2^32-1, taken from the hash of the\n * <li>     associated public key\n * <li> parentFingerPrint: a number ranging from 0 to 2^32-1, taken from the hash\n * <li>     of this parent's associated public key or zero.\n * <li> childIndex: the index from which this child was derived (or zero)\n * <li> chainCode: an hexa string representing a number used in the derivation\n * <li> privateKey: the private key associated, in hexa representation\n * <li> xprivkey: the representation of this extended private key in checksum\n * <li>     base58 format\n * <li> checksum: the base58 checksum of xprivkey\n * </ul>\n *  @return {Object}\n */\nHDPrivateKey.prototype.toObject = HDPrivateKey.prototype.toJSON = function toObject() {\n  return {\n    network: Network.get(BufferUtil.integerFromBuffer(this._buffers.version), 'xprivkey').name,\n    depth: BufferUtil.integerFromSingleByteBuffer(this._buffers.depth),\n    fingerPrint: BufferUtil.integerFromBuffer(this.fingerPrint),\n    parentFingerPrint: BufferUtil.integerFromBuffer(this._buffers.parentFingerPrint),\n    childIndex: BufferUtil.integerFromBuffer(this._buffers.childIndex),\n    chainCode: BufferUtil.bufferToHex(this._buffers.chainCode),\n    privateKey: this.privateKey.toBuffer().toString('hex'),\n    checksum: BufferUtil.integerFromBuffer(this._buffers.checksum),\n    xprivkey: this.xprivkey\n  };\n};\n\n/**\n * Build a HDPrivateKey from a buffer\n *\n * @param {Buffer} arg\n * @return {HDPrivateKey}\n */\nHDPrivateKey.fromBuffer = function(arg) {\n  return new HDPrivateKey(arg.toString());\n};\n\n/**\n * Returns a buffer representation of the HDPrivateKey\n *\n * @return {string}\n */\nHDPrivateKey.prototype.toBuffer = function() {\n  return BufferUtil.copy(this._buffers.xprivkey);\n};\n\nHDPrivateKey.DefaultDepth = 0;\nHDPrivateKey.DefaultFingerprint = 0;\nHDPrivateKey.DefaultChildIndex = 0;\nHDPrivateKey.Hardened = 0x80000000;\nHDPrivateKey.MaxIndex = 2 * HDPrivateKey.Hardened;\n\nHDPrivateKey.RootElementAlias = ['m', 'M', 'm\\'', 'M\\''];\n\nHDPrivateKey.VersionSize = 4;\nHDPrivateKey.DepthSize = 1;\nHDPrivateKey.ParentFingerPrintSize = 4;\nHDPrivateKey.ChildIndexSize = 4;\nHDPrivateKey.ChainCodeSize = 32;\nHDPrivateKey.PrivateKeySize = 32;\nHDPrivateKey.CheckSumSize = 4;\n\nHDPrivateKey.DataLength = 78;\nHDPrivateKey.SerializedByteSize = 82;\n\nHDPrivateKey.VersionStart = 0;\nHDPrivateKey.VersionEnd = HDPrivateKey.VersionStart + HDPrivateKey.VersionSize;\nHDPrivateKey.DepthStart = HDPrivateKey.VersionEnd;\nHDPrivateKey.DepthEnd = HDPrivateKey.DepthStart + HDPrivateKey.DepthSize;\nHDPrivateKey.ParentFingerPrintStart = HDPrivateKey.DepthEnd;\nHDPrivateKey.ParentFingerPrintEnd = HDPrivateKey.ParentFingerPrintStart + HDPrivateKey.ParentFingerPrintSize;\nHDPrivateKey.ChildIndexStart = HDPrivateKey.ParentFingerPrintEnd;\nHDPrivateKey.ChildIndexEnd = HDPrivateKey.ChildIndexStart + HDPrivateKey.ChildIndexSize;\nHDPrivateKey.ChainCodeStart = HDPrivateKey.ChildIndexEnd;\nHDPrivateKey.ChainCodeEnd = HDPrivateKey.ChainCodeStart + HDPrivateKey.ChainCodeSize;\nHDPrivateKey.PrivateKeyStart = HDPrivateKey.ChainCodeEnd + 1;\nHDPrivateKey.PrivateKeyEnd = HDPrivateKey.PrivateKeyStart + HDPrivateKey.PrivateKeySize;\nHDPrivateKey.ChecksumStart = HDPrivateKey.PrivateKeyEnd;\nHDPrivateKey.ChecksumEnd = HDPrivateKey.ChecksumStart + HDPrivateKey.CheckSumSize;\n\nassert(HDPrivateKey.ChecksumEnd === HDPrivateKey.SerializedByteSize);\n\nmodule.exports = HDPrivateKey;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}