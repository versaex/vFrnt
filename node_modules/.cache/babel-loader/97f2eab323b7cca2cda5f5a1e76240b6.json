{"ast":null,"code":"import { __values } from \"tslib\";\nimport { htmlTreeAsString } from './browser';\nimport { isElement, isError, isEvent, isInstanceOf, isPlainObject, isPrimitive, isSyntheticEvent } from './is';\nimport { Memo } from './memo';\nimport { getFunctionName } from './stacktrace';\nimport { truncate } from './string';\n/**\n * Wrap a given object method with a higher-order function\n *\n * @param source An object that contains a method to be wrapped.\n * @param name A name of method to be wrapped.\n * @param replacementFactory A function that should be used to wrap a given method, returning the wrapped method which\n * will be substituted in for `source[name]`.\n * @returns void\n */\nexport function fill(source, name, replacementFactory) {\n  if (!(name in source)) {\n    return;\n  }\n  var original = source[name];\n  var wrapped = replacementFactory(original);\n  // Make sure it's a function first, as we need to attach an empty prototype for `defineProperties` to work\n  // otherwise it'll throw \"TypeError: Object.defineProperties called on non-object\"\n  if (typeof wrapped === 'function') {\n    try {\n      wrapped.prototype = wrapped.prototype || {};\n      Object.defineProperties(wrapped, {\n        __sentry_original__: {\n          enumerable: false,\n          value: original\n        }\n      });\n    } catch (_Oo) {\n      // This can throw if multiple fill happens on a global object like XMLHttpRequest\n      // Fixes https://github.com/getsentry/sentry-javascript/issues/2043\n    }\n  }\n  source[name] = wrapped;\n}\n/**\n * Encodes given object into url-friendly format\n *\n * @param object An object that contains serializable values\n * @returns string Encoded\n */\nexport function urlEncode(object) {\n  return Object.keys(object).map(function (key) {\n    return encodeURIComponent(key) + \"=\" + encodeURIComponent(object[key]);\n  }).join('&');\n}\n/**\n * Transforms any object into an object literal with all its attributes\n * attached to it.\n *\n * @param value Initial source that we have to transform in order for it to be usable by the serializer\n */\nfunction getWalkSource(value) {\n  if (isError(value)) {\n    var error = value;\n    var err = {\n      message: error.message,\n      name: error.name,\n      stack: error.stack\n    };\n    for (var i in error) {\n      if (Object.prototype.hasOwnProperty.call(error, i)) {\n        err[i] = error[i];\n      }\n    }\n    return err;\n  }\n  if (isEvent(value)) {\n    var event_1 = value;\n    var source = {};\n    source.type = event_1.type;\n    // Accessing event.target can throw (see getsentry/raven-js#838, #768)\n    try {\n      source.target = isElement(event_1.target) ? htmlTreeAsString(event_1.target) : Object.prototype.toString.call(event_1.target);\n    } catch (_oO) {\n      source.target = '<unknown>';\n    }\n    try {\n      source.currentTarget = isElement(event_1.currentTarget) ? htmlTreeAsString(event_1.currentTarget) : Object.prototype.toString.call(event_1.currentTarget);\n    } catch (_oO) {\n      source.currentTarget = '<unknown>';\n    }\n    if (typeof CustomEvent !== 'undefined' && isInstanceOf(value, CustomEvent)) {\n      source.detail = event_1.detail;\n    }\n    for (var i in event_1) {\n      if (Object.prototype.hasOwnProperty.call(event_1, i)) {\n        source[i] = event_1;\n      }\n    }\n    return source;\n  }\n  return value;\n}\n/** Calculates bytes size of input string */\nfunction utf8Length(value) {\n  // eslint-disable-next-line no-bitwise\n  return ~-encodeURI(value).split(/%..|./).length;\n}\n/** Calculates bytes size of input object */\nfunction jsonSize(value) {\n  return utf8Length(JSON.stringify(value));\n}\n/** JSDoc */\nexport function normalizeToSize(object,\n// Default Node.js REPL depth\ndepth,\n// 100kB, as 200kB is max payload size, so half sounds reasonable\nmaxSize) {\n  if (depth === void 0) {\n    depth = 3;\n  }\n  if (maxSize === void 0) {\n    maxSize = 100 * 1024;\n  }\n  var serialized = normalize(object, depth);\n  if (jsonSize(serialized) > maxSize) {\n    return normalizeToSize(object, depth - 1, maxSize);\n  }\n  return serialized;\n}\n/**\n * Transform any non-primitive, BigInt, or Symbol-type value into a string. Acts as a no-op on strings, numbers,\n * booleans, null, and undefined.\n *\n * @param value The value to stringify\n * @returns For non-primitive, BigInt, and Symbol-type values, a string denoting the value's type, type and value, or\n *  type and `description` property, respectively. For non-BigInt, non-Symbol primitives, returns the original value,\n *  unchanged.\n */\nfunction serializeValue(value) {\n  var type = Object.prototype.toString.call(value);\n  // Node.js REPL notation\n  if (typeof value === 'string') {\n    return value;\n  }\n  if (type === '[object Object]') {\n    return '[Object]';\n  }\n  if (type === '[object Array]') {\n    return '[Array]';\n  }\n  var normalized = normalizeValue(value);\n  return isPrimitive(normalized) ? normalized : type;\n}\n/**\n * normalizeValue()\n *\n * Takes unserializable input and make it serializable friendly\n *\n * - translates undefined/NaN values to \"[undefined]\"/\"[NaN]\" respectively,\n * - serializes Error objects\n * - filter global objects\n */\nfunction normalizeValue(value, key) {\n  if (key === 'domain' && value && typeof value === 'object' && value._events) {\n    return '[Domain]';\n  }\n  if (key === 'domainEmitter') {\n    return '[DomainEmitter]';\n  }\n  if (typeof global !== 'undefined' && value === global) {\n    return '[Global]';\n  }\n  if (typeof window !== 'undefined' && value === window) {\n    return '[Window]';\n  }\n  if (typeof document !== 'undefined' && value === document) {\n    return '[Document]';\n  }\n  // React's SyntheticEvent thingy\n  if (isSyntheticEvent(value)) {\n    return '[SyntheticEvent]';\n  }\n  if (typeof value === 'number' && value !== value) {\n    return '[NaN]';\n  }\n  if (value === void 0) {\n    return '[undefined]';\n  }\n  if (typeof value === 'function') {\n    return \"[Function: \" + getFunctionName(value) + \"]\";\n  }\n  // symbols and bigints are considered primitives by TS, but aren't natively JSON-serilaizable\n  if (typeof value === 'symbol') {\n    return \"[\" + String(value) + \"]\";\n  }\n  if (typeof value === 'bigint') {\n    return \"[BigInt: \" + String(value) + \"]\";\n  }\n  return value;\n}\n/**\n * Walks an object to perform a normalization on it\n *\n * @param key of object that's walked in current iteration\n * @param value object to be walked\n * @param depth Optional number indicating how deep should walking be performed\n * @param memo Optional Memo class handling decycling\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function walk(key, value, depth, memo) {\n  if (depth === void 0) {\n    depth = +Infinity;\n  }\n  if (memo === void 0) {\n    memo = new Memo();\n  }\n  // If we reach the maximum depth, serialize whatever has left\n  if (depth === 0) {\n    return serializeValue(value);\n  }\n  /* eslint-disable @typescript-eslint/no-unsafe-member-access */\n  // If value implements `toJSON` method, call it and return early\n  if (value !== null && value !== undefined && typeof value.toJSON === 'function') {\n    return value.toJSON();\n  }\n  /* eslint-enable @typescript-eslint/no-unsafe-member-access */\n  // If normalized value is a primitive, there are no branches left to walk, so we can just bail out, as theres no point in going down that branch any further\n  var normalized = normalizeValue(value, key);\n  if (isPrimitive(normalized)) {\n    return normalized;\n  }\n  // Create source that we will use for next itterations, either objectified error object (Error type with extracted keys:value pairs) or the input itself\n  var source = getWalkSource(value);\n  // Create an accumulator that will act as a parent for all future itterations of that branch\n  var acc = Array.isArray(value) ? [] : {};\n  // If we already walked that branch, bail out, as it's circular reference\n  if (memo.memoize(value)) {\n    return '[Circular ~]';\n  }\n  // Walk all keys of the source\n  for (var innerKey in source) {\n    // Avoid iterating over fields in the prototype if they've somehow been exposed to enumeration.\n    if (!Object.prototype.hasOwnProperty.call(source, innerKey)) {\n      continue;\n    }\n    // Recursively walk through all the child nodes\n    acc[innerKey] = walk(innerKey, source[innerKey], depth - 1, memo);\n  }\n  // Once walked through all the branches, remove the parent from memo storage\n  memo.unmemoize(value);\n  // Return accumulated values\n  return acc;\n}\n/**\n * normalize()\n *\n * - Creates a copy to prevent original input mutation\n * - Skip non-enumerablers\n * - Calls `toJSON` if implemented\n * - Removes circular references\n * - Translates non-serializeable values (undefined/NaN/Functions) to serializable format\n * - Translates known global objects/Classes to a string representations\n * - Takes care of Error objects serialization\n * - Optionally limit depth of final output\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function normalize(input, depth) {\n  try {\n    return JSON.parse(JSON.stringify(input, function (key, value) {\n      return walk(key, value, depth);\n    }));\n  } catch (_oO) {\n    return '**non-serializable**';\n  }\n}\n/**\n * Given any captured exception, extract its keys and create a sorted\n * and truncated list that will be used inside the event message.\n * eg. `Non-error exception captured with keys: foo, bar, baz`\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function extractExceptionKeysForMessage(exception, maxLength) {\n  if (maxLength === void 0) {\n    maxLength = 40;\n  }\n  var keys = Object.keys(getWalkSource(exception));\n  keys.sort();\n  if (!keys.length) {\n    return '[object has no keys]';\n  }\n  if (keys[0].length >= maxLength) {\n    return truncate(keys[0], maxLength);\n  }\n  for (var includedKeys = keys.length; includedKeys > 0; includedKeys--) {\n    var serialized = keys.slice(0, includedKeys).join(', ');\n    if (serialized.length > maxLength) {\n      continue;\n    }\n    if (includedKeys === keys.length) {\n      return serialized;\n    }\n    return truncate(serialized, maxLength);\n  }\n  return '';\n}\n/**\n * Given any object, return the new object with removed keys that value was `undefined`.\n * Works recursively on objects and arrays.\n */\nexport function dropUndefinedKeys(val) {\n  var e_1, _a;\n  if (isPlainObject(val)) {\n    var obj = val;\n    var rv = {};\n    try {\n      for (var _b = __values(Object.keys(obj)), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var key = _c.value;\n        if (typeof obj[key] !== 'undefined') {\n          rv[key] = dropUndefinedKeys(obj[key]);\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n    return rv;\n  }\n  if (Array.isArray(val)) {\n    return val.map(dropUndefinedKeys);\n  }\n  return val;\n}","map":{"version":3,"sources":["../src/object.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { ExtendedError, WrappedFunction } from '@sentry/types';\n\nimport { htmlTreeAsString } from './browser';\nimport { isElement, isError, isEvent, isInstanceOf, isPlainObject, isPrimitive, isSyntheticEvent } from './is';\nimport { Memo } from './memo';\nimport { getFunctionName } from './stacktrace';\nimport { truncate } from './string';\n\n/**\n * Wrap a given object method with a higher-order function\n *\n * @param source An object that contains a method to be wrapped.\n * @param name A name of method to be wrapped.\n * @param replacementFactory A function that should be used to wrap a given method, returning the wrapped method which\n * will be substituted in for `source[name]`.\n * @returns void\n */\nexport function fill(source: { [key: string]: any }, name: string, replacementFactory: (...args: any[]) => any): void {\n  if (!(name in source)) {\n    return;\n  }\n\n  const original = source[name] as () => any;\n  const wrapped = replacementFactory(original) as WrappedFunction;\n\n  // Make sure it's a function first, as we need to attach an empty prototype for `defineProperties` to work\n  // otherwise it'll throw \"TypeError: Object.defineProperties called on non-object\"\n  if (typeof wrapped === 'function') {\n    try {\n      wrapped.prototype = wrapped.prototype || {};\n      Object.defineProperties(wrapped, {\n        __sentry_original__: {\n          enumerable: false,\n          value: original,\n        },\n      });\n    } catch (_Oo) {\n      // This can throw if multiple fill happens on a global object like XMLHttpRequest\n      // Fixes https://github.com/getsentry/sentry-javascript/issues/2043\n    }\n  }\n\n  source[name] = wrapped;\n}\n\n/**\n * Encodes given object into url-friendly format\n *\n * @param object An object that contains serializable values\n * @returns string Encoded\n */\nexport function urlEncode(object: { [key: string]: any }): string {\n  return Object.keys(object)\n    .map(key => `${encodeURIComponent(key)}=${encodeURIComponent(object[key])}`)\n    .join('&');\n}\n\n/**\n * Transforms any object into an object literal with all its attributes\n * attached to it.\n *\n * @param value Initial source that we have to transform in order for it to be usable by the serializer\n */\nfunction getWalkSource(\n  value: any,\n): {\n  [key: string]: any;\n} {\n  if (isError(value)) {\n    const error = value as ExtendedError;\n    const err: {\n      [key: string]: any;\n      stack: string | undefined;\n      message: string;\n      name: string;\n    } = {\n      message: error.message,\n      name: error.name,\n      stack: error.stack,\n    };\n\n    for (const i in error) {\n      if (Object.prototype.hasOwnProperty.call(error, i)) {\n        err[i] = error[i];\n      }\n    }\n\n    return err;\n  }\n\n  if (isEvent(value)) {\n    /**\n     * Event-like interface that's usable in browser and node\n     */\n    interface SimpleEvent {\n      [key: string]: unknown;\n      type: string;\n      target?: unknown;\n      currentTarget?: unknown;\n    }\n\n    const event = value as SimpleEvent;\n\n    const source: {\n      [key: string]: any;\n    } = {};\n\n    source.type = event.type;\n\n    // Accessing event.target can throw (see getsentry/raven-js#838, #768)\n    try {\n      source.target = isElement(event.target)\n        ? htmlTreeAsString(event.target)\n        : Object.prototype.toString.call(event.target);\n    } catch (_oO) {\n      source.target = '<unknown>';\n    }\n\n    try {\n      source.currentTarget = isElement(event.currentTarget)\n        ? htmlTreeAsString(event.currentTarget)\n        : Object.prototype.toString.call(event.currentTarget);\n    } catch (_oO) {\n      source.currentTarget = '<unknown>';\n    }\n\n    if (typeof CustomEvent !== 'undefined' && isInstanceOf(value, CustomEvent)) {\n      source.detail = event.detail;\n    }\n\n    for (const i in event) {\n      if (Object.prototype.hasOwnProperty.call(event, i)) {\n        source[i] = event;\n      }\n    }\n\n    return source;\n  }\n\n  return value as {\n    [key: string]: any;\n  };\n}\n\n/** Calculates bytes size of input string */\nfunction utf8Length(value: string): number {\n  // eslint-disable-next-line no-bitwise\n  return ~-encodeURI(value).split(/%..|./).length;\n}\n\n/** Calculates bytes size of input object */\nfunction jsonSize(value: any): number {\n  return utf8Length(JSON.stringify(value));\n}\n\n/** JSDoc */\nexport function normalizeToSize<T>(\n  object: { [key: string]: any },\n  // Default Node.js REPL depth\n  depth: number = 3,\n  // 100kB, as 200kB is max payload size, so half sounds reasonable\n  maxSize: number = 100 * 1024,\n): T {\n  const serialized = normalize(object, depth);\n\n  if (jsonSize(serialized) > maxSize) {\n    return normalizeToSize(object, depth - 1, maxSize);\n  }\n\n  return serialized as T;\n}\n\n/**\n * Transform any non-primitive, BigInt, or Symbol-type value into a string. Acts as a no-op on strings, numbers,\n * booleans, null, and undefined.\n *\n * @param value The value to stringify\n * @returns For non-primitive, BigInt, and Symbol-type values, a string denoting the value's type, type and value, or\n *  type and `description` property, respectively. For non-BigInt, non-Symbol primitives, returns the original value,\n *  unchanged.\n */\nfunction serializeValue(value: any): any {\n  const type = Object.prototype.toString.call(value);\n\n  // Node.js REPL notation\n  if (typeof value === 'string') {\n    return value;\n  }\n  if (type === '[object Object]') {\n    return '[Object]';\n  }\n  if (type === '[object Array]') {\n    return '[Array]';\n  }\n\n  const normalized = normalizeValue(value);\n  return isPrimitive(normalized) ? normalized : type;\n}\n\n/**\n * normalizeValue()\n *\n * Takes unserializable input and make it serializable friendly\n *\n * - translates undefined/NaN values to \"[undefined]\"/\"[NaN]\" respectively,\n * - serializes Error objects\n * - filter global objects\n */\nfunction normalizeValue<T>(value: T, key?: any): T | string {\n  if (key === 'domain' && value && typeof value === 'object' && ((value as unknown) as { _events: any })._events) {\n    return '[Domain]';\n  }\n\n  if (key === 'domainEmitter') {\n    return '[DomainEmitter]';\n  }\n\n  if (typeof (global as any) !== 'undefined' && (value as unknown) === global) {\n    return '[Global]';\n  }\n\n  if (typeof (window as any) !== 'undefined' && (value as unknown) === window) {\n    return '[Window]';\n  }\n\n  if (typeof (document as any) !== 'undefined' && (value as unknown) === document) {\n    return '[Document]';\n  }\n\n  // React's SyntheticEvent thingy\n  if (isSyntheticEvent(value)) {\n    return '[SyntheticEvent]';\n  }\n\n  if (typeof value === 'number' && value !== value) {\n    return '[NaN]';\n  }\n\n  if (value === void 0) {\n    return '[undefined]';\n  }\n\n  if (typeof value === 'function') {\n    return `[Function: ${getFunctionName(value)}]`;\n  }\n\n  // symbols and bigints are considered primitives by TS, but aren't natively JSON-serilaizable\n\n  if (typeof value === 'symbol') {\n    return `[${String(value)}]`;\n  }\n\n  if (typeof value === 'bigint') {\n    return `[BigInt: ${String(value)}]`;\n  }\n\n  return value;\n}\n\n/**\n * Walks an object to perform a normalization on it\n *\n * @param key of object that's walked in current iteration\n * @param value object to be walked\n * @param depth Optional number indicating how deep should walking be performed\n * @param memo Optional Memo class handling decycling\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function walk(key: string, value: any, depth: number = +Infinity, memo: Memo = new Memo()): any {\n  // If we reach the maximum depth, serialize whatever has left\n  if (depth === 0) {\n    return serializeValue(value);\n  }\n\n  /* eslint-disable @typescript-eslint/no-unsafe-member-access */\n  // If value implements `toJSON` method, call it and return early\n  if (value !== null && value !== undefined && typeof value.toJSON === 'function') {\n    return value.toJSON();\n  }\n  /* eslint-enable @typescript-eslint/no-unsafe-member-access */\n\n  // If normalized value is a primitive, there are no branches left to walk, so we can just bail out, as theres no point in going down that branch any further\n  const normalized = normalizeValue(value, key);\n  if (isPrimitive(normalized)) {\n    return normalized;\n  }\n\n  // Create source that we will use for next itterations, either objectified error object (Error type with extracted keys:value pairs) or the input itself\n  const source = getWalkSource(value);\n\n  // Create an accumulator that will act as a parent for all future itterations of that branch\n  const acc = Array.isArray(value) ? [] : {};\n\n  // If we already walked that branch, bail out, as it's circular reference\n  if (memo.memoize(value)) {\n    return '[Circular ~]';\n  }\n\n  // Walk all keys of the source\n  for (const innerKey in source) {\n    // Avoid iterating over fields in the prototype if they've somehow been exposed to enumeration.\n    if (!Object.prototype.hasOwnProperty.call(source, innerKey)) {\n      continue;\n    }\n    // Recursively walk through all the child nodes\n    (acc as { [key: string]: any })[innerKey] = walk(innerKey, source[innerKey], depth - 1, memo);\n  }\n\n  // Once walked through all the branches, remove the parent from memo storage\n  memo.unmemoize(value);\n\n  // Return accumulated values\n  return acc;\n}\n\n/**\n * normalize()\n *\n * - Creates a copy to prevent original input mutation\n * - Skip non-enumerablers\n * - Calls `toJSON` if implemented\n * - Removes circular references\n * - Translates non-serializeable values (undefined/NaN/Functions) to serializable format\n * - Translates known global objects/Classes to a string representations\n * - Takes care of Error objects serialization\n * - Optionally limit depth of final output\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function normalize(input: any, depth?: number): any {\n  try {\n    return JSON.parse(JSON.stringify(input, (key: string, value: any) => walk(key, value, depth)));\n  } catch (_oO) {\n    return '**non-serializable**';\n  }\n}\n\n/**\n * Given any captured exception, extract its keys and create a sorted\n * and truncated list that will be used inside the event message.\n * eg. `Non-error exception captured with keys: foo, bar, baz`\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function extractExceptionKeysForMessage(exception: any, maxLength: number = 40): string {\n  const keys = Object.keys(getWalkSource(exception));\n  keys.sort();\n\n  if (!keys.length) {\n    return '[object has no keys]';\n  }\n\n  if (keys[0].length >= maxLength) {\n    return truncate(keys[0], maxLength);\n  }\n\n  for (let includedKeys = keys.length; includedKeys > 0; includedKeys--) {\n    const serialized = keys.slice(0, includedKeys).join(', ');\n    if (serialized.length > maxLength) {\n      continue;\n    }\n    if (includedKeys === keys.length) {\n      return serialized;\n    }\n    return truncate(serialized, maxLength);\n  }\n\n  return '';\n}\n\n/**\n * Given any object, return the new object with removed keys that value was `undefined`.\n * Works recursively on objects and arrays.\n */\nexport function dropUndefinedKeys<T>(val: T): T {\n  if (isPlainObject(val)) {\n    const obj = val as { [key: string]: any };\n    const rv: { [key: string]: any } = {};\n    for (const key of Object.keys(obj)) {\n      if (typeof obj[key] !== 'undefined') {\n        rv[key] = dropUndefinedKeys(obj[key]);\n      }\n    }\n    return rv as T;\n  }\n\n  if (Array.isArray(val)) {\n    return (val as any[]).map(dropUndefinedKeys) as any;\n  }\n\n  return val;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}