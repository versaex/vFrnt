{"ast":null,"code":"import _isEqual from \"lodash/isEqual\";\nimport _sortBy from \"lodash/sortBy\";\nimport _isNaN from \"lodash/isNaN\";\nimport _isString from \"lodash/isString\";\nimport _isArray from \"lodash/isArray\";\nimport _max from \"lodash/max\";\nimport _min from \"lodash/min\";\nimport _flatMap from \"lodash/flatMap\";\nimport _isFunction from \"lodash/isFunction\";\nimport _get from \"lodash/get\";\nimport _isNil from \"lodash/isNil\";\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n}\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n}\nfunction _iterableToArray(iter) {\n  if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n}\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n    return arr2;\n  }\n}\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    if (enumerableOnly) symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    });\n    keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n    if (i % 2) {\n      ownKeys(source, true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(source).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n  return target;\n}\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nimport { getNiceTickValues, getTickValuesFixedDomain } from 'recharts-scale';\nimport * as d3Scales from 'd3-scale';\nimport { stack as shapeStack, stackOrderNone, stackOffsetExpand, stackOffsetNone, stackOffsetSilhouette, stackOffsetWiggle } from 'd3-shape';\nimport { isNumOrStr, uniqueId, isNumber, getPercentValue, mathSign, findEntryInArray } from './DataUtils';\nimport ErrorBar from '../cartesian/ErrorBar';\nimport Legend from '../component/Legend';\nimport { findAllByType, findChildByType, getDisplayName } from './ReactUtils';\nexport var getValueByDataKey = function getValueByDataKey(obj, dataKey, defaultValue) {\n  if (_isNil(obj) || _isNil(dataKey)) {\n    return defaultValue;\n  }\n  if (isNumOrStr(dataKey)) {\n    return _get(obj, dataKey, defaultValue);\n  }\n  if (_isFunction(dataKey)) {\n    return dataKey(obj);\n  }\n  return defaultValue;\n};\n/**\n * Get domain of data by key\n * @param  {Array}   data      The data displayed in the chart\n * @param  {String}  key       The unique key of a group of data\n * @param  {String}  type      The type of axis\n * @param  {Boolean} filterNil Whether or not filter nil values\n * @return {Array} Domain of data\n */\n\nexport var getDomainOfDataByKey = function getDomainOfDataByKey(data, key, type, filterNil) {\n  var flattenData = _flatMap(data, function (entry) {\n    return getValueByDataKey(entry, key);\n  });\n  if (type === 'number') {\n    var domain = flattenData.filter(function (entry) {\n      return isNumber(entry) || parseFloat(entry, 10);\n    });\n    return domain.length ? [_min(domain), _max(domain)] : [Infinity, -Infinity];\n  }\n  var validateData = filterNil ? flattenData.filter(function (entry) {\n    return !_isNil(entry);\n  }) : flattenData;\n  return validateData.map(function (entry) {\n    return isNumOrStr(entry) ? entry : '';\n  });\n};\nexport var calculateActiveTickIndex = function calculateActiveTickIndex(coordinate, ticks, unsortedTicks, axis) {\n  var index = -1;\n  var len = ticks.length;\n  if (len > 1) {\n    if (axis && axis.axisType === 'angleAxis' && Math.abs(Math.abs(axis.range[1] - axis.range[0]) - 360) <= 1e-6) {\n      var range = axis.range; // ticks are distributed in a circle\n\n      for (var i = 0; i < len; i++) {\n        var before = i > 0 ? unsortedTicks[i - 1].coordinate : unsortedTicks[len - 1].coordinate;\n        var cur = unsortedTicks[i].coordinate;\n        var after = i >= len - 1 ? unsortedTicks[0].coordinate : unsortedTicks[i + 1].coordinate;\n        var sameDirectionCoord = void 0;\n        if (mathSign(cur - before) !== mathSign(after - cur)) {\n          var diffInterval = [];\n          if (mathSign(after - cur) === mathSign(range[1] - range[0])) {\n            sameDirectionCoord = after;\n            var curInRange = cur + range[1] - range[0];\n            diffInterval[0] = Math.min(curInRange, (curInRange + before) / 2);\n            diffInterval[1] = Math.max(curInRange, (curInRange + before) / 2);\n          } else {\n            sameDirectionCoord = before;\n            var afterInRange = after + range[1] - range[0];\n            diffInterval[0] = Math.min(cur, (afterInRange + cur) / 2);\n            diffInterval[1] = Math.max(cur, (afterInRange + cur) / 2);\n          }\n          var sameInterval = [Math.min(cur, (sameDirectionCoord + cur) / 2), Math.max(cur, (sameDirectionCoord + cur) / 2)];\n          if (coordinate > sameInterval[0] && coordinate <= sameInterval[1] || coordinate >= diffInterval[0] && coordinate <= diffInterval[1]) {\n            index = unsortedTicks[i].index;\n            break;\n          }\n        } else {\n          var min = Math.min(before, after);\n          var max = Math.max(before, after);\n          if (coordinate > (min + cur) / 2 && coordinate <= (max + cur) / 2) {\n            index = unsortedTicks[i].index;\n            break;\n          }\n        }\n      }\n    } else {\n      // ticks are distributed in a single direction\n      for (var _i = 0; _i < len; _i++) {\n        if (_i === 0 && coordinate <= (ticks[_i].coordinate + ticks[_i + 1].coordinate) / 2 || _i > 0 && _i < len - 1 && coordinate > (ticks[_i].coordinate + ticks[_i - 1].coordinate) / 2 && coordinate <= (ticks[_i].coordinate + ticks[_i + 1].coordinate) / 2 || _i === len - 1 && coordinate > (ticks[_i].coordinate + ticks[_i - 1].coordinate) / 2) {\n          index = ticks[_i].index;\n          break;\n        }\n      }\n    }\n  } else {\n    index = 0;\n  }\n  return index;\n};\n/**\n * Get the main color of each graphic item\n * @param  {ReactElement} item A graphic item\n * @return {String}            Color\n */\n\nexport var getMainColorOfGraphicItem = function getMainColorOfGraphicItem(item) {\n  var displayName = item.type.displayName;\n  var _item$props = item.props,\n    stroke = _item$props.stroke,\n    fill = _item$props.fill;\n  var result;\n  switch (displayName) {\n    case 'Line':\n      result = stroke;\n      break;\n    case 'Area':\n    case 'Radar':\n      result = stroke && stroke !== 'none' ? stroke : fill;\n      break;\n    default:\n      result = fill;\n      break;\n  }\n  return result;\n};\nexport var getLegendProps = function getLegendProps(_ref) {\n  var children = _ref.children,\n    formatedGraphicalItems = _ref.formatedGraphicalItems,\n    legendWidth = _ref.legendWidth,\n    legendContent = _ref.legendContent;\n  var legendItem = findChildByType(children, Legend);\n  if (!legendItem) {\n    return null;\n  }\n  var legendData;\n  if (legendItem.props && legendItem.props.payload) {\n    legendData = legendItem.props && legendItem.props.payload;\n  } else if (legendContent === 'children') {\n    legendData = (formatedGraphicalItems || []).reduce(function (result, _ref2) {\n      var item = _ref2.item,\n        props = _ref2.props;\n      var data = props.sectors || props.data || [];\n      return result.concat(data.map(function (entry) {\n        return {\n          type: legendItem.props.iconType || item.props.legendType,\n          value: entry.name,\n          color: entry.fill,\n          payload: entry\n        };\n      }));\n    }, []);\n  } else {\n    legendData = (formatedGraphicalItems || []).map(function (_ref3) {\n      var item = _ref3.item;\n      var _item$props2 = item.props,\n        dataKey = _item$props2.dataKey,\n        name = _item$props2.name,\n        legendType = _item$props2.legendType,\n        hide = _item$props2.hide;\n      return {\n        inactive: hide,\n        dataKey: dataKey,\n        type: legendItem.props.iconType || legendType || 'square',\n        color: getMainColorOfGraphicItem(item),\n        value: name || dataKey,\n        payload: item.props\n      };\n    });\n  }\n  return _objectSpread({}, legendItem.props, {}, Legend.getWithHeight(legendItem, legendWidth), {\n    payload: legendData,\n    item: legendItem\n  });\n};\n/**\n * Calculate the size of all groups for stacked bar graph\n * @param  {Object} stackGroups The items grouped by axisId and stackId\n * @return {Object} The size of all groups\n */\n\nexport var getBarSizeList = function getBarSizeList(_ref4) {\n  var globalSize = _ref4.barSize,\n    _ref4$stackGroups = _ref4.stackGroups,\n    stackGroups = _ref4$stackGroups === void 0 ? {} : _ref4$stackGroups;\n  if (!stackGroups) {\n    return {};\n  }\n  var result = {};\n  var numericAxisIds = Object.keys(stackGroups);\n  for (var i = 0, len = numericAxisIds.length; i < len; i++) {\n    var sgs = stackGroups[numericAxisIds[i]].stackGroups;\n    var stackIds = Object.keys(sgs);\n    for (var j = 0, sLen = stackIds.length; j < sLen; j++) {\n      var _sgs$stackIds$j = sgs[stackIds[j]],\n        items = _sgs$stackIds$j.items,\n        cateAxisId = _sgs$stackIds$j.cateAxisId;\n      var barItems = items.filter(function (item) {\n        return getDisplayName(item.type).indexOf('Bar') >= 0;\n      });\n      if (barItems && barItems.length) {\n        var selfSize = barItems[0].props.barSize;\n        var cateId = barItems[0].props[cateAxisId];\n        if (!result[cateId]) {\n          result[cateId] = [];\n        }\n        result[cateId].push({\n          item: barItems[0],\n          stackList: barItems.slice(1),\n          barSize: _isNil(selfSize) ? globalSize : selfSize\n        });\n      }\n    }\n  }\n  return result;\n};\n/**\n   * Calculate the size of each bar and the gap between two bars\n   * @param  {Number} bandSize  The size of each category\n   * @param  {sizeList} sizeList  The size of all groups\n   * @param  {maxBarSize} maxBarSize The maximum size of bar\n   * @return {Number} The size of each bar and the gap between two bars\n   */\n\nexport var getBarPosition = function getBarPosition(_ref5) {\n  var barGap = _ref5.barGap,\n    barCategoryGap = _ref5.barCategoryGap,\n    bandSize = _ref5.bandSize,\n    _ref5$sizeList = _ref5.sizeList,\n    sizeList = _ref5$sizeList === void 0 ? [] : _ref5$sizeList,\n    maxBarSize = _ref5.maxBarSize;\n  var len = sizeList.length;\n  if (len < 1) return null;\n  var realBarGap = getPercentValue(barGap, bandSize, 0, true);\n  var result; // whether or not is barSize setted by user\n\n  if (sizeList[0].barSize === +sizeList[0].barSize) {\n    var useFull = false;\n    var fullBarSize = bandSize / len;\n    var sum = sizeList.reduce(function (res, entry) {\n      return res + entry.barSize || 0;\n    }, 0);\n    sum += (len - 1) * realBarGap;\n    if (sum >= bandSize) {\n      sum -= (len - 1) * realBarGap;\n      realBarGap = 0;\n    }\n    if (sum >= bandSize && fullBarSize > 0) {\n      useFull = true;\n      fullBarSize *= 0.9;\n      sum = len * fullBarSize;\n    }\n    var offset = (bandSize - sum) / 2 >> 0;\n    var prev = {\n      offset: offset - realBarGap,\n      size: 0\n    };\n    result = sizeList.reduce(function (res, entry) {\n      var newRes = [].concat(_toConsumableArray(res), [{\n        item: entry.item,\n        position: {\n          offset: prev.offset + prev.size + realBarGap,\n          size: useFull ? fullBarSize : entry.barSize\n        }\n      }]);\n      prev = newRes[newRes.length - 1].position;\n      if (entry.stackList && entry.stackList.length) {\n        entry.stackList.forEach(function (item) {\n          newRes.push({\n            item: item,\n            position: prev\n          });\n        });\n      }\n      return newRes;\n    }, []);\n  } else {\n    var _offset = getPercentValue(barCategoryGap, bandSize, 0, true);\n    if (bandSize - 2 * _offset - (len - 1) * realBarGap <= 0) {\n      realBarGap = 0;\n    }\n    var originalSize = (bandSize - 2 * _offset - (len - 1) * realBarGap) / len;\n    if (originalSize > 1) {\n      originalSize >>= 0;\n    }\n    var size = maxBarSize === +maxBarSize ? Math.min(originalSize, maxBarSize) : originalSize;\n    result = sizeList.reduce(function (res, entry, i) {\n      var newRes = [].concat(_toConsumableArray(res), [{\n        item: entry.item,\n        position: {\n          offset: _offset + (originalSize + realBarGap) * i + (originalSize - size) / 2,\n          size: size\n        }\n      }]);\n      if (entry.stackList && entry.stackList.length) {\n        entry.stackList.forEach(function (item) {\n          newRes.push({\n            item: item,\n            position: newRes[newRes.length - 1].position\n          });\n        });\n      }\n      return newRes;\n    }, []);\n  }\n  return result;\n};\nexport var appendOffsetOfLegend = function appendOffsetOfLegend(offset, items, props, legendBox) {\n  var children = props.children,\n    width = props.width,\n    height = props.height,\n    margin = props.margin;\n  var legendWidth = width - (margin.left || 0) - (margin.right || 0);\n  var legendHeight = height - (margin.top || 0) - (margin.bottom || 0);\n  var legendProps = getLegendProps({\n    children: children,\n    items: items,\n    legendWidth: legendWidth,\n    legendHeight: legendHeight\n  });\n  var newOffset = offset;\n  if (legendProps) {\n    var box = legendBox || {};\n    var align = legendProps.align,\n      verticalAlign = legendProps.verticalAlign,\n      layout = legendProps.layout;\n    if ((layout === 'vertical' || layout === 'horizontal' && verticalAlign === 'center') && isNumber(offset[align])) {\n      newOffset = _objectSpread({}, offset, _defineProperty({}, align, newOffset[align] + (box.width || 0)));\n    }\n    if ((layout === 'horizontal' || layout === 'vertical' && align === 'center') && isNumber(offset[verticalAlign])) {\n      newOffset = _objectSpread({}, offset, _defineProperty({}, verticalAlign, newOffset[verticalAlign] + (box.height || 0)));\n    }\n  }\n  return newOffset;\n};\nexport var getDomainOfErrorBars = function getDomainOfErrorBars(data, item, dataKey, axisType) {\n  var children = item.props.children;\n  var errorBars = findAllByType(children, ErrorBar).filter(function (errorBarChild) {\n    var direction = errorBarChild.props.direction;\n    return _isNil(direction) || _isNil(axisType) ? true : axisType.indexOf(direction) >= 0;\n  });\n  if (errorBars && errorBars.length) {\n    var keys = errorBars.map(function (errorBarChild) {\n      return errorBarChild.props.dataKey;\n    });\n    return data.reduce(function (result, entry) {\n      var entryValue = getValueByDataKey(entry, dataKey, 0);\n      var mainValue = _isArray(entryValue) ? [_min(entryValue), _max(entryValue)] : [entryValue, entryValue];\n      var errorDomain = keys.reduce(function (prevErrorArr, k) {\n        var errorValue = getValueByDataKey(entry, k, 0);\n        var lowerValue = mainValue[0] - Math.abs(_isArray(errorValue) ? errorValue[0] : errorValue);\n        var upperValue = mainValue[1] + Math.abs(_isArray(errorValue) ? errorValue[1] : errorValue);\n        return [Math.min(lowerValue, prevErrorArr[0]), Math.max(upperValue, prevErrorArr[1])];\n      }, [Infinity, -Infinity]);\n      return [Math.min(errorDomain[0], result[0]), Math.max(errorDomain[1], result[1])];\n    }, [Infinity, -Infinity]);\n  }\n  return null;\n};\nexport var parseErrorBarsOfAxis = function parseErrorBarsOfAxis(data, items, dataKey, axisType) {\n  var domains = items.map(function (item) {\n    return getDomainOfErrorBars(data, item, dataKey, axisType);\n  }).filter(function (entry) {\n    return !_isNil(entry);\n  });\n  if (domains && domains.length) {\n    return domains.reduce(function (result, entry) {\n      return [Math.min(result[0], entry[0]), Math.max(result[1], entry[1])];\n    }, [Infinity, -Infinity]);\n  }\n  return null;\n};\n/**\n * Get domain of data by the configuration of item element\n * @param  {Array}   data      The data displayed in the chart\n * @param  {Array}   items     The instances of item\n * @param  {String}  type      The type of axis, number - Number Axis, category - Category Axis\n * @param  {Boolean} filterNil Whether or not filter nil values\n * @return {Array}        Domain\n */\n\nexport var getDomainOfItemsWithSameAxis = function getDomainOfItemsWithSameAxis(data, items, type, filterNil) {\n  var domains = items.map(function (item) {\n    var dataKey = item.props.dataKey;\n    if (type === 'number' && dataKey) {\n      return getDomainOfErrorBars(data, item, dataKey) || getDomainOfDataByKey(data, dataKey, type, filterNil);\n    }\n    return getDomainOfDataByKey(data, dataKey, type, filterNil);\n  });\n  if (type === 'number') {\n    // Calculate the domain of number axis\n    return domains.reduce(function (result, entry) {\n      return [Math.min(result[0], entry[0]), Math.max(result[1], entry[1])];\n    }, [Infinity, -Infinity]);\n  }\n  var tag = {}; // Get the union set of category axis\n\n  return domains.reduce(function (result, entry) {\n    for (var i = 0, len = entry.length; i < len; i++) {\n      if (!tag[entry[i]]) {\n        tag[entry[i]] = true;\n        result.push(entry[i]);\n      }\n    }\n    return result;\n  }, []);\n};\nexport var isCategorialAxis = function isCategorialAxis(layout, axisType) {\n  return layout === 'horizontal' && axisType === 'xAxis' || layout === 'vertical' && axisType === 'yAxis' || layout === 'centric' && axisType === 'angleAxis' || layout === 'radial' && axisType === 'radiusAxis';\n};\n/**\n * Calculate the Coordinates of grid\n * @param  {Array} ticks The ticks in axis\n * @param {Number} min   The minimun value of axis\n * @param {Number} max   The maximun value of axis\n * @return {Array}       Coordinates\n */\n\nexport var getCoordinatesOfGrid = function getCoordinatesOfGrid(ticks, min, max) {\n  var hasMin, hasMax;\n  var values = ticks.map(function (entry) {\n    if (entry.coordinate === min) {\n      hasMin = true;\n    }\n    if (entry.coordinate === max) {\n      hasMax = true;\n    }\n    return entry.coordinate;\n  });\n  if (!hasMin) {\n    values.push(min);\n  }\n  if (!hasMax) {\n    values.push(max);\n  }\n  return values;\n};\n/**\n * Get the ticks of an axis\n * @param  {Object}  axis The configuration of an axis\n * @param {Boolean} isGrid Whether or not are the ticks in grid\n * @param {Boolean} isAll Return the ticks of all the points or not\n * @return {Array}  Ticks\n */\n\nexport var getTicksOfAxis = function getTicksOfAxis(axis, isGrid, isAll) {\n  if (!axis) return null;\n  var scale = axis.scale;\n  var duplicateDomain = axis.duplicateDomain,\n    type = axis.type,\n    range = axis.range;\n  var offset = (isGrid || isAll) && type === 'category' && scale.bandwidth ? scale.bandwidth() / 2 : 0;\n  offset = axis.axisType === 'angleAxis' ? mathSign(range[0] - range[1]) * 2 * offset : offset; // The ticks setted by user should only affect the ticks adjacent to axis line\n\n  if (isGrid && (axis.ticks || axis.niceTicks)) {\n    return (axis.ticks || axis.niceTicks).map(function (entry) {\n      var scaleContent = duplicateDomain ? duplicateDomain.indexOf(entry) : entry;\n      return {\n        coordinate: scale(scaleContent) + offset,\n        value: entry,\n        offset: offset\n      };\n    });\n  }\n  if (axis.isCategorial && axis.categoricalDomain) {\n    return axis.categoricalDomain.map(function (entry, index) {\n      return {\n        coordinate: scale(entry),\n        value: entry,\n        index: index,\n        offset: offset\n      };\n    });\n  }\n  if (scale.ticks && !isAll) {\n    return scale.ticks(axis.tickCount).map(function (entry) {\n      return {\n        coordinate: scale(entry) + offset,\n        value: entry,\n        offset: offset\n      };\n    });\n  } // When axis has duplicated text, serial numbers are used to generate scale\n\n  return scale.domain().map(function (entry, index) {\n    return {\n      coordinate: scale(entry) + offset,\n      value: duplicateDomain ? duplicateDomain[entry] : entry,\n      index: index,\n      offset: offset\n    };\n  });\n};\n/**\n * combine the handlers\n * @param  {Function} defaultHandler Internal private handler\n * @param  {Function} parentHandler  Handler function specified in parent component\n * @param  {Function} childHandler   Handler function specified in child component\n * @return {Function}                The combined handler\n */\n\nexport var combineEventHandlers = function combineEventHandlers(defaultHandler, parentHandler, childHandler) {\n  var customizedHandler;\n  if (_isFunction(childHandler)) {\n    customizedHandler = childHandler;\n  } else if (_isFunction(parentHandler)) {\n    customizedHandler = parentHandler;\n  }\n  if (_isFunction(defaultHandler) || customizedHandler) {\n    return function (arg1, arg2, arg3, arg4) {\n      if (_isFunction(defaultHandler)) {\n        defaultHandler(arg1, arg2, arg3, arg4);\n      }\n      if (_isFunction(customizedHandler)) {\n        customizedHandler(arg1, arg2, arg3, arg4);\n      }\n    };\n  }\n  return null;\n};\n/**\n * Parse the scale function of axis\n * @param  {Object}   axis          The option of axis\n * @param  {String}   chartType     The displayName of chart\n * @return {Function}               The scale funcion\n */\n\nexport var parseScale = function parseScale(axis, chartType) {\n  var scale = axis.scale,\n    type = axis.type,\n    layout = axis.layout,\n    axisType = axis.axisType;\n  if (scale === 'auto') {\n    if (layout === 'radial' && axisType === 'radiusAxis') {\n      return {\n        scale: d3Scales.scaleBand(),\n        realScaleType: 'band'\n      };\n    }\n    if (layout === 'radial' && axisType === 'angleAxis') {\n      return {\n        scale: d3Scales.scaleLinear(),\n        realScaleType: 'linear'\n      };\n    }\n    if (type === 'category' && chartType && (chartType.indexOf('LineChart') >= 0 || chartType.indexOf('AreaChart') >= 0)) {\n      return {\n        scale: d3Scales.scalePoint(),\n        realScaleType: 'point'\n      };\n    }\n    if (type === 'category') {\n      return {\n        scale: d3Scales.scaleBand(),\n        realScaleType: 'band'\n      };\n    }\n    return {\n      scale: d3Scales.scaleLinear(),\n      realScaleType: 'linear'\n    };\n  }\n  if (_isString(scale)) {\n    var name = \"scale\".concat(scale.slice(0, 1).toUpperCase()).concat(scale.slice(1));\n    return {\n      scale: (d3Scales[name] || d3Scales.scalePoint)(),\n      realScaleType: d3Scales[name] ? name : 'point'\n    };\n  }\n  return _isFunction(scale) ? {\n    scale: scale\n  } : {\n    scale: d3Scales.scalePoint(),\n    realScaleType: 'point'\n  };\n};\nvar EPS = 1e-4;\nexport var checkDomainOfScale = function checkDomainOfScale(scale) {\n  var domain = scale.domain();\n  if (!domain || domain.length <= 2) {\n    return;\n  }\n  var len = domain.length;\n  var range = scale.range();\n  var min = Math.min(range[0], range[1]) - EPS;\n  var max = Math.max(range[0], range[1]) + EPS;\n  var first = scale(domain[0]);\n  var last = scale(domain[len - 1]);\n  if (first < min || first > max || last < min || last > max) {\n    scale.domain([domain[0], domain[len - 1]]);\n  }\n};\nexport var findPositionOfBar = function findPositionOfBar(barPosition, child) {\n  if (!barPosition) {\n    return null;\n  }\n  for (var i = 0, len = barPosition.length; i < len; i++) {\n    if (barPosition[i].item === child) {\n      return barPosition[i].position;\n    }\n  }\n  return null;\n};\nexport var truncateByDomain = function truncateByDomain(value, domain) {\n  if (!domain || domain.length !== 2 || !isNumber(domain[0]) || !isNumber(domain[1])) {\n    return value;\n  }\n  var min = Math.min(domain[0], domain[1]);\n  var max = Math.max(domain[0], domain[1]);\n  var result = [value[0], value[1]];\n  if (!isNumber(value[0]) || value[0] < min) {\n    result[0] = min;\n  }\n  if (!isNumber(value[1]) || value[1] > max) {\n    result[1] = max;\n  }\n  if (result[0] > max) {\n    result[0] = max;\n  }\n  if (result[1] < min) {\n    result[1] = min;\n  }\n  return result;\n};\n/* eslint no-param-reassign: 0 */\n\nexport var offsetSign = function offsetSign(series) {\n  var n = series.length;\n  if (n <= 0) {\n    return;\n  }\n  for (var j = 0, m = series[0].length; j < m; ++j) {\n    var positive = 0;\n    var negative = 0;\n    for (var i = 0; i < n; ++i) {\n      var value = _isNaN(series[i][j][1]) ? series[i][j][0] : series[i][j][1];\n      /* eslint-disable prefer-destructuring */\n\n      if (value >= 0) {\n        series[i][j][0] = positive;\n        series[i][j][1] = positive + value;\n        positive = series[i][j][1];\n      } else {\n        series[i][j][0] = negative;\n        series[i][j][1] = negative + value;\n        negative = series[i][j][1];\n      }\n      /* eslint-enable prefer-destructuring */\n    }\n  }\n};\n\nvar STACK_OFFSET_MAP = {\n  sign: offsetSign,\n  expand: stackOffsetExpand,\n  none: stackOffsetNone,\n  silhouette: stackOffsetSilhouette,\n  wiggle: stackOffsetWiggle\n};\nexport var getStackedData = function getStackedData(data, stackItems, offsetType) {\n  var dataKeys = stackItems.map(function (item) {\n    return item.props.dataKey;\n  });\n  var stack = shapeStack().keys(dataKeys).value(function (d, key) {\n    return +getValueByDataKey(d, key, 0);\n  }).order(stackOrderNone).offset(STACK_OFFSET_MAP[offsetType]);\n  return stack(data);\n};\nexport var getStackGroupsByAxisId = function getStackGroupsByAxisId(data, _items, numericAxisId, cateAxisId, offsetType, reverseStackOrder) {\n  if (!data) {\n    return null;\n  } // reversing items to affect render order (for layering)\n\n  var items = reverseStackOrder ? _items.reverse() : _items;\n  var stackGroups = items.reduce(function (result, item) {\n    var _item$props3 = item.props,\n      stackId = _item$props3.stackId,\n      hide = _item$props3.hide;\n    if (hide) {\n      return result;\n    }\n    var axisId = item.props[numericAxisId];\n    var parentGroup = result[axisId] || {\n      hasStack: false,\n      stackGroups: {}\n    };\n    if (isNumOrStr(stackId)) {\n      var childGroup = parentGroup.stackGroups[stackId] || {\n        numericAxisId: numericAxisId,\n        cateAxisId: cateAxisId,\n        items: []\n      };\n      childGroup.items.push(item);\n      parentGroup.hasStack = true;\n      parentGroup.stackGroups[stackId] = childGroup;\n    } else {\n      parentGroup.stackGroups[uniqueId('_stackId_')] = {\n        numericAxisId: numericAxisId,\n        cateAxisId: cateAxisId,\n        items: [item]\n      };\n    }\n    return _objectSpread({}, result, _defineProperty({}, axisId, parentGroup));\n  }, {});\n  return Object.keys(stackGroups).reduce(function (result, axisId) {\n    var group = stackGroups[axisId];\n    if (group.hasStack) {\n      group.stackGroups = Object.keys(group.stackGroups).reduce(function (res, stackId) {\n        var g = group.stackGroups[stackId];\n        return _objectSpread({}, res, _defineProperty({}, stackId, {\n          numericAxisId: numericAxisId,\n          cateAxisId: cateAxisId,\n          items: g.items,\n          stackedData: getStackedData(data, g.items, offsetType)\n        }));\n      }, {});\n    }\n    return _objectSpread({}, result, _defineProperty({}, axisId, group));\n  }, {});\n};\n/**\n * get domain of ticks\n * @param  {Array} ticks Ticks of axis\n * @param  {String} type  The type of axis\n * @return {Array} domain\n */\n\nexport var calculateDomainOfTicks = function calculateDomainOfTicks(ticks, type) {\n  if (type === 'number') {\n    return [_min(ticks), _max(ticks)];\n  }\n  return ticks;\n};\n/**\n * Configure the scale function of axis\n * @param {Object} scale The scale function\n * @param {Object} opts  The configuration of axis\n * @return {Object}      null\n */\n\nexport var getTicksOfScale = function getTicksOfScale(scale, opts) {\n  var realScaleType = opts.realScaleType,\n    type = opts.type,\n    tickCount = opts.tickCount,\n    originalDomain = opts.originalDomain,\n    allowDecimals = opts.allowDecimals;\n  var scaleType = realScaleType || opts.scale;\n  if (scaleType !== 'auto' && scaleType !== 'linear') {\n    return null;\n  }\n  if (tickCount && type === 'number' && originalDomain && (originalDomain[0] === 'auto' || originalDomain[1] === 'auto')) {\n    // Calculate the ticks by the number of grid when the axis is a number axis\n    var domain = scale.domain();\n    var tickValues = getNiceTickValues(domain, tickCount, allowDecimals);\n    scale.domain(calculateDomainOfTicks(tickValues, type));\n    return {\n      niceTicks: tickValues\n    };\n  }\n  if (tickCount && type === 'number') {\n    var _domain = scale.domain();\n    var _tickValues = getTickValuesFixedDomain(_domain, tickCount, allowDecimals);\n    return {\n      niceTicks: _tickValues\n    };\n  }\n  return null;\n};\nexport var getCateCoordinateOfLine = function getCateCoordinateOfLine(_ref6) {\n  var axis = _ref6.axis,\n    ticks = _ref6.ticks,\n    bandSize = _ref6.bandSize,\n    entry = _ref6.entry,\n    index = _ref6.index,\n    dataKey = _ref6.dataKey;\n  if (axis.type === 'category') {\n    // find coordinate of category axis by the value of category\n    if (!axis.allowDuplicatedCategory && axis.dataKey && !_isNil(entry[axis.dataKey])) {\n      var matchedTick = findEntryInArray(ticks, 'value', entry[axis.dataKey]);\n      if (matchedTick) {\n        return matchedTick.coordinate + bandSize / 2;\n      }\n    }\n    return ticks[index] ? ticks[index].coordinate + bandSize / 2 : null;\n  }\n  var value = getValueByDataKey(entry, !_isNil(dataKey) ? dataKey : axis.dataKey);\n  return !_isNil(value) ? axis.scale(value) : null;\n};\nexport var getCateCoordinateOfBar = function getCateCoordinateOfBar(_ref7) {\n  var axis = _ref7.axis,\n    ticks = _ref7.ticks,\n    offset = _ref7.offset,\n    bandSize = _ref7.bandSize,\n    entry = _ref7.entry,\n    index = _ref7.index;\n  if (axis.type === 'category') {\n    return ticks[index] ? ticks[index].coordinate + offset : null;\n  }\n  var value = getValueByDataKey(entry, axis.dataKey, axis.domain[index]);\n  return !_isNil(value) ? axis.scale(value) - bandSize / 2 + offset : null;\n};\nexport var getBaseValueOfBar = function getBaseValueOfBar(_ref8) {\n  var numericAxis = _ref8.numericAxis;\n  var domain = numericAxis.scale.domain();\n  if (numericAxis.type === 'number') {\n    var min = Math.min(domain[0], domain[1]);\n    var max = Math.max(domain[0], domain[1]);\n    if (min <= 0 && max >= 0) {\n      return 0;\n    }\n    if (max < 0) {\n      return max;\n    }\n    return min;\n  }\n  return domain[0];\n};\nexport var getStackedDataOfItem = function getStackedDataOfItem(item, stackGroups) {\n  var stackId = item.props.stackId;\n  if (isNumOrStr(stackId)) {\n    var group = stackGroups[stackId];\n    if (group && group.items.length) {\n      var itemIndex = -1;\n      for (var i = 0, len = group.items.length; i < len; i++) {\n        if (group.items[i] === item) {\n          itemIndex = i;\n          break;\n        }\n      }\n      return itemIndex >= 0 ? group.stackedData[itemIndex] : null;\n    }\n  }\n  return null;\n};\nvar getDomainOfSingle = function getDomainOfSingle(data) {\n  return data.reduce(function (result, entry) {\n    return [_min(entry.concat([result[0]]).filter(isNumber)), _max(entry.concat([result[1]]).filter(isNumber))];\n  }, [Infinity, -Infinity]);\n};\nexport var getDomainOfStackGroups = function getDomainOfStackGroups(stackGroups, startIndex, endIndex) {\n  return Object.keys(stackGroups).reduce(function (result, stackId) {\n    var group = stackGroups[stackId];\n    var stackedData = group.stackedData;\n    var domain = stackedData.reduce(function (res, entry) {\n      var s = getDomainOfSingle(entry.slice(startIndex, endIndex + 1));\n      return [Math.min(res[0], s[0]), Math.max(res[1], s[1])];\n    }, [Infinity, -Infinity]);\n    return [Math.min(domain[0], result[0]), Math.max(domain[1], result[1])];\n  }, [Infinity, -Infinity]).map(function (result) {\n    return result === Infinity || result === -Infinity ? 0 : result;\n  });\n};\nexport var MIN_VALUE_REG = /^dataMin[\\s]*-[\\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;\nexport var MAX_VALUE_REG = /^dataMax[\\s]*\\+[\\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;\nexport var parseSpecifiedDomain = function parseSpecifiedDomain(specifiedDomain, dataDomain, allowDataOverflow) {\n  if (!_isArray(specifiedDomain)) {\n    return dataDomain;\n  }\n  var domain = [];\n  /* eslint-disable prefer-destructuring */\n\n  if (isNumber(specifiedDomain[0])) {\n    domain[0] = allowDataOverflow ? specifiedDomain[0] : Math.min(specifiedDomain[0], dataDomain[0]);\n  } else if (MIN_VALUE_REG.test(specifiedDomain[0])) {\n    var value = +MIN_VALUE_REG.exec(specifiedDomain[0])[1];\n    domain[0] = dataDomain[0] - value;\n  } else if (_isFunction(specifiedDomain[0])) {\n    domain[0] = specifiedDomain[0](dataDomain[0]);\n  } else {\n    domain[0] = dataDomain[0];\n  }\n  if (isNumber(specifiedDomain[1])) {\n    domain[1] = allowDataOverflow ? specifiedDomain[1] : Math.max(specifiedDomain[1], dataDomain[1]);\n  } else if (MAX_VALUE_REG.test(specifiedDomain[1])) {\n    var _value = +MAX_VALUE_REG.exec(specifiedDomain[1])[1];\n    domain[1] = dataDomain[1] + _value;\n  } else if (_isFunction(specifiedDomain[1])) {\n    domain[1] = specifiedDomain[1](dataDomain[1]);\n  } else {\n    domain[1] = dataDomain[1];\n  }\n  /* eslint-enable prefer-destructuring */\n\n  return domain;\n};\n/**\n * Calculate the size between two category\n * @param  {Object} axis  The options of axis\n * @param  {Array}  ticks The ticks of axis\n * @return {Number} Size\n */\n\nexport var getBandSizeOfAxis = function getBandSizeOfAxis(axis, ticks) {\n  if (axis && axis.scale && axis.scale.bandwidth) {\n    return axis.scale.bandwidth();\n  }\n  if (axis && ticks && ticks.length >= 2) {\n    var orderedTicks = _sortBy(ticks, function (o) {\n      return o.coordinate;\n    });\n    var bandSize = Infinity;\n    for (var i = 1, len = orderedTicks.length; i < len; i++) {\n      var cur = orderedTicks[i];\n      var prev = orderedTicks[i - 1];\n      bandSize = Math.min((cur.coordinate || 0) - (prev.coordinate || 0), bandSize);\n    }\n    return bandSize === Infinity ? 0 : bandSize;\n  }\n  return 0;\n};\n/**\n * parse the domain of a category axis when a domain is specified\n * @param   {Array}        specifiedDomain  The domain specified by users\n * @param   {Array}        calculatedDomain The domain calculated by dateKey\n * @param   {ReactElement} axisChild        The axis element\n * @returns {Array}        domains\n */\n\nexport var parseDomainOfCategoryAxis = function parseDomainOfCategoryAxis(specifiedDomain, calculatedDomain, axisChild) {\n  if (!specifiedDomain || !specifiedDomain.length) {\n    return calculatedDomain;\n  }\n  if (_isEqual(specifiedDomain, _get(axisChild, 'type.defaultProps.domain'))) {\n    return calculatedDomain;\n  }\n  return specifiedDomain;\n};","map":{"version":3,"names":["_isEqual","_sortBy","_isNaN","_isString","_isArray","_max","_min","_flatMap","_isFunction","_get","_isNil","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","Object","prototype","toString","call","Array","from","isArray","i","arr2","length","ownKeys","object","enumerableOnly","keys","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","apply","_objectSpread","target","arguments","source","forEach","key","_defineProperty","getOwnPropertyDescriptors","defineProperties","defineProperty","obj","value","configurable","writable","getNiceTickValues","getTickValuesFixedDomain","d3Scales","stack","shapeStack","stackOrderNone","stackOffsetExpand","stackOffsetNone","stackOffsetSilhouette","stackOffsetWiggle","isNumOrStr","uniqueId","isNumber","getPercentValue","mathSign","findEntryInArray","ErrorBar","Legend","findAllByType","findChildByType","getDisplayName","getValueByDataKey","dataKey","defaultValue","getDomainOfDataByKey","data","type","filterNil","flattenData","entry","domain","parseFloat","Infinity","validateData","map","calculateActiveTickIndex","coordinate","ticks","unsortedTicks","axis","index","len","axisType","Math","abs","range","before","cur","after","sameDirectionCoord","diffInterval","curInRange","min","max","afterInRange","sameInterval","_i","getMainColorOfGraphicItem","item","displayName","_item$props","props","stroke","fill","result","getLegendProps","_ref","children","formatedGraphicalItems","legendWidth","legendContent","legendItem","legendData","payload","reduce","_ref2","sectors","concat","iconType","legendType","name","color","_ref3","_item$props2","hide","inactive","getWithHeight","getBarSizeList","_ref4","globalSize","barSize","_ref4$stackGroups","stackGroups","numericAxisIds","sgs","stackIds","j","sLen","_sgs$stackIds$j","items","cateAxisId","barItems","indexOf","selfSize","cateId","stackList","slice","getBarPosition","_ref5","barGap","barCategoryGap","bandSize","_ref5$sizeList","sizeList","maxBarSize","realBarGap","useFull","fullBarSize","sum","res","offset","prev","size","newRes","position","_offset","originalSize","appendOffsetOfLegend","legendBox","width","height","margin","left","right","legendHeight","top","bottom","legendProps","newOffset","box","align","verticalAlign","layout","getDomainOfErrorBars","errorBars","errorBarChild","direction","entryValue","mainValue","errorDomain","prevErrorArr","k","errorValue","lowerValue","upperValue","parseErrorBarsOfAxis","domains","getDomainOfItemsWithSameAxis","tag","isCategorialAxis","getCoordinatesOfGrid","hasMin","hasMax","values","getTicksOfAxis","isGrid","isAll","scale","duplicateDomain","bandwidth","niceTicks","scaleContent","isCategorial","categoricalDomain","tickCount","combineEventHandlers","defaultHandler","parentHandler","childHandler","customizedHandler","arg1","arg2","arg3","arg4","parseScale","chartType","scaleBand","realScaleType","scaleLinear","scalePoint","toUpperCase","EPS","checkDomainOfScale","first","last","findPositionOfBar","barPosition","child","truncateByDomain","offsetSign","series","n","m","positive","negative","STACK_OFFSET_MAP","sign","expand","none","silhouette","wiggle","getStackedData","stackItems","offsetType","dataKeys","d","order","getStackGroupsByAxisId","_items","numericAxisId","reverseStackOrder","reverse","_item$props3","stackId","axisId","parentGroup","hasStack","childGroup","group","g","stackedData","calculateDomainOfTicks","getTicksOfScale","opts","originalDomain","allowDecimals","scaleType","tickValues","_domain","_tickValues","getCateCoordinateOfLine","_ref6","allowDuplicatedCategory","matchedTick","getCateCoordinateOfBar","_ref7","getBaseValueOfBar","_ref8","numericAxis","getStackedDataOfItem","itemIndex","getDomainOfSingle","getDomainOfStackGroups","startIndex","endIndex","s","MIN_VALUE_REG","MAX_VALUE_REG","parseSpecifiedDomain","specifiedDomain","dataDomain","allowDataOverflow","test","exec","_value","getBandSizeOfAxis","orderedTicks","o","parseDomainOfCategoryAxis","calculatedDomain","axisChild"],"sources":["C:/Users/Elton/OneDrive/Desktop/baseapp-2024/node_modules/recharts/es6/util/ChartUtils.js"],"sourcesContent":["import _isEqual from \"lodash/isEqual\";\nimport _sortBy from \"lodash/sortBy\";\nimport _isNaN from \"lodash/isNaN\";\nimport _isString from \"lodash/isString\";\nimport _isArray from \"lodash/isArray\";\nimport _max from \"lodash/max\";\nimport _min from \"lodash/min\";\nimport _flatMap from \"lodash/flatMap\";\nimport _isFunction from \"lodash/isFunction\";\nimport _get from \"lodash/get\";\nimport _isNil from \"lodash/isNil\";\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { getNiceTickValues, getTickValuesFixedDomain } from 'recharts-scale';\nimport * as d3Scales from 'd3-scale';\nimport { stack as shapeStack, stackOrderNone, stackOffsetExpand, stackOffsetNone, stackOffsetSilhouette, stackOffsetWiggle } from 'd3-shape';\nimport { isNumOrStr, uniqueId, isNumber, getPercentValue, mathSign, findEntryInArray } from './DataUtils';\nimport ErrorBar from '../cartesian/ErrorBar';\nimport Legend from '../component/Legend';\nimport { findAllByType, findChildByType, getDisplayName } from './ReactUtils';\nexport var getValueByDataKey = function getValueByDataKey(obj, dataKey, defaultValue) {\n  if (_isNil(obj) || _isNil(dataKey)) {\n    return defaultValue;\n  }\n\n  if (isNumOrStr(dataKey)) {\n    return _get(obj, dataKey, defaultValue);\n  }\n\n  if (_isFunction(dataKey)) {\n    return dataKey(obj);\n  }\n\n  return defaultValue;\n};\n/**\n * Get domain of data by key\n * @param  {Array}   data      The data displayed in the chart\n * @param  {String}  key       The unique key of a group of data\n * @param  {String}  type      The type of axis\n * @param  {Boolean} filterNil Whether or not filter nil values\n * @return {Array} Domain of data\n */\n\nexport var getDomainOfDataByKey = function getDomainOfDataByKey(data, key, type, filterNil) {\n  var flattenData = _flatMap(data, function (entry) {\n    return getValueByDataKey(entry, key);\n  });\n\n  if (type === 'number') {\n    var domain = flattenData.filter(function (entry) {\n      return isNumber(entry) || parseFloat(entry, 10);\n    });\n    return domain.length ? [_min(domain), _max(domain)] : [Infinity, -Infinity];\n  }\n\n  var validateData = filterNil ? flattenData.filter(function (entry) {\n    return !_isNil(entry);\n  }) : flattenData;\n  return validateData.map(function (entry) {\n    return isNumOrStr(entry) ? entry : '';\n  });\n};\nexport var calculateActiveTickIndex = function calculateActiveTickIndex(coordinate, ticks, unsortedTicks, axis) {\n  var index = -1;\n  var len = ticks.length;\n\n  if (len > 1) {\n    if (axis && axis.axisType === 'angleAxis' && Math.abs(Math.abs(axis.range[1] - axis.range[0]) - 360) <= 1e-6) {\n      var range = axis.range; // ticks are distributed in a circle\n\n      for (var i = 0; i < len; i++) {\n        var before = i > 0 ? unsortedTicks[i - 1].coordinate : unsortedTicks[len - 1].coordinate;\n        var cur = unsortedTicks[i].coordinate;\n        var after = i >= len - 1 ? unsortedTicks[0].coordinate : unsortedTicks[i + 1].coordinate;\n        var sameDirectionCoord = void 0;\n\n        if (mathSign(cur - before) !== mathSign(after - cur)) {\n          var diffInterval = [];\n\n          if (mathSign(after - cur) === mathSign(range[1] - range[0])) {\n            sameDirectionCoord = after;\n            var curInRange = cur + range[1] - range[0];\n            diffInterval[0] = Math.min(curInRange, (curInRange + before) / 2);\n            diffInterval[1] = Math.max(curInRange, (curInRange + before) / 2);\n          } else {\n            sameDirectionCoord = before;\n            var afterInRange = after + range[1] - range[0];\n            diffInterval[0] = Math.min(cur, (afterInRange + cur) / 2);\n            diffInterval[1] = Math.max(cur, (afterInRange + cur) / 2);\n          }\n\n          var sameInterval = [Math.min(cur, (sameDirectionCoord + cur) / 2), Math.max(cur, (sameDirectionCoord + cur) / 2)];\n\n          if (coordinate > sameInterval[0] && coordinate <= sameInterval[1] || coordinate >= diffInterval[0] && coordinate <= diffInterval[1]) {\n            index = unsortedTicks[i].index;\n            break;\n          }\n        } else {\n          var min = Math.min(before, after);\n          var max = Math.max(before, after);\n\n          if (coordinate > (min + cur) / 2 && coordinate <= (max + cur) / 2) {\n            index = unsortedTicks[i].index;\n            break;\n          }\n        }\n      }\n    } else {\n      // ticks are distributed in a single direction\n      for (var _i = 0; _i < len; _i++) {\n        if (_i === 0 && coordinate <= (ticks[_i].coordinate + ticks[_i + 1].coordinate) / 2 || _i > 0 && _i < len - 1 && coordinate > (ticks[_i].coordinate + ticks[_i - 1].coordinate) / 2 && coordinate <= (ticks[_i].coordinate + ticks[_i + 1].coordinate) / 2 || _i === len - 1 && coordinate > (ticks[_i].coordinate + ticks[_i - 1].coordinate) / 2) {\n          index = ticks[_i].index;\n          break;\n        }\n      }\n    }\n  } else {\n    index = 0;\n  }\n\n  return index;\n};\n/**\n * Get the main color of each graphic item\n * @param  {ReactElement} item A graphic item\n * @return {String}            Color\n */\n\nexport var getMainColorOfGraphicItem = function getMainColorOfGraphicItem(item) {\n  var displayName = item.type.displayName;\n  var _item$props = item.props,\n      stroke = _item$props.stroke,\n      fill = _item$props.fill;\n  var result;\n\n  switch (displayName) {\n    case 'Line':\n      result = stroke;\n      break;\n\n    case 'Area':\n    case 'Radar':\n      result = stroke && stroke !== 'none' ? stroke : fill;\n      break;\n\n    default:\n      result = fill;\n      break;\n  }\n\n  return result;\n};\nexport var getLegendProps = function getLegendProps(_ref) {\n  var children = _ref.children,\n      formatedGraphicalItems = _ref.formatedGraphicalItems,\n      legendWidth = _ref.legendWidth,\n      legendContent = _ref.legendContent;\n  var legendItem = findChildByType(children, Legend);\n\n  if (!legendItem) {\n    return null;\n  }\n\n  var legendData;\n\n  if (legendItem.props && legendItem.props.payload) {\n    legendData = legendItem.props && legendItem.props.payload;\n  } else if (legendContent === 'children') {\n    legendData = (formatedGraphicalItems || []).reduce(function (result, _ref2) {\n      var item = _ref2.item,\n          props = _ref2.props;\n      var data = props.sectors || props.data || [];\n      return result.concat(data.map(function (entry) {\n        return {\n          type: legendItem.props.iconType || item.props.legendType,\n          value: entry.name,\n          color: entry.fill,\n          payload: entry\n        };\n      }));\n    }, []);\n  } else {\n    legendData = (formatedGraphicalItems || []).map(function (_ref3) {\n      var item = _ref3.item;\n      var _item$props2 = item.props,\n          dataKey = _item$props2.dataKey,\n          name = _item$props2.name,\n          legendType = _item$props2.legendType,\n          hide = _item$props2.hide;\n      return {\n        inactive: hide,\n        dataKey: dataKey,\n        type: legendItem.props.iconType || legendType || 'square',\n        color: getMainColorOfGraphicItem(item),\n        value: name || dataKey,\n        payload: item.props\n      };\n    });\n  }\n\n  return _objectSpread({}, legendItem.props, {}, Legend.getWithHeight(legendItem, legendWidth), {\n    payload: legendData,\n    item: legendItem\n  });\n};\n/**\n * Calculate the size of all groups for stacked bar graph\n * @param  {Object} stackGroups The items grouped by axisId and stackId\n * @return {Object} The size of all groups\n */\n\nexport var getBarSizeList = function getBarSizeList(_ref4) {\n  var globalSize = _ref4.barSize,\n      _ref4$stackGroups = _ref4.stackGroups,\n      stackGroups = _ref4$stackGroups === void 0 ? {} : _ref4$stackGroups;\n\n  if (!stackGroups) {\n    return {};\n  }\n\n  var result = {};\n  var numericAxisIds = Object.keys(stackGroups);\n\n  for (var i = 0, len = numericAxisIds.length; i < len; i++) {\n    var sgs = stackGroups[numericAxisIds[i]].stackGroups;\n    var stackIds = Object.keys(sgs);\n\n    for (var j = 0, sLen = stackIds.length; j < sLen; j++) {\n      var _sgs$stackIds$j = sgs[stackIds[j]],\n          items = _sgs$stackIds$j.items,\n          cateAxisId = _sgs$stackIds$j.cateAxisId;\n      var barItems = items.filter(function (item) {\n        return getDisplayName(item.type).indexOf('Bar') >= 0;\n      });\n\n      if (barItems && barItems.length) {\n        var selfSize = barItems[0].props.barSize;\n        var cateId = barItems[0].props[cateAxisId];\n\n        if (!result[cateId]) {\n          result[cateId] = [];\n        }\n\n        result[cateId].push({\n          item: barItems[0],\n          stackList: barItems.slice(1),\n          barSize: _isNil(selfSize) ? globalSize : selfSize\n        });\n      }\n    }\n  }\n\n  return result;\n};\n/**\n   * Calculate the size of each bar and the gap between two bars\n   * @param  {Number} bandSize  The size of each category\n   * @param  {sizeList} sizeList  The size of all groups\n   * @param  {maxBarSize} maxBarSize The maximum size of bar\n   * @return {Number} The size of each bar and the gap between two bars\n   */\n\nexport var getBarPosition = function getBarPosition(_ref5) {\n  var barGap = _ref5.barGap,\n      barCategoryGap = _ref5.barCategoryGap,\n      bandSize = _ref5.bandSize,\n      _ref5$sizeList = _ref5.sizeList,\n      sizeList = _ref5$sizeList === void 0 ? [] : _ref5$sizeList,\n      maxBarSize = _ref5.maxBarSize;\n  var len = sizeList.length;\n  if (len < 1) return null;\n  var realBarGap = getPercentValue(barGap, bandSize, 0, true);\n  var result; // whether or not is barSize setted by user\n\n  if (sizeList[0].barSize === +sizeList[0].barSize) {\n    var useFull = false;\n    var fullBarSize = bandSize / len;\n    var sum = sizeList.reduce(function (res, entry) {\n      return res + entry.barSize || 0;\n    }, 0);\n    sum += (len - 1) * realBarGap;\n\n    if (sum >= bandSize) {\n      sum -= (len - 1) * realBarGap;\n      realBarGap = 0;\n    }\n\n    if (sum >= bandSize && fullBarSize > 0) {\n      useFull = true;\n      fullBarSize *= 0.9;\n      sum = len * fullBarSize;\n    }\n\n    var offset = (bandSize - sum) / 2 >> 0;\n    var prev = {\n      offset: offset - realBarGap,\n      size: 0\n    };\n    result = sizeList.reduce(function (res, entry) {\n      var newRes = [].concat(_toConsumableArray(res), [{\n        item: entry.item,\n        position: {\n          offset: prev.offset + prev.size + realBarGap,\n          size: useFull ? fullBarSize : entry.barSize\n        }\n      }]);\n      prev = newRes[newRes.length - 1].position;\n\n      if (entry.stackList && entry.stackList.length) {\n        entry.stackList.forEach(function (item) {\n          newRes.push({\n            item: item,\n            position: prev\n          });\n        });\n      }\n\n      return newRes;\n    }, []);\n  } else {\n    var _offset = getPercentValue(barCategoryGap, bandSize, 0, true);\n\n    if (bandSize - 2 * _offset - (len - 1) * realBarGap <= 0) {\n      realBarGap = 0;\n    }\n\n    var originalSize = (bandSize - 2 * _offset - (len - 1) * realBarGap) / len;\n\n    if (originalSize > 1) {\n      originalSize >>= 0;\n    }\n\n    var size = maxBarSize === +maxBarSize ? Math.min(originalSize, maxBarSize) : originalSize;\n    result = sizeList.reduce(function (res, entry, i) {\n      var newRes = [].concat(_toConsumableArray(res), [{\n        item: entry.item,\n        position: {\n          offset: _offset + (originalSize + realBarGap) * i + (originalSize - size) / 2,\n          size: size\n        }\n      }]);\n\n      if (entry.stackList && entry.stackList.length) {\n        entry.stackList.forEach(function (item) {\n          newRes.push({\n            item: item,\n            position: newRes[newRes.length - 1].position\n          });\n        });\n      }\n\n      return newRes;\n    }, []);\n  }\n\n  return result;\n};\nexport var appendOffsetOfLegend = function appendOffsetOfLegend(offset, items, props, legendBox) {\n  var children = props.children,\n      width = props.width,\n      height = props.height,\n      margin = props.margin;\n  var legendWidth = width - (margin.left || 0) - (margin.right || 0);\n  var legendHeight = height - (margin.top || 0) - (margin.bottom || 0);\n  var legendProps = getLegendProps({\n    children: children,\n    items: items,\n    legendWidth: legendWidth,\n    legendHeight: legendHeight\n  });\n  var newOffset = offset;\n\n  if (legendProps) {\n    var box = legendBox || {};\n    var align = legendProps.align,\n        verticalAlign = legendProps.verticalAlign,\n        layout = legendProps.layout;\n\n    if ((layout === 'vertical' || layout === 'horizontal' && verticalAlign === 'center') && isNumber(offset[align])) {\n      newOffset = _objectSpread({}, offset, _defineProperty({}, align, newOffset[align] + (box.width || 0)));\n    }\n\n    if ((layout === 'horizontal' || layout === 'vertical' && align === 'center') && isNumber(offset[verticalAlign])) {\n      newOffset = _objectSpread({}, offset, _defineProperty({}, verticalAlign, newOffset[verticalAlign] + (box.height || 0)));\n    }\n  }\n\n  return newOffset;\n};\nexport var getDomainOfErrorBars = function getDomainOfErrorBars(data, item, dataKey, axisType) {\n  var children = item.props.children;\n  var errorBars = findAllByType(children, ErrorBar).filter(function (errorBarChild) {\n    var direction = errorBarChild.props.direction;\n    return _isNil(direction) || _isNil(axisType) ? true : axisType.indexOf(direction) >= 0;\n  });\n\n  if (errorBars && errorBars.length) {\n    var keys = errorBars.map(function (errorBarChild) {\n      return errorBarChild.props.dataKey;\n    });\n    return data.reduce(function (result, entry) {\n      var entryValue = getValueByDataKey(entry, dataKey, 0);\n      var mainValue = _isArray(entryValue) ? [_min(entryValue), _max(entryValue)] : [entryValue, entryValue];\n      var errorDomain = keys.reduce(function (prevErrorArr, k) {\n        var errorValue = getValueByDataKey(entry, k, 0);\n        var lowerValue = mainValue[0] - Math.abs(_isArray(errorValue) ? errorValue[0] : errorValue);\n        var upperValue = mainValue[1] + Math.abs(_isArray(errorValue) ? errorValue[1] : errorValue);\n        return [Math.min(lowerValue, prevErrorArr[0]), Math.max(upperValue, prevErrorArr[1])];\n      }, [Infinity, -Infinity]);\n      return [Math.min(errorDomain[0], result[0]), Math.max(errorDomain[1], result[1])];\n    }, [Infinity, -Infinity]);\n  }\n\n  return null;\n};\nexport var parseErrorBarsOfAxis = function parseErrorBarsOfAxis(data, items, dataKey, axisType) {\n  var domains = items.map(function (item) {\n    return getDomainOfErrorBars(data, item, dataKey, axisType);\n  }).filter(function (entry) {\n    return !_isNil(entry);\n  });\n\n  if (domains && domains.length) {\n    return domains.reduce(function (result, entry) {\n      return [Math.min(result[0], entry[0]), Math.max(result[1], entry[1])];\n    }, [Infinity, -Infinity]);\n  }\n\n  return null;\n};\n/**\n * Get domain of data by the configuration of item element\n * @param  {Array}   data      The data displayed in the chart\n * @param  {Array}   items     The instances of item\n * @param  {String}  type      The type of axis, number - Number Axis, category - Category Axis\n * @param  {Boolean} filterNil Whether or not filter nil values\n * @return {Array}        Domain\n */\n\nexport var getDomainOfItemsWithSameAxis = function getDomainOfItemsWithSameAxis(data, items, type, filterNil) {\n  var domains = items.map(function (item) {\n    var dataKey = item.props.dataKey;\n\n    if (type === 'number' && dataKey) {\n      return getDomainOfErrorBars(data, item, dataKey) || getDomainOfDataByKey(data, dataKey, type, filterNil);\n    }\n\n    return getDomainOfDataByKey(data, dataKey, type, filterNil);\n  });\n\n  if (type === 'number') {\n    // Calculate the domain of number axis\n    return domains.reduce(function (result, entry) {\n      return [Math.min(result[0], entry[0]), Math.max(result[1], entry[1])];\n    }, [Infinity, -Infinity]);\n  }\n\n  var tag = {}; // Get the union set of category axis\n\n  return domains.reduce(function (result, entry) {\n    for (var i = 0, len = entry.length; i < len; i++) {\n      if (!tag[entry[i]]) {\n        tag[entry[i]] = true;\n        result.push(entry[i]);\n      }\n    }\n\n    return result;\n  }, []);\n};\nexport var isCategorialAxis = function isCategorialAxis(layout, axisType) {\n  return layout === 'horizontal' && axisType === 'xAxis' || layout === 'vertical' && axisType === 'yAxis' || layout === 'centric' && axisType === 'angleAxis' || layout === 'radial' && axisType === 'radiusAxis';\n};\n/**\n * Calculate the Coordinates of grid\n * @param  {Array} ticks The ticks in axis\n * @param {Number} min   The minimun value of axis\n * @param {Number} max   The maximun value of axis\n * @return {Array}       Coordinates\n */\n\nexport var getCoordinatesOfGrid = function getCoordinatesOfGrid(ticks, min, max) {\n  var hasMin, hasMax;\n  var values = ticks.map(function (entry) {\n    if (entry.coordinate === min) {\n      hasMin = true;\n    }\n\n    if (entry.coordinate === max) {\n      hasMax = true;\n    }\n\n    return entry.coordinate;\n  });\n\n  if (!hasMin) {\n    values.push(min);\n  }\n\n  if (!hasMax) {\n    values.push(max);\n  }\n\n  return values;\n};\n/**\n * Get the ticks of an axis\n * @param  {Object}  axis The configuration of an axis\n * @param {Boolean} isGrid Whether or not are the ticks in grid\n * @param {Boolean} isAll Return the ticks of all the points or not\n * @return {Array}  Ticks\n */\n\nexport var getTicksOfAxis = function getTicksOfAxis(axis, isGrid, isAll) {\n  if (!axis) return null;\n  var scale = axis.scale;\n  var duplicateDomain = axis.duplicateDomain,\n      type = axis.type,\n      range = axis.range;\n  var offset = (isGrid || isAll) && type === 'category' && scale.bandwidth ? scale.bandwidth() / 2 : 0;\n  offset = axis.axisType === 'angleAxis' ? mathSign(range[0] - range[1]) * 2 * offset : offset; // The ticks setted by user should only affect the ticks adjacent to axis line\n\n  if (isGrid && (axis.ticks || axis.niceTicks)) {\n    return (axis.ticks || axis.niceTicks).map(function (entry) {\n      var scaleContent = duplicateDomain ? duplicateDomain.indexOf(entry) : entry;\n      return {\n        coordinate: scale(scaleContent) + offset,\n        value: entry,\n        offset: offset\n      };\n    });\n  }\n\n  if (axis.isCategorial && axis.categoricalDomain) {\n    return axis.categoricalDomain.map(function (entry, index) {\n      return {\n        coordinate: scale(entry),\n        value: entry,\n        index: index,\n        offset: offset\n      };\n    });\n  }\n\n  if (scale.ticks && !isAll) {\n    return scale.ticks(axis.tickCount).map(function (entry) {\n      return {\n        coordinate: scale(entry) + offset,\n        value: entry,\n        offset: offset\n      };\n    });\n  } // When axis has duplicated text, serial numbers are used to generate scale\n\n\n  return scale.domain().map(function (entry, index) {\n    return {\n      coordinate: scale(entry) + offset,\n      value: duplicateDomain ? duplicateDomain[entry] : entry,\n      index: index,\n      offset: offset\n    };\n  });\n};\n/**\n * combine the handlers\n * @param  {Function} defaultHandler Internal private handler\n * @param  {Function} parentHandler  Handler function specified in parent component\n * @param  {Function} childHandler   Handler function specified in child component\n * @return {Function}                The combined handler\n */\n\nexport var combineEventHandlers = function combineEventHandlers(defaultHandler, parentHandler, childHandler) {\n  var customizedHandler;\n\n  if (_isFunction(childHandler)) {\n    customizedHandler = childHandler;\n  } else if (_isFunction(parentHandler)) {\n    customizedHandler = parentHandler;\n  }\n\n  if (_isFunction(defaultHandler) || customizedHandler) {\n    return function (arg1, arg2, arg3, arg4) {\n      if (_isFunction(defaultHandler)) {\n        defaultHandler(arg1, arg2, arg3, arg4);\n      }\n\n      if (_isFunction(customizedHandler)) {\n        customizedHandler(arg1, arg2, arg3, arg4);\n      }\n    };\n  }\n\n  return null;\n};\n/**\n * Parse the scale function of axis\n * @param  {Object}   axis          The option of axis\n * @param  {String}   chartType     The displayName of chart\n * @return {Function}               The scale funcion\n */\n\nexport var parseScale = function parseScale(axis, chartType) {\n  var scale = axis.scale,\n      type = axis.type,\n      layout = axis.layout,\n      axisType = axis.axisType;\n\n  if (scale === 'auto') {\n    if (layout === 'radial' && axisType === 'radiusAxis') {\n      return {\n        scale: d3Scales.scaleBand(),\n        realScaleType: 'band'\n      };\n    }\n\n    if (layout === 'radial' && axisType === 'angleAxis') {\n      return {\n        scale: d3Scales.scaleLinear(),\n        realScaleType: 'linear'\n      };\n    }\n\n    if (type === 'category' && chartType && (chartType.indexOf('LineChart') >= 0 || chartType.indexOf('AreaChart') >= 0)) {\n      return {\n        scale: d3Scales.scalePoint(),\n        realScaleType: 'point'\n      };\n    }\n\n    if (type === 'category') {\n      return {\n        scale: d3Scales.scaleBand(),\n        realScaleType: 'band'\n      };\n    }\n\n    return {\n      scale: d3Scales.scaleLinear(),\n      realScaleType: 'linear'\n    };\n  }\n\n  if (_isString(scale)) {\n    var name = \"scale\".concat(scale.slice(0, 1).toUpperCase()).concat(scale.slice(1));\n    return {\n      scale: (d3Scales[name] || d3Scales.scalePoint)(),\n      realScaleType: d3Scales[name] ? name : 'point'\n    };\n  }\n\n  return _isFunction(scale) ? {\n    scale: scale\n  } : {\n    scale: d3Scales.scalePoint(),\n    realScaleType: 'point'\n  };\n};\nvar EPS = 1e-4;\nexport var checkDomainOfScale = function checkDomainOfScale(scale) {\n  var domain = scale.domain();\n\n  if (!domain || domain.length <= 2) {\n    return;\n  }\n\n  var len = domain.length;\n  var range = scale.range();\n  var min = Math.min(range[0], range[1]) - EPS;\n  var max = Math.max(range[0], range[1]) + EPS;\n  var first = scale(domain[0]);\n  var last = scale(domain[len - 1]);\n\n  if (first < min || first > max || last < min || last > max) {\n    scale.domain([domain[0], domain[len - 1]]);\n  }\n};\nexport var findPositionOfBar = function findPositionOfBar(barPosition, child) {\n  if (!barPosition) {\n    return null;\n  }\n\n  for (var i = 0, len = barPosition.length; i < len; i++) {\n    if (barPosition[i].item === child) {\n      return barPosition[i].position;\n    }\n  }\n\n  return null;\n};\nexport var truncateByDomain = function truncateByDomain(value, domain) {\n  if (!domain || domain.length !== 2 || !isNumber(domain[0]) || !isNumber(domain[1])) {\n    return value;\n  }\n\n  var min = Math.min(domain[0], domain[1]);\n  var max = Math.max(domain[0], domain[1]);\n  var result = [value[0], value[1]];\n\n  if (!isNumber(value[0]) || value[0] < min) {\n    result[0] = min;\n  }\n\n  if (!isNumber(value[1]) || value[1] > max) {\n    result[1] = max;\n  }\n\n  if (result[0] > max) {\n    result[0] = max;\n  }\n\n  if (result[1] < min) {\n    result[1] = min;\n  }\n\n  return result;\n};\n/* eslint no-param-reassign: 0 */\n\nexport var offsetSign = function offsetSign(series) {\n  var n = series.length;\n\n  if (n <= 0) {\n    return;\n  }\n\n  for (var j = 0, m = series[0].length; j < m; ++j) {\n    var positive = 0;\n    var negative = 0;\n\n    for (var i = 0; i < n; ++i) {\n      var value = _isNaN(series[i][j][1]) ? series[i][j][0] : series[i][j][1];\n      /* eslint-disable prefer-destructuring */\n\n      if (value >= 0) {\n        series[i][j][0] = positive;\n        series[i][j][1] = positive + value;\n        positive = series[i][j][1];\n      } else {\n        series[i][j][0] = negative;\n        series[i][j][1] = negative + value;\n        negative = series[i][j][1];\n      }\n      /* eslint-enable prefer-destructuring */\n\n    }\n  }\n};\nvar STACK_OFFSET_MAP = {\n  sign: offsetSign,\n  expand: stackOffsetExpand,\n  none: stackOffsetNone,\n  silhouette: stackOffsetSilhouette,\n  wiggle: stackOffsetWiggle\n};\nexport var getStackedData = function getStackedData(data, stackItems, offsetType) {\n  var dataKeys = stackItems.map(function (item) {\n    return item.props.dataKey;\n  });\n  var stack = shapeStack().keys(dataKeys).value(function (d, key) {\n    return +getValueByDataKey(d, key, 0);\n  }).order(stackOrderNone).offset(STACK_OFFSET_MAP[offsetType]);\n  return stack(data);\n};\nexport var getStackGroupsByAxisId = function getStackGroupsByAxisId(data, _items, numericAxisId, cateAxisId, offsetType, reverseStackOrder) {\n  if (!data) {\n    return null;\n  } // reversing items to affect render order (for layering)\n\n\n  var items = reverseStackOrder ? _items.reverse() : _items;\n  var stackGroups = items.reduce(function (result, item) {\n    var _item$props3 = item.props,\n        stackId = _item$props3.stackId,\n        hide = _item$props3.hide;\n\n    if (hide) {\n      return result;\n    }\n\n    var axisId = item.props[numericAxisId];\n    var parentGroup = result[axisId] || {\n      hasStack: false,\n      stackGroups: {}\n    };\n\n    if (isNumOrStr(stackId)) {\n      var childGroup = parentGroup.stackGroups[stackId] || {\n        numericAxisId: numericAxisId,\n        cateAxisId: cateAxisId,\n        items: []\n      };\n      childGroup.items.push(item);\n      parentGroup.hasStack = true;\n      parentGroup.stackGroups[stackId] = childGroup;\n    } else {\n      parentGroup.stackGroups[uniqueId('_stackId_')] = {\n        numericAxisId: numericAxisId,\n        cateAxisId: cateAxisId,\n        items: [item]\n      };\n    }\n\n    return _objectSpread({}, result, _defineProperty({}, axisId, parentGroup));\n  }, {});\n  return Object.keys(stackGroups).reduce(function (result, axisId) {\n    var group = stackGroups[axisId];\n\n    if (group.hasStack) {\n      group.stackGroups = Object.keys(group.stackGroups).reduce(function (res, stackId) {\n        var g = group.stackGroups[stackId];\n        return _objectSpread({}, res, _defineProperty({}, stackId, {\n          numericAxisId: numericAxisId,\n          cateAxisId: cateAxisId,\n          items: g.items,\n          stackedData: getStackedData(data, g.items, offsetType)\n        }));\n      }, {});\n    }\n\n    return _objectSpread({}, result, _defineProperty({}, axisId, group));\n  }, {});\n};\n/**\n * get domain of ticks\n * @param  {Array} ticks Ticks of axis\n * @param  {String} type  The type of axis\n * @return {Array} domain\n */\n\nexport var calculateDomainOfTicks = function calculateDomainOfTicks(ticks, type) {\n  if (type === 'number') {\n    return [_min(ticks), _max(ticks)];\n  }\n\n  return ticks;\n};\n/**\n * Configure the scale function of axis\n * @param {Object} scale The scale function\n * @param {Object} opts  The configuration of axis\n * @return {Object}      null\n */\n\nexport var getTicksOfScale = function getTicksOfScale(scale, opts) {\n  var realScaleType = opts.realScaleType,\n      type = opts.type,\n      tickCount = opts.tickCount,\n      originalDomain = opts.originalDomain,\n      allowDecimals = opts.allowDecimals;\n  var scaleType = realScaleType || opts.scale;\n\n  if (scaleType !== 'auto' && scaleType !== 'linear') {\n    return null;\n  }\n\n  if (tickCount && type === 'number' && originalDomain && (originalDomain[0] === 'auto' || originalDomain[1] === 'auto')) {\n    // Calculate the ticks by the number of grid when the axis is a number axis\n    var domain = scale.domain();\n    var tickValues = getNiceTickValues(domain, tickCount, allowDecimals);\n    scale.domain(calculateDomainOfTicks(tickValues, type));\n    return {\n      niceTicks: tickValues\n    };\n  }\n\n  if (tickCount && type === 'number') {\n    var _domain = scale.domain();\n\n    var _tickValues = getTickValuesFixedDomain(_domain, tickCount, allowDecimals);\n\n    return {\n      niceTicks: _tickValues\n    };\n  }\n\n  return null;\n};\nexport var getCateCoordinateOfLine = function getCateCoordinateOfLine(_ref6) {\n  var axis = _ref6.axis,\n      ticks = _ref6.ticks,\n      bandSize = _ref6.bandSize,\n      entry = _ref6.entry,\n      index = _ref6.index,\n      dataKey = _ref6.dataKey;\n\n  if (axis.type === 'category') {\n    // find coordinate of category axis by the value of category\n    if (!axis.allowDuplicatedCategory && axis.dataKey && !_isNil(entry[axis.dataKey])) {\n      var matchedTick = findEntryInArray(ticks, 'value', entry[axis.dataKey]);\n\n      if (matchedTick) {\n        return matchedTick.coordinate + bandSize / 2;\n      }\n    }\n\n    return ticks[index] ? ticks[index].coordinate + bandSize / 2 : null;\n  }\n\n  var value = getValueByDataKey(entry, !_isNil(dataKey) ? dataKey : axis.dataKey);\n  return !_isNil(value) ? axis.scale(value) : null;\n};\nexport var getCateCoordinateOfBar = function getCateCoordinateOfBar(_ref7) {\n  var axis = _ref7.axis,\n      ticks = _ref7.ticks,\n      offset = _ref7.offset,\n      bandSize = _ref7.bandSize,\n      entry = _ref7.entry,\n      index = _ref7.index;\n\n  if (axis.type === 'category') {\n    return ticks[index] ? ticks[index].coordinate + offset : null;\n  }\n\n  var value = getValueByDataKey(entry, axis.dataKey, axis.domain[index]);\n  return !_isNil(value) ? axis.scale(value) - bandSize / 2 + offset : null;\n};\nexport var getBaseValueOfBar = function getBaseValueOfBar(_ref8) {\n  var numericAxis = _ref8.numericAxis;\n  var domain = numericAxis.scale.domain();\n\n  if (numericAxis.type === 'number') {\n    var min = Math.min(domain[0], domain[1]);\n    var max = Math.max(domain[0], domain[1]);\n\n    if (min <= 0 && max >= 0) {\n      return 0;\n    }\n\n    if (max < 0) {\n      return max;\n    }\n\n    return min;\n  }\n\n  return domain[0];\n};\nexport var getStackedDataOfItem = function getStackedDataOfItem(item, stackGroups) {\n  var stackId = item.props.stackId;\n\n  if (isNumOrStr(stackId)) {\n    var group = stackGroups[stackId];\n\n    if (group && group.items.length) {\n      var itemIndex = -1;\n\n      for (var i = 0, len = group.items.length; i < len; i++) {\n        if (group.items[i] === item) {\n          itemIndex = i;\n          break;\n        }\n      }\n\n      return itemIndex >= 0 ? group.stackedData[itemIndex] : null;\n    }\n  }\n\n  return null;\n};\n\nvar getDomainOfSingle = function getDomainOfSingle(data) {\n  return data.reduce(function (result, entry) {\n    return [_min(entry.concat([result[0]]).filter(isNumber)), _max(entry.concat([result[1]]).filter(isNumber))];\n  }, [Infinity, -Infinity]);\n};\n\nexport var getDomainOfStackGroups = function getDomainOfStackGroups(stackGroups, startIndex, endIndex) {\n  return Object.keys(stackGroups).reduce(function (result, stackId) {\n    var group = stackGroups[stackId];\n    var stackedData = group.stackedData;\n    var domain = stackedData.reduce(function (res, entry) {\n      var s = getDomainOfSingle(entry.slice(startIndex, endIndex + 1));\n      return [Math.min(res[0], s[0]), Math.max(res[1], s[1])];\n    }, [Infinity, -Infinity]);\n    return [Math.min(domain[0], result[0]), Math.max(domain[1], result[1])];\n  }, [Infinity, -Infinity]).map(function (result) {\n    return result === Infinity || result === -Infinity ? 0 : result;\n  });\n};\nexport var MIN_VALUE_REG = /^dataMin[\\s]*-[\\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;\nexport var MAX_VALUE_REG = /^dataMax[\\s]*\\+[\\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;\nexport var parseSpecifiedDomain = function parseSpecifiedDomain(specifiedDomain, dataDomain, allowDataOverflow) {\n  if (!_isArray(specifiedDomain)) {\n    return dataDomain;\n  }\n\n  var domain = [];\n  /* eslint-disable prefer-destructuring */\n\n  if (isNumber(specifiedDomain[0])) {\n    domain[0] = allowDataOverflow ? specifiedDomain[0] : Math.min(specifiedDomain[0], dataDomain[0]);\n  } else if (MIN_VALUE_REG.test(specifiedDomain[0])) {\n    var value = +MIN_VALUE_REG.exec(specifiedDomain[0])[1];\n    domain[0] = dataDomain[0] - value;\n  } else if (_isFunction(specifiedDomain[0])) {\n    domain[0] = specifiedDomain[0](dataDomain[0]);\n  } else {\n    domain[0] = dataDomain[0];\n  }\n\n  if (isNumber(specifiedDomain[1])) {\n    domain[1] = allowDataOverflow ? specifiedDomain[1] : Math.max(specifiedDomain[1], dataDomain[1]);\n  } else if (MAX_VALUE_REG.test(specifiedDomain[1])) {\n    var _value = +MAX_VALUE_REG.exec(specifiedDomain[1])[1];\n\n    domain[1] = dataDomain[1] + _value;\n  } else if (_isFunction(specifiedDomain[1])) {\n    domain[1] = specifiedDomain[1](dataDomain[1]);\n  } else {\n    domain[1] = dataDomain[1];\n  }\n  /* eslint-enable prefer-destructuring */\n\n\n  return domain;\n};\n/**\n * Calculate the size between two category\n * @param  {Object} axis  The options of axis\n * @param  {Array}  ticks The ticks of axis\n * @return {Number} Size\n */\n\nexport var getBandSizeOfAxis = function getBandSizeOfAxis(axis, ticks) {\n  if (axis && axis.scale && axis.scale.bandwidth) {\n    return axis.scale.bandwidth();\n  }\n\n  if (axis && ticks && ticks.length >= 2) {\n    var orderedTicks = _sortBy(ticks, function (o) {\n      return o.coordinate;\n    });\n\n    var bandSize = Infinity;\n\n    for (var i = 1, len = orderedTicks.length; i < len; i++) {\n      var cur = orderedTicks[i];\n      var prev = orderedTicks[i - 1];\n      bandSize = Math.min((cur.coordinate || 0) - (prev.coordinate || 0), bandSize);\n    }\n\n    return bandSize === Infinity ? 0 : bandSize;\n  }\n\n  return 0;\n};\n/**\n * parse the domain of a category axis when a domain is specified\n * @param   {Array}        specifiedDomain  The domain specified by users\n * @param   {Array}        calculatedDomain The domain calculated by dateKey\n * @param   {ReactElement} axisChild        The axis element\n * @returns {Array}        domains\n */\n\nexport var parseDomainOfCategoryAxis = function parseDomainOfCategoryAxis(specifiedDomain, calculatedDomain, axisChild) {\n  if (!specifiedDomain || !specifiedDomain.length) {\n    return calculatedDomain;\n  }\n\n  if (_isEqual(specifiedDomain, _get(axisChild, 'type.defaultProps.domain'))) {\n    return calculatedDomain;\n  }\n\n  return specifiedDomain;\n};"],"mappings":"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"},"metadata":{},"sourceType":"module"}