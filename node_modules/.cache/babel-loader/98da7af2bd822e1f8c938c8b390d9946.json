{"ast":null,"code":"import { extractExceptionKeysForMessage, isEvent, normalizeToSize } from '@sentry/utils';\nimport { computeStackTrace } from './tracekit';\nvar STACKTRACE_LIMIT = 50;\n/**\n * This function creates an exception from an TraceKitStackTrace\n * @param stacktrace TraceKitStackTrace that will be converted to an exception\n * @hidden\n */\nexport function exceptionFromStacktrace(stacktrace) {\n  var frames = prepareFramesForEvent(stacktrace.stack);\n  var exception = {\n    type: stacktrace.name,\n    value: stacktrace.message\n  };\n  if (frames && frames.length) {\n    exception.stacktrace = {\n      frames: frames\n    };\n  }\n  if (exception.type === undefined && exception.value === '') {\n    exception.value = 'Unrecoverable error caught';\n  }\n  return exception;\n}\n/**\n * @hidden\n */\nexport function eventFromPlainObject(exception, syntheticException, rejection) {\n  var event = {\n    exception: {\n      values: [{\n        type: isEvent(exception) ? exception.constructor.name : rejection ? 'UnhandledRejection' : 'Error',\n        value: \"Non-Error \" + (rejection ? 'promise rejection' : 'exception') + \" captured with keys: \" + extractExceptionKeysForMessage(exception)\n      }]\n    },\n    extra: {\n      __serialized__: normalizeToSize(exception)\n    }\n  };\n  if (syntheticException) {\n    var stacktrace = computeStackTrace(syntheticException);\n    var frames_1 = prepareFramesForEvent(stacktrace.stack);\n    event.stacktrace = {\n      frames: frames_1\n    };\n  }\n  return event;\n}\n/**\n * @hidden\n */\nexport function eventFromStacktrace(stacktrace) {\n  var exception = exceptionFromStacktrace(stacktrace);\n  return {\n    exception: {\n      values: [exception]\n    }\n  };\n}\n/**\n * @hidden\n */\nexport function prepareFramesForEvent(stack) {\n  if (!stack || !stack.length) {\n    return [];\n  }\n  var localStack = stack;\n  var firstFrameFunction = localStack[0].func || '';\n  var lastFrameFunction = localStack[localStack.length - 1].func || '';\n  // If stack starts with one of our API calls, remove it (starts, meaning it's the top of the stack - aka last call)\n  if (firstFrameFunction.indexOf('captureMessage') !== -1 || firstFrameFunction.indexOf('captureException') !== -1) {\n    localStack = localStack.slice(1);\n  }\n  // If stack ends with one of our internal API calls, remove it (ends, meaning it's the bottom of the stack - aka top-most call)\n  if (lastFrameFunction.indexOf('sentryWrapped') !== -1) {\n    localStack = localStack.slice(0, -1);\n  }\n  // The frame where the crash happened, should be the last entry in the array\n  return localStack.slice(0, STACKTRACE_LIMIT).map(function (frame) {\n    return {\n      colno: frame.column === null ? undefined : frame.column,\n      filename: frame.url || localStack[0].url,\n      function: frame.func || '?',\n      in_app: true,\n      lineno: frame.line === null ? undefined : frame.line\n    };\n  }).reverse();\n}","map":{"version":3,"sources":["../src/parsers.ts"],"names":[],"mappings":"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","sourcesContent":["import { Event, Exception, StackFrame } from '@sentry/types';\nimport { extractExceptionKeysForMessage, isEvent, normalizeToSize } from '@sentry/utils';\n\nimport { computeStackTrace, StackFrame as TraceKitStackFrame, StackTrace as TraceKitStackTrace } from './tracekit';\n\nconst STACKTRACE_LIMIT = 50;\n\n/**\n * This function creates an exception from an TraceKitStackTrace\n * @param stacktrace TraceKitStackTrace that will be converted to an exception\n * @hidden\n */\nexport function exceptionFromStacktrace(stacktrace: TraceKitStackTrace): Exception {\n  const frames = prepareFramesForEvent(stacktrace.stack);\n\n  const exception: Exception = {\n    type: stacktrace.name,\n    value: stacktrace.message,\n  };\n\n  if (frames && frames.length) {\n    exception.stacktrace = { frames };\n  }\n\n  if (exception.type === undefined && exception.value === '') {\n    exception.value = 'Unrecoverable error caught';\n  }\n\n  return exception;\n}\n\n/**\n * @hidden\n */\nexport function eventFromPlainObject(\n  exception: Record<string, unknown>,\n  syntheticException?: Error,\n  rejection?: boolean,\n): Event {\n  const event: Event = {\n    exception: {\n      values: [\n        {\n          type: isEvent(exception) ? exception.constructor.name : rejection ? 'UnhandledRejection' : 'Error',\n          value: `Non-Error ${\n            rejection ? 'promise rejection' : 'exception'\n          } captured with keys: ${extractExceptionKeysForMessage(exception)}`,\n        },\n      ],\n    },\n    extra: {\n      __serialized__: normalizeToSize(exception),\n    },\n  };\n\n  if (syntheticException) {\n    const stacktrace = computeStackTrace(syntheticException);\n    const frames = prepareFramesForEvent(stacktrace.stack);\n    event.stacktrace = {\n      frames,\n    };\n  }\n\n  return event;\n}\n\n/**\n * @hidden\n */\nexport function eventFromStacktrace(stacktrace: TraceKitStackTrace): Event {\n  const exception = exceptionFromStacktrace(stacktrace);\n\n  return {\n    exception: {\n      values: [exception],\n    },\n  };\n}\n\n/**\n * @hidden\n */\nexport function prepareFramesForEvent(stack: TraceKitStackFrame[]): StackFrame[] {\n  if (!stack || !stack.length) {\n    return [];\n  }\n\n  let localStack = stack;\n\n  const firstFrameFunction = localStack[0].func || '';\n  const lastFrameFunction = localStack[localStack.length - 1].func || '';\n\n  // If stack starts with one of our API calls, remove it (starts, meaning it's the top of the stack - aka last call)\n  if (firstFrameFunction.indexOf('captureMessage') !== -1 || firstFrameFunction.indexOf('captureException') !== -1) {\n    localStack = localStack.slice(1);\n  }\n\n  // If stack ends with one of our internal API calls, remove it (ends, meaning it's the bottom of the stack - aka top-most call)\n  if (lastFrameFunction.indexOf('sentryWrapped') !== -1) {\n    localStack = localStack.slice(0, -1);\n  }\n\n  // The frame where the crash happened, should be the last entry in the array\n  return localStack\n    .slice(0, STACKTRACE_LIMIT)\n    .map(\n      (frame: TraceKitStackFrame): StackFrame => ({\n        colno: frame.column === null ? undefined : frame.column,\n        filename: frame.url || localStack[0].url,\n        function: frame.func || '?',\n        in_app: true,\n        lineno: frame.line === null ? undefined : frame.line,\n      }),\n    )\n    .reverse();\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}