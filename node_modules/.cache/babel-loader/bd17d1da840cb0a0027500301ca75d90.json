{"ast":null,"code":"/**\n * @license\n * https://github.com/bitcoincashjs/cashaddr\n * Copyright (c) 2017-2018 Emilio Almansi\n * Distributed under the MIT software license, see the accompanying\n * file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n */\n\n'use strict';\n\nvar base32 = require('./base32');\nvar bigInt = require('big-integer');\nvar convertBits = require('./convertBits');\nvar validation = require('./validation');\nvar validate = validation.validate;\n\n/**\n * Encoding and decoding of the new Cash Address format for Bitcoin Cash. <br />\n * Compliant with the original cashaddr specification:\n * {@link https://github.com/Bitcoin-UAHF/spec/blob/master/cashaddr.md}\n * @module cashaddr\n */\n\n/**\n * Encodes a hash from a given type into a Bitcoin Cash address with the given prefix.\n * \n * @static\n * @param {string} prefix Network prefix. E.g.: 'bitcoincash'.\n * @param {string} type Type of address to generate. Either 'P2PKH' or 'P2SH'.\n * @param {Uint8Array} hash Hash to encode represented as an array of 8-bit integers.\n * @returns {string}\n * @throws {ValidationError}\n */\nfunction encode(prefix, type, hash) {\n  validate(typeof prefix === 'string' && isValidPrefix(prefix), 'Invalid prefix: ' + prefix + '.');\n  validate(typeof type === 'string', 'Invalid type: ' + type + '.');\n  validate(hash instanceof Uint8Array, 'Invalid hash: ' + hash + '.');\n  var prefixData = concat(prefixToUint5Array(prefix), new Uint8Array(1));\n  var versionByte = getTypeBits(type) + getHashSizeBits(hash);\n  var payloadData = toUint5Array(concat(Uint8Array.of(versionByte), hash));\n  var checksumData = concat(concat(prefixData, payloadData), new Uint8Array(8));\n  var payload = concat(payloadData, checksumToUint5Array(polymod(checksumData)));\n  return prefix + ':' + base32.encode(payload);\n}\n\n/**\n * Decodes the given address into its constituting prefix, type and hash. See [#encode()]{@link encode}.\n * \n * @static\n * @param {string} address Address to decode. E.g.: 'bitcoincash:qpm2qsznhks23z7629mms6s4cwef74vcwvy22gdx6a'.\n * @returns {object}\n * @throws {ValidationError}\n */\nfunction decode(address) {\n  validate(typeof address === 'string' && hasSingleCase(address), 'Invalid address: ' + address + '.');\n  var pieces = address.toLowerCase().split(':');\n  validate(pieces.length === 2, 'Missing prefix: ' + address + '.');\n  var prefix = pieces[0];\n  var payload = base32.decode(pieces[1]);\n  validate(validChecksum(prefix, payload), 'Invalid checksum: ' + address + '.');\n  var payloadData = fromUint5Array(payload.slice(0, -8));\n  var versionByte = payloadData[0];\n  var hash = payloadData.slice(1);\n  validate(getHashSize(versionByte) === hash.length * 8, 'Invalid hash size: ' + address + '.');\n  var type = getType(versionByte);\n  return {\n    prefix: prefix,\n    type: type,\n    hash: hash\n  };\n}\n\n/**\n * Error thrown when encoding or decoding fail due to invalid input.\n *\n * @constructor ValidationError\n * @param {string} message Error description.\n */\nvar ValidationError = validation.ValidationError;\n\n/**\n * Valid address prefixes.\n *\n * @private\n */\nvar VALID_PREFIXES = ['bitcoincash', 'bchtest', 'bchreg'];\n\n/**\n * Checks whether a string is a valid prefix; ie., it has a single letter case\n * and is one of 'bitcoincash', 'bchtest', or 'bchreg'.\n *\n * @private\n * @param {string} prefix \n * @returns {boolean}\n */\nfunction isValidPrefix(prefix) {\n  return hasSingleCase(prefix) && VALID_PREFIXES.indexOf(prefix.toLowerCase()) !== -1;\n}\n\n/**\n * Derives an array from the given prefix to be used in the computation\n * of the address' checksum.\n *\n * @private\n * @param {string} prefix Network prefix. E.g.: 'bitcoincash'. \n * @returns {Uint8Array}\n */\nfunction prefixToUint5Array(prefix) {\n  var result = new Uint8Array(prefix.length);\n  for (var i = 0; i < prefix.length; ++i) {\n    result[i] = prefix[i].charCodeAt(0) & 31;\n  }\n  return result;\n}\n\n/**\n * Returns an array representation of the given checksum to be encoded\n * within the address' payload.\n *\n * @private\n * @param {BigInteger} checksum Computed checksum.\n * @returns {Uint8Array}\n */\nfunction checksumToUint5Array(checksum) {\n  var result = new Uint8Array(8);\n  for (var i = 0; i < 8; ++i) {\n    result[7 - i] = checksum.and(31).toJSNumber();\n    checksum = checksum.shiftRight(5);\n  }\n  return result;\n}\n\n/**\n * Returns the bit representation of the given type within the version\n * byte.\n *\n * @private\n * @param {string} type Address type. Either 'P2PKH' or 'P2SH'.\n * @returns {number}\n * @throws {ValidationError}\n */\nfunction getTypeBits(type) {\n  switch (type) {\n    case 'P2PKH':\n      return 0;\n    case 'P2SH':\n      return 8;\n    default:\n      throw new ValidationError('Invalid type: ' + type + '.');\n  }\n}\n\n/**\n * Retrieves the address type from its bit representation within the\n * version byte.\n *\n * @private\n * @param {number} versionByte\n * @returns {string}\n * @throws {ValidationError}\n */\nfunction getType(versionByte) {\n  switch (versionByte & 120) {\n    case 0:\n      return 'P2PKH';\n    case 8:\n      return 'P2SH';\n    default:\n      throw new ValidationError('Invalid address type in version byte: ' + versionByte + '.');\n  }\n}\n\n/**\n * Returns the bit representation of the length in bits of the given\n * hash within the version byte.\n *\n * @private\n * @param {Uint8Array} hash Hash to encode represented as an array of 8-bit integers.\n * @returns {number}\n * @throws {ValidationError}\n */\nfunction getHashSizeBits(hash) {\n  switch (hash.length * 8) {\n    case 160:\n      return 0;\n    case 192:\n      return 1;\n    case 224:\n      return 2;\n    case 256:\n      return 3;\n    case 320:\n      return 4;\n    case 384:\n      return 5;\n    case 448:\n      return 6;\n    case 512:\n      return 7;\n    default:\n      throw new ValidationError('Invalid hash size: ' + hash.length + '.');\n  }\n}\n\n/**\n * Retrieves the the length in bits of the encoded hash from its bit\n * representation within the version byte.\n *\n * @private\n * @param {number} versionByte\n * @returns {number}\n */\nfunction getHashSize(versionByte) {\n  switch (versionByte & 7) {\n    case 0:\n      return 160;\n    case 1:\n      return 192;\n    case 2:\n      return 224;\n    case 3:\n      return 256;\n    case 4:\n      return 320;\n    case 5:\n      return 384;\n    case 6:\n      return 448;\n    case 7:\n      return 512;\n  }\n}\n\n/**\n * Converts an array of 8-bit integers into an array of 5-bit integers,\n * right-padding with zeroes if necessary.\n *\n * @private\n * @param {Uint8Array} data\n * @returns {Uint8Array}\n */\nfunction toUint5Array(data) {\n  return convertBits(data, 8, 5);\n}\n\n/**\n * Converts an array of 5-bit integers back into an array of 8-bit integers,\n * removing extra zeroes left from padding if necessary.\n * Throws a {@link ValidationError} if input is not a zero-padded array of 8-bit integers.\n *\n * @private\n * @param {Uint8Array} data\n * @returns {Uint8Array}\n * @throws {ValidationError}\n */\nfunction fromUint5Array(data) {\n  return convertBits(data, 5, 8, true);\n}\n\n/**\n * Returns the concatenation a and b.\n *\n * @private\n * @param {Uint8Array} a \n * @param {Uint8Array} b \n * @returns {Uint8Array}\n * @throws {ValidationError}\n */\nfunction concat(a, b) {\n  var ab = new Uint8Array(a.length + b.length);\n  ab.set(a);\n  ab.set(b, a.length);\n  return ab;\n}\n\n/**\n * Computes a checksum from the given input data as specified for the CashAddr\n * format: https://github.com/Bitcoin-UAHF/spec/blob/master/cashaddr.md.\n *\n * @private\n * @param {Uint8Array} data Array of 5-bit integers over which the checksum is to be computed.\n * @returns {BigInteger}\n */\nfunction polymod(data) {\n  var GENERATOR = [0x98f2bc8e61, 0x79b76d99e2, 0xf33e5fb3c4, 0xae2eabe2a8, 0x1e4f43e470];\n  var checksum = bigInt(1);\n  for (var i = 0; i < data.length; ++i) {\n    var value = data[i];\n    var topBits = checksum.shiftRight(35);\n    checksum = checksum.and(0x07ffffffff).shiftLeft(5).xor(value);\n    for (var j = 0; j < GENERATOR.length; ++j) {\n      if (topBits.shiftRight(j).and(1).equals(1)) {\n        checksum = checksum.xor(GENERATOR[j]);\n      }\n    }\n  }\n  return checksum.xor(1);\n}\n\n/**\n * Verify that the payload has not been corrupted by checking that the\n * checksum is valid.\n * \n * @private\n * @param {string} prefix Network prefix. E.g.: 'bitcoincash'.\n * @param {Uint8Array} payload Array of 5-bit integers containing the address' payload.\n * @returns {boolean}\n */\nfunction validChecksum(prefix, payload) {\n  var prefixData = concat(prefixToUint5Array(prefix), new Uint8Array(1));\n  var checksumData = concat(prefixData, payload);\n  return polymod(checksumData).equals(0);\n}\n\n/**\n * Returns true if, and only if, the given string contains either uppercase\n * or lowercase letters, but not both.\n *\n * @private\n * @param {string} string Input string.\n * @returns {boolean}\n */\nfunction hasSingleCase(string) {\n  return string === string.toLowerCase() || string === string.toUpperCase();\n}\nmodule.exports = {\n  encode: encode,\n  decode: decode,\n  ValidationError: ValidationError\n};","map":{"version":3,"names":["base32","require","bigInt","convertBits","validation","validate","encode","prefix","type","hash","isValidPrefix","Uint8Array","prefixData","concat","prefixToUint5Array","versionByte","getTypeBits","getHashSizeBits","payloadData","toUint5Array","of","checksumData","payload","checksumToUint5Array","polymod","decode","address","hasSingleCase","pieces","toLowerCase","split","length","validChecksum","fromUint5Array","slice","getHashSize","getType","ValidationError","VALID_PREFIXES","indexOf","result","i","charCodeAt","checksum","and","toJSNumber","shiftRight","data","a","b","ab","set","GENERATOR","value","topBits","shiftLeft","xor","j","equals","string","toUpperCase","module","exports"],"sources":["C:/Users/Elton/OneDrive/Desktop/baseapp-2024/node_modules/cashaddrjs/src/cashaddr.js"],"sourcesContent":["/**\n * @license\n * https://github.com/bitcoincashjs/cashaddr\n * Copyright (c) 2017-2018 Emilio Almansi\n * Distributed under the MIT software license, see the accompanying\n * file LICENSE or http://www.opensource.org/licenses/mit-license.php.\n */\n\n'use strict';\n\nvar base32 = require('./base32');\nvar bigInt = require('big-integer');\nvar convertBits = require('./convertBits');\nvar validation = require('./validation');\nvar validate = validation.validate;\n\n/**\n * Encoding and decoding of the new Cash Address format for Bitcoin Cash. <br />\n * Compliant with the original cashaddr specification:\n * {@link https://github.com/Bitcoin-UAHF/spec/blob/master/cashaddr.md}\n * @module cashaddr\n */\n\n/**\n * Encodes a hash from a given type into a Bitcoin Cash address with the given prefix.\n * \n * @static\n * @param {string} prefix Network prefix. E.g.: 'bitcoincash'.\n * @param {string} type Type of address to generate. Either 'P2PKH' or 'P2SH'.\n * @param {Uint8Array} hash Hash to encode represented as an array of 8-bit integers.\n * @returns {string}\n * @throws {ValidationError}\n */\nfunction encode(prefix, type, hash) {\n  validate(typeof prefix === 'string' && isValidPrefix(prefix), 'Invalid prefix: ' + prefix + '.');\n  validate(typeof type === 'string', 'Invalid type: ' + type + '.');\n  validate(hash instanceof Uint8Array, 'Invalid hash: ' + hash + '.');\n  var prefixData = concat(prefixToUint5Array(prefix), new Uint8Array(1));\n  var versionByte = getTypeBits(type) + getHashSizeBits(hash);\n  var payloadData = toUint5Array(concat(Uint8Array.of(versionByte), hash));\n  var checksumData = concat(concat(prefixData, payloadData), new Uint8Array(8));\n  var payload = concat(payloadData, checksumToUint5Array(polymod(checksumData)));\n  return prefix + ':' + base32.encode(payload);\n}\n\n/**\n * Decodes the given address into its constituting prefix, type and hash. See [#encode()]{@link encode}.\n * \n * @static\n * @param {string} address Address to decode. E.g.: 'bitcoincash:qpm2qsznhks23z7629mms6s4cwef74vcwvy22gdx6a'.\n * @returns {object}\n * @throws {ValidationError}\n */\nfunction decode(address) {\n  validate(typeof address === 'string' && hasSingleCase(address), 'Invalid address: ' + address + '.');\n  var pieces = address.toLowerCase().split(':');\n  validate(pieces.length === 2, 'Missing prefix: ' + address + '.');\n  var prefix = pieces[0];\n  var payload = base32.decode(pieces[1]);\n  validate(validChecksum(prefix, payload), 'Invalid checksum: ' + address + '.');\n  var payloadData = fromUint5Array(payload.slice(0, -8));\n  var versionByte = payloadData[0];\n  var hash = payloadData.slice(1);\n  validate(getHashSize(versionByte) === hash.length * 8, 'Invalid hash size: ' + address + '.');\n  var type = getType(versionByte);\n  return {\n    prefix: prefix,\n    type: type,\n    hash: hash,\n  };\n}\n\n/**\n * Error thrown when encoding or decoding fail due to invalid input.\n *\n * @constructor ValidationError\n * @param {string} message Error description.\n */\nvar ValidationError = validation.ValidationError;\n\n/**\n * Valid address prefixes.\n *\n * @private\n */\nvar VALID_PREFIXES = ['bitcoincash', 'bchtest', 'bchreg'];\n\n/**\n * Checks whether a string is a valid prefix; ie., it has a single letter case\n * and is one of 'bitcoincash', 'bchtest', or 'bchreg'.\n *\n * @private\n * @param {string} prefix \n * @returns {boolean}\n */\nfunction isValidPrefix(prefix) {\n  return hasSingleCase(prefix) && VALID_PREFIXES.indexOf(prefix.toLowerCase()) !== -1;\n}\n\n/**\n * Derives an array from the given prefix to be used in the computation\n * of the address' checksum.\n *\n * @private\n * @param {string} prefix Network prefix. E.g.: 'bitcoincash'. \n * @returns {Uint8Array}\n */\nfunction prefixToUint5Array(prefix) {\n  var result = new Uint8Array(prefix.length);\n  for (var i = 0; i < prefix.length; ++i) {\n    result[i] = prefix[i].charCodeAt(0) & 31;\n  }\n  return result;\n}\n\n/**\n * Returns an array representation of the given checksum to be encoded\n * within the address' payload.\n *\n * @private\n * @param {BigInteger} checksum Computed checksum.\n * @returns {Uint8Array}\n */\nfunction checksumToUint5Array(checksum) {\n  var result = new Uint8Array(8);\n  for (var i = 0; i < 8; ++i) {\n    result[7 - i] = checksum.and(31).toJSNumber();\n    checksum = checksum.shiftRight(5);\n  }\n  return result;\n}\n\n/**\n * Returns the bit representation of the given type within the version\n * byte.\n *\n * @private\n * @param {string} type Address type. Either 'P2PKH' or 'P2SH'.\n * @returns {number}\n * @throws {ValidationError}\n */\nfunction getTypeBits(type) {\n  switch (type) {\n  case 'P2PKH':\n    return 0;\n  case 'P2SH':\n    return 8;\n  default:\n    throw new ValidationError('Invalid type: ' + type + '.');\n  }\n}\n\n/**\n * Retrieves the address type from its bit representation within the\n * version byte.\n *\n * @private\n * @param {number} versionByte\n * @returns {string}\n * @throws {ValidationError}\n */\nfunction getType(versionByte) {\n  switch (versionByte & 120) {\n  case 0:\n    return 'P2PKH';\n  case 8:\n    return 'P2SH';\n  default:\n    throw new ValidationError('Invalid address type in version byte: ' + versionByte + '.');\n  }\n}\n\n/**\n * Returns the bit representation of the length in bits of the given\n * hash within the version byte.\n *\n * @private\n * @param {Uint8Array} hash Hash to encode represented as an array of 8-bit integers.\n * @returns {number}\n * @throws {ValidationError}\n */\nfunction getHashSizeBits(hash) {\n  switch (hash.length * 8) {\n  case 160:\n    return 0;\n  case 192:\n    return 1;\n  case 224:\n    return 2;\n  case 256:\n    return 3;\n  case 320:\n    return 4;\n  case 384:\n    return 5;\n  case 448:\n    return 6;\n  case 512:\n    return 7;\n  default:\n    throw new ValidationError('Invalid hash size: ' + hash.length + '.');\n  }\n}\n\n/**\n * Retrieves the the length in bits of the encoded hash from its bit\n * representation within the version byte.\n *\n * @private\n * @param {number} versionByte\n * @returns {number}\n */\nfunction getHashSize(versionByte) {\n  switch (versionByte & 7) {\n  case 0:\n    return 160;\n  case 1:\n    return 192;\n  case 2:\n    return 224;\n  case 3:\n    return 256;\n  case 4:\n    return 320;\n  case 5:\n    return 384;\n  case 6:\n    return 448;\n  case 7:\n    return 512;\n  }\n}\n\n/**\n * Converts an array of 8-bit integers into an array of 5-bit integers,\n * right-padding with zeroes if necessary.\n *\n * @private\n * @param {Uint8Array} data\n * @returns {Uint8Array}\n */\nfunction toUint5Array(data) {\n  return convertBits(data, 8, 5);\n}\n\n/**\n * Converts an array of 5-bit integers back into an array of 8-bit integers,\n * removing extra zeroes left from padding if necessary.\n * Throws a {@link ValidationError} if input is not a zero-padded array of 8-bit integers.\n *\n * @private\n * @param {Uint8Array} data\n * @returns {Uint8Array}\n * @throws {ValidationError}\n */\nfunction fromUint5Array(data) {\n  return convertBits(data, 5, 8, true);\n}\n\n/**\n * Returns the concatenation a and b.\n *\n * @private\n * @param {Uint8Array} a \n * @param {Uint8Array} b \n * @returns {Uint8Array}\n * @throws {ValidationError}\n */\nfunction concat(a, b) {\n  var ab = new Uint8Array(a.length + b.length);\n  ab.set(a);\n  ab.set(b, a.length);\n  return ab;\n}\n\n/**\n * Computes a checksum from the given input data as specified for the CashAddr\n * format: https://github.com/Bitcoin-UAHF/spec/blob/master/cashaddr.md.\n *\n * @private\n * @param {Uint8Array} data Array of 5-bit integers over which the checksum is to be computed.\n * @returns {BigInteger}\n */\nfunction polymod(data) {\n  var GENERATOR = [0x98f2bc8e61, 0x79b76d99e2, 0xf33e5fb3c4, 0xae2eabe2a8, 0x1e4f43e470];\n  var checksum = bigInt(1);\n  for (var i = 0; i < data.length; ++i) {\n    var value = data[i];\n    var topBits = checksum.shiftRight(35);\n    checksum = checksum.and(0x07ffffffff).shiftLeft(5).xor(value);\n    for (var j = 0; j < GENERATOR.length; ++j) {\n      if (topBits.shiftRight(j).and(1).equals(1)) {\n        checksum = checksum.xor(GENERATOR[j]);\n      }\n    }\n  }\n  return checksum.xor(1);\n}\n\n/**\n * Verify that the payload has not been corrupted by checking that the\n * checksum is valid.\n * \n * @private\n * @param {string} prefix Network prefix. E.g.: 'bitcoincash'.\n * @param {Uint8Array} payload Array of 5-bit integers containing the address' payload.\n * @returns {boolean}\n */\nfunction validChecksum(prefix, payload) {\n  var prefixData = concat(prefixToUint5Array(prefix), new Uint8Array(1));\n  var checksumData = concat(prefixData, payload);\n  return polymod(checksumData).equals(0);\n}\n\n/**\n * Returns true if, and only if, the given string contains either uppercase\n * or lowercase letters, but not both.\n *\n * @private\n * @param {string} string Input string.\n * @returns {boolean}\n */\nfunction hasSingleCase(string) {\n  return string === string.toLowerCase() || string === string.toUpperCase();\n}\n\nmodule.exports = {\n  encode: encode,\n  decode: decode,\n  ValidationError: ValidationError,\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}