{"ast":null,"code":"'use strict';\n\nvar buffer = require('buffer');\nvar Signature = require('../crypto/signature');\nvar Script = require('../script');\nvar Output = require('./output');\nvar BufferReader = require('../encoding/bufferreader');\nvar BufferWriter = require('../encoding/bufferwriter');\nvar BN = require('../crypto/bn');\nvar Hash = require('../crypto/hash');\nvar ECDSA = require('../crypto/ecdsa');\nvar $ = require('../util/preconditions');\nvar BufferUtil = require('../util/buffer');\nvar _ = require('lodash');\nvar SIGHASH_SINGLE_BUG = '0000000000000000000000000000000000000000000000000000000000000001';\nvar BITS_64_ON = 'ffffffffffffffff';\nvar ENABLE_SIGHASH_FORKID = true;\nvar sighashForForkId = function sighashForForkId(transaction, sighashType, inputNumber, subscript, satoshisBN) {\n  var input = transaction.inputs[inputNumber];\n  $.checkArgument(satoshisBN instanceof BN, 'For ForkId=0 signatures, satoshis or complete input must be provided');\n  function GetForkId() {\n    return 0; // In the UAHF, a fork id of 0 is used (see [4] REQ-6-2 NOTE 4)\n  }\n  ;\n  function GetPrevoutHash(tx) {\n    var writer = new BufferWriter();\n    _.each(tx.inputs, function (input) {\n      writer.writeReverse(input.prevTxId);\n      writer.writeUInt32LE(input.outputIndex);\n    });\n    var buf = writer.toBuffer();\n    var ret = Hash.sha256sha256(buf);\n    return ret;\n  }\n  function GetSequenceHash(tx) {\n    var writer = new BufferWriter();\n    _.each(tx.inputs, function (input) {\n      writer.writeUInt32LE(input.sequenceNumber);\n    });\n    var buf = writer.toBuffer();\n    var ret = Hash.sha256sha256(buf);\n    return ret;\n  }\n  function GetOutputsHash(tx, n) {\n    var writer = new BufferWriter();\n    if (_.isUndefined(n)) {\n      _.each(tx.outputs, function (output) {\n        output.toBufferWriter(writer);\n      });\n    } else {\n      tx.outputs[n].toBufferWriter(writer);\n    }\n    var buf = writer.toBuffer();\n    var ret = Hash.sha256sha256(buf);\n    return ret;\n  }\n  var hashPrevouts = BufferUtil.emptyBuffer(32);\n  var hashSequence = BufferUtil.emptyBuffer(32);\n  var hashOutputs = BufferUtil.emptyBuffer(32);\n  if (!(sighashType & Signature.SIGHASH_ANYONECANPAY)) {\n    hashPrevouts = GetPrevoutHash(transaction);\n  }\n  if (!(sighashType & Signature.SIGHASH_ANYONECANPAY) && (sighashType & 31) != Signature.SIGHASH_SINGLE && (sighashType & 31) != Signature.SIGHASH_NONE) {\n    hashSequence = GetSequenceHash(transaction);\n  }\n  if ((sighashType & 31) != Signature.SIGHASH_SINGLE && (sighashType & 31) != Signature.SIGHASH_NONE) {\n    hashOutputs = GetOutputsHash(transaction);\n  } else if ((sighashType & 31) == Signature.SIGHASH_SINGLE && inputNumber < transaction.outputs.length) {\n    hashOutputs = GetOutputsHash(transaction, inputNumber);\n  }\n  function getHash(w) {\n    var buf = w.toBuffer();\n    var ret = Hash.sha256sha256(buf);\n    ret = new BufferReader(ret).readReverse();\n    return ret;\n  }\n  ;\n  var writer = new BufferWriter();\n\n  // Version\n  writer.writeInt32LE(transaction.version);\n\n  // Input prevouts/nSequence (none/all, depending on flags)\n  writer.write(hashPrevouts);\n  writer.write(hashSequence);\n\n  //  outpoint (32-byte hash + 4-byte little endian)\n  writer.writeReverse(input.prevTxId);\n  writer.writeUInt32LE(input.outputIndex);\n\n  // scriptCode of the input (serialized as scripts inside CTxOuts)\n  writer.writeUInt8(subscript.toBuffer().length);\n  writer.write(subscript.toBuffer());\n\n  // value of the output spent by this input (8-byte little endian)\n  writer.writeUInt64LEBN(satoshisBN);\n\n  // nSequence of the input (4-byte little endian) \n  var sequenceNumber = input.sequenceNumber;\n  writer.writeUInt32LE(sequenceNumber);\n\n  // Outputs (none/one/all, depending on flags)\n  writer.write(hashOutputs);\n\n  // Locktime\n  writer.writeUInt32LE(transaction.nLockTime);\n\n  // sighashType \n  writer.writeUInt32LE(sighashType >>> 0);\n  var buf = writer.toBuffer();\n  var ret = Hash.sha256sha256(buf);\n  ret = new BufferReader(ret).readReverse();\n  return ret;\n};\n\n/**\n * Returns a buffer of length 32 bytes with the hash that needs to be signed\n * for OP_CHECKSIG.\n *\n * @name Signing.sighash\n * @param {Transaction} transaction the transaction to sign\n * @param {number} sighashType the type of the hash\n * @param {number} inputNumber the input index for the signature\n * @param {Script} subscript the script that will be signed\n * @param {satoshisBN} sed in ForkId signatures. If not provided, outputs's amount is used.\n *\n */\nvar sighash = function sighash(transaction, sighashType, inputNumber, subscript, satoshisBN) {\n  var Transaction = require('./transaction');\n  var Input = require('./input');\n\n  // Copy transaction\n  var txcopy = Transaction.shallowCopy(transaction);\n\n  // Copy script\n  subscript = new Script(subscript);\n  if (sighashType & Signature.SIGHASH_FORKID && ENABLE_SIGHASH_FORKID) {\n    return sighashForForkId(txcopy, sighashType, inputNumber, subscript, satoshisBN);\n  }\n\n  // For no ForkId sighash, separators need to be removed.\n  subscript.removeCodeseparators();\n  var i;\n  for (i = 0; i < txcopy.inputs.length; i++) {\n    // Blank signatures for other inputs\n    txcopy.inputs[i] = new Input(txcopy.inputs[i]).setScript(Script.empty());\n  }\n  txcopy.inputs[inputNumber] = new Input(txcopy.inputs[inputNumber]).setScript(subscript);\n  if ((sighashType & 31) === Signature.SIGHASH_NONE || (sighashType & 31) === Signature.SIGHASH_SINGLE) {\n    // clear all sequenceNumbers\n    for (i = 0; i < txcopy.inputs.length; i++) {\n      if (i !== inputNumber) {\n        txcopy.inputs[i].sequenceNumber = 0;\n      }\n    }\n  }\n  if ((sighashType & 31) === Signature.SIGHASH_NONE) {\n    txcopy.outputs = [];\n  } else if ((sighashType & 31) === Signature.SIGHASH_SINGLE) {\n    // The SIGHASH_SINGLE bug.\n    // https://bitcointalk.org/index.php?topic=260595.0\n    if (inputNumber >= txcopy.outputs.length) {\n      return new Buffer(SIGHASH_SINGLE_BUG, 'hex');\n    }\n    txcopy.outputs.length = inputNumber + 1;\n    for (i = 0; i < inputNumber; i++) {\n      txcopy.outputs[i] = new Output({\n        satoshis: BN.fromBuffer(new buffer.Buffer(BITS_64_ON, 'hex')),\n        script: Script.empty()\n      });\n    }\n  }\n  if (sighashType & Signature.SIGHASH_ANYONECANPAY) {\n    txcopy.inputs = [txcopy.inputs[inputNumber]];\n  }\n  var buf = new BufferWriter().write(txcopy.toBuffer()).writeInt32LE(sighashType).toBuffer();\n  var ret = Hash.sha256sha256(buf);\n  ret = new BufferReader(ret).readReverse();\n  return ret;\n};\n\n/**\n * Create a signature\n *\n * @name Signing.sign\n * @param {Transaction} transaction\n * @param {PrivateKey} privateKey\n * @param {number} sighash\n * @param {number} inputIndex\n * @param {Script} subscript\n * @param {satoshisBN} input's amount\n * @return {Signature}\n */\nfunction sign(transaction, privateKey, sighashType, inputIndex, subscript, satoshisBN) {\n  var hashbuf = sighash(transaction, sighashType, inputIndex, subscript, satoshisBN);\n  var sig = ECDSA.sign(hashbuf, privateKey, 'little').set({\n    nhashtype: sighashType\n  });\n  return sig;\n}\n\n/**\n * Verify a signature\n *\n * @name Signing.verify\n * @param {Transaction} transaction\n * @param {Signature} signature\n * @param {PublicKey} publicKey\n * @param {number} inputIndex\n * @param {Script} subscript\n * @param {satoshisBN} input's amount\n * @return {boolean}\n */\nfunction verify(transaction, signature, publicKey, inputIndex, subscript, satoshisBN) {\n  $.checkArgument(!_.isUndefined(transaction));\n  $.checkArgument(!_.isUndefined(signature) && !_.isUndefined(signature.nhashtype));\n  var hashbuf = sighash(transaction, signature.nhashtype, inputIndex, subscript, satoshisBN);\n  return ECDSA.verify(hashbuf, signature, publicKey, 'little');\n}\n\n/**\n * @namespace Signing\n */\nmodule.exports = {\n  sighash: sighash,\n  sign: sign,\n  verify: verify\n};","map":{"version":3,"names":["buffer","require","Signature","Script","Output","BufferReader","BufferWriter","BN","Hash","ECDSA","$","BufferUtil","_","SIGHASH_SINGLE_BUG","BITS_64_ON","ENABLE_SIGHASH_FORKID","sighashForForkId","transaction","sighashType","inputNumber","subscript","satoshisBN","input","inputs","checkArgument","GetForkId","GetPrevoutHash","tx","writer","each","writeReverse","prevTxId","writeUInt32LE","outputIndex","buf","toBuffer","ret","sha256sha256","GetSequenceHash","sequenceNumber","GetOutputsHash","n","isUndefined","outputs","output","toBufferWriter","hashPrevouts","emptyBuffer","hashSequence","hashOutputs","SIGHASH_ANYONECANPAY","SIGHASH_SINGLE","SIGHASH_NONE","length","getHash","w","readReverse","writeInt32LE","version","write","writeUInt8","writeUInt64LEBN","nLockTime","sighash","Transaction","Input","txcopy","shallowCopy","SIGHASH_FORKID","removeCodeseparators","i","setScript","empty","Buffer","satoshis","fromBuffer","script","sign","privateKey","inputIndex","hashbuf","sig","set","nhashtype","verify","signature","publicKey","module","exports"],"sources":["C:/Users/Elton/OneDrive/Desktop/baseapp-2024/node_modules/bitcoincashjs/src/transaction/sighash.js"],"sourcesContent":["'use strict';\n\nvar buffer = require('buffer');\n\nvar Signature = require('../crypto/signature');\nvar Script = require('../script');\nvar Output = require('./output');\nvar BufferReader = require('../encoding/bufferreader');\nvar BufferWriter = require('../encoding/bufferwriter');\nvar BN = require('../crypto/bn');\nvar Hash = require('../crypto/hash');\nvar ECDSA = require('../crypto/ecdsa');\nvar $ = require('../util/preconditions');\nvar BufferUtil = require('../util/buffer');\nvar _ = require('lodash');\n\nvar SIGHASH_SINGLE_BUG = '0000000000000000000000000000000000000000000000000000000000000001';\nvar BITS_64_ON = 'ffffffffffffffff';\n\n\nvar ENABLE_SIGHASH_FORKID = true;\n\n\nvar sighashForForkId = function(transaction, sighashType, inputNumber, subscript, satoshisBN) {\n  var input = transaction.inputs[inputNumber];\n  $.checkArgument(\n    satoshisBN instanceof BN, \n    'For ForkId=0 signatures, satoshis or complete input must be provided'\n  );\n\n  \n\n  function GetForkId() {\n    return 0; // In the UAHF, a fork id of 0 is used (see [4] REQ-6-2 NOTE 4)\n  };\n\n  function GetPrevoutHash(tx) {\n    var writer = new BufferWriter()\n\n    _.each(tx.inputs, function(input) {\n        writer.writeReverse(input.prevTxId);\n        writer.writeUInt32LE(input.outputIndex);\n    });\n\n    var buf = writer.toBuffer();\n    var ret = Hash.sha256sha256(buf);\n    return ret;\n  }\n\n  function GetSequenceHash(tx) {\n    var writer = new BufferWriter()\n\n    _.each(tx.inputs, function(input) {\n      writer.writeUInt32LE(input.sequenceNumber);\n    });\n\n    var buf = writer.toBuffer();\n    var ret = Hash.sha256sha256(buf);\n    return ret;\n  }\n\n  function GetOutputsHash(tx, n) {\n    var writer = new BufferWriter()\n\n    if ( _.isUndefined(n)) {\n      _.each(tx.outputs, function(output) {\n        output.toBufferWriter(writer);\n      });\n    } else {\n      tx.outputs[n].toBufferWriter(writer);\n    }\n   \n    var buf = writer.toBuffer();\n    var ret = Hash.sha256sha256(buf);\n    return ret;\n  }\n\n  var hashPrevouts = BufferUtil.emptyBuffer(32);\n  var hashSequence = BufferUtil.emptyBuffer(32);\n  var hashOutputs = BufferUtil.emptyBuffer(32);\n\n  if (!(sighashType & Signature.SIGHASH_ANYONECANPAY)) {\n    hashPrevouts = GetPrevoutHash(transaction);\n  }\n\n  if (!(sighashType & Signature.SIGHASH_ANYONECANPAY) &&\n    (sighashType & 31) != Signature.SIGHASH_SINGLE &&\n    (sighashType & 31) != Signature.SIGHASH_NONE) {\n    hashSequence = GetSequenceHash(transaction);\n  }\n\n  if ((sighashType & 31) != Signature.SIGHASH_SINGLE && (sighashType & 31) != Signature.SIGHASH_NONE) {\n    hashOutputs = GetOutputsHash(transaction);\n  } else if ((sighashType & 31) == Signature.SIGHASH_SINGLE && inputNumber < transaction.outputs.length) {\n    hashOutputs = GetOutputsHash(transaction, inputNumber);\n  }\n\n\nfunction getHash (w) {\n\n  var buf = w.toBuffer();\n  var ret = Hash.sha256sha256(buf);\n  ret = new BufferReader(ret).readReverse();\n  return ret;\n};  \n\n\n\n  var writer = new BufferWriter()\n\n  // Version\n  writer.writeInt32LE(transaction.version);\n\n  // Input prevouts/nSequence (none/all, depending on flags)\n  writer.write(hashPrevouts);\n  writer.write(hashSequence);\n\n  //  outpoint (32-byte hash + 4-byte little endian)\n  writer.writeReverse(input.prevTxId);\n  writer.writeUInt32LE(input.outputIndex);\n\n  // scriptCode of the input (serialized as scripts inside CTxOuts)\n  writer.writeUInt8(subscript.toBuffer().length)\n  writer.write(subscript.toBuffer());\n\n  // value of the output spent by this input (8-byte little endian)\n  writer.writeUInt64LEBN(satoshisBN);\n  \n  // nSequence of the input (4-byte little endian) \n  var sequenceNumber = input.sequenceNumber;\n  writer.writeUInt32LE(sequenceNumber);\n\n  // Outputs (none/one/all, depending on flags)\n  writer.write(hashOutputs);\n\n  // Locktime\n  writer.writeUInt32LE(transaction.nLockTime);\n\n  // sighashType \n  writer.writeUInt32LE(sighashType >>>0);\n\n  var buf = writer.toBuffer();\n  var ret = Hash.sha256sha256(buf);\n  ret = new BufferReader(ret).readReverse();\n  return ret;\n}\n\n/**\n * Returns a buffer of length 32 bytes with the hash that needs to be signed\n * for OP_CHECKSIG.\n *\n * @name Signing.sighash\n * @param {Transaction} transaction the transaction to sign\n * @param {number} sighashType the type of the hash\n * @param {number} inputNumber the input index for the signature\n * @param {Script} subscript the script that will be signed\n * @param {satoshisBN} sed in ForkId signatures. If not provided, outputs's amount is used.\n *\n */\nvar sighash = function sighash(transaction, sighashType, inputNumber, subscript, satoshisBN) {\n  var Transaction = require('./transaction');\n  var Input = require('./input');\n\n  // Copy transaction\n  var txcopy = Transaction.shallowCopy(transaction);\n\n  // Copy script\n  subscript = new Script(subscript);\n\n\n  if ( ( sighashType & Signature.SIGHASH_FORKID) && ENABLE_SIGHASH_FORKID) {\n    return sighashForForkId(txcopy, sighashType, inputNumber, subscript, satoshisBN);\n  }\n\n  // For no ForkId sighash, separators need to be removed.\n  subscript.removeCodeseparators();\n\n  var i;\n\n  for (i = 0; i < txcopy.inputs.length; i++) {\n    // Blank signatures for other inputs\n    txcopy.inputs[i] = new Input(txcopy.inputs[i]).setScript(Script.empty());\n  }\n\n  txcopy.inputs[inputNumber] = new Input(txcopy.inputs[inputNumber]).setScript(subscript);\n\n  if ((sighashType & 31) === Signature.SIGHASH_NONE ||\n    (sighashType & 31) === Signature.SIGHASH_SINGLE) {\n\n    // clear all sequenceNumbers\n    for (i = 0; i < txcopy.inputs.length; i++) {\n      if (i !== inputNumber) {\n        txcopy.inputs[i].sequenceNumber = 0;\n      }\n    }\n  }\n\n  if ((sighashType & 31) === Signature.SIGHASH_NONE) {\n    txcopy.outputs = [];\n\n  } else if ((sighashType & 31) === Signature.SIGHASH_SINGLE) {\n    // The SIGHASH_SINGLE bug.\n    // https://bitcointalk.org/index.php?topic=260595.0\n    if (inputNumber >= txcopy.outputs.length) {\n      return new Buffer(SIGHASH_SINGLE_BUG, 'hex');\n    }\n\n    txcopy.outputs.length = inputNumber + 1;\n\n    for (i = 0; i < inputNumber; i++) {\n      txcopy.outputs[i] = new Output({\n        satoshis: BN.fromBuffer(new buffer.Buffer(BITS_64_ON, 'hex')),\n        script: Script.empty()\n      });\n    }\n  }\n\n  if (sighashType & Signature.SIGHASH_ANYONECANPAY) {\n    txcopy.inputs = [txcopy.inputs[inputNumber]];\n  }\n\n  var buf = new BufferWriter()\n    .write(txcopy.toBuffer())\n    .writeInt32LE(sighashType)\n    .toBuffer();\n  var ret = Hash.sha256sha256(buf);\n  ret = new BufferReader(ret).readReverse();\n  return ret;\n};\n\n/**\n * Create a signature\n *\n * @name Signing.sign\n * @param {Transaction} transaction\n * @param {PrivateKey} privateKey\n * @param {number} sighash\n * @param {number} inputIndex\n * @param {Script} subscript\n * @param {satoshisBN} input's amount\n * @return {Signature}\n */\nfunction sign(transaction, privateKey, sighashType, inputIndex, subscript, satoshisBN) {\n  var hashbuf = sighash(transaction, sighashType, inputIndex, subscript, satoshisBN);\n  var sig = ECDSA.sign(hashbuf, privateKey, 'little').set({\n    nhashtype: sighashType\n  });\n  return sig;\n}\n\n/**\n * Verify a signature\n *\n * @name Signing.verify\n * @param {Transaction} transaction\n * @param {Signature} signature\n * @param {PublicKey} publicKey\n * @param {number} inputIndex\n * @param {Script} subscript\n * @param {satoshisBN} input's amount\n * @return {boolean}\n */\nfunction verify(transaction, signature, publicKey, inputIndex, subscript, satoshisBN) {\n  $.checkArgument(!_.isUndefined(transaction));\n  $.checkArgument(!_.isUndefined(signature) && !_.isUndefined(signature.nhashtype));\n  var hashbuf = sighash(transaction, signature.nhashtype, inputIndex, subscript, satoshisBN);\n  return ECDSA.verify(hashbuf, signature, publicKey, 'little');\n}\n\n/**\n * @namespace Signing\n */\nmodule.exports = {\n  sighash: sighash,\n  sign: sign,\n  verify: verify\n};\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,MAAM,GAAGC,OAAO,CAAC,QAAQ,CAAC;AAE9B,IAAIC,SAAS,GAAGD,OAAO,CAAC,qBAAqB,CAAC;AAC9C,IAAIE,MAAM,GAAGF,OAAO,CAAC,WAAW,CAAC;AACjC,IAAIG,MAAM,GAAGH,OAAO,CAAC,UAAU,CAAC;AAChC,IAAII,YAAY,GAAGJ,OAAO,CAAC,0BAA0B,CAAC;AACtD,IAAIK,YAAY,GAAGL,OAAO,CAAC,0BAA0B,CAAC;AACtD,IAAIM,EAAE,GAAGN,OAAO,CAAC,cAAc,CAAC;AAChC,IAAIO,IAAI,GAAGP,OAAO,CAAC,gBAAgB,CAAC;AACpC,IAAIQ,KAAK,GAAGR,OAAO,CAAC,iBAAiB,CAAC;AACtC,IAAIS,CAAC,GAAGT,OAAO,CAAC,uBAAuB,CAAC;AACxC,IAAIU,UAAU,GAAGV,OAAO,CAAC,gBAAgB,CAAC;AAC1C,IAAIW,CAAC,GAAGX,OAAO,CAAC,QAAQ,CAAC;AAEzB,IAAIY,kBAAkB,GAAG,kEAAkE;AAC3F,IAAIC,UAAU,GAAG,kBAAkB;AAGnC,IAAIC,qBAAqB,GAAG,IAAI;AAGhC,IAAIC,gBAAgB,GAAG,SAAnBA,gBAAgB,CAAYC,WAAW,EAAEC,WAAW,EAAEC,WAAW,EAAEC,SAAS,EAAEC,UAAU,EAAE;EAC5F,IAAIC,KAAK,GAAGL,WAAW,CAACM,MAAM,CAACJ,WAAW,CAAC;EAC3CT,CAAC,CAACc,aAAa,CACbH,UAAU,YAAYd,EAAE,EACxB,sEAAsE,CACvE;EAID,SAASkB,SAAS,GAAG;IACnB,OAAO,CAAC,CAAC,CAAC;EACZ;EAAC;EAED,SAASC,cAAc,CAACC,EAAE,EAAE;IAC1B,IAAIC,MAAM,GAAG,IAAItB,YAAY,EAAE;IAE/BM,CAAC,CAACiB,IAAI,CAACF,EAAE,CAACJ,MAAM,EAAE,UAASD,KAAK,EAAE;MAC9BM,MAAM,CAACE,YAAY,CAACR,KAAK,CAACS,QAAQ,CAAC;MACnCH,MAAM,CAACI,aAAa,CAACV,KAAK,CAACW,WAAW,CAAC;IAC3C,CAAC,CAAC;IAEF,IAAIC,GAAG,GAAGN,MAAM,CAACO,QAAQ,EAAE;IAC3B,IAAIC,GAAG,GAAG5B,IAAI,CAAC6B,YAAY,CAACH,GAAG,CAAC;IAChC,OAAOE,GAAG;EACZ;EAEA,SAASE,eAAe,CAACX,EAAE,EAAE;IAC3B,IAAIC,MAAM,GAAG,IAAItB,YAAY,EAAE;IAE/BM,CAAC,CAACiB,IAAI,CAACF,EAAE,CAACJ,MAAM,EAAE,UAASD,KAAK,EAAE;MAChCM,MAAM,CAACI,aAAa,CAACV,KAAK,CAACiB,cAAc,CAAC;IAC5C,CAAC,CAAC;IAEF,IAAIL,GAAG,GAAGN,MAAM,CAACO,QAAQ,EAAE;IAC3B,IAAIC,GAAG,GAAG5B,IAAI,CAAC6B,YAAY,CAACH,GAAG,CAAC;IAChC,OAAOE,GAAG;EACZ;EAEA,SAASI,cAAc,CAACb,EAAE,EAAEc,CAAC,EAAE;IAC7B,IAAIb,MAAM,GAAG,IAAItB,YAAY,EAAE;IAE/B,IAAKM,CAAC,CAAC8B,WAAW,CAACD,CAAC,CAAC,EAAE;MACrB7B,CAAC,CAACiB,IAAI,CAACF,EAAE,CAACgB,OAAO,EAAE,UAASC,MAAM,EAAE;QAClCA,MAAM,CAACC,cAAc,CAACjB,MAAM,CAAC;MAC/B,CAAC,CAAC;IACJ,CAAC,MAAM;MACLD,EAAE,CAACgB,OAAO,CAACF,CAAC,CAAC,CAACI,cAAc,CAACjB,MAAM,CAAC;IACtC;IAEA,IAAIM,GAAG,GAAGN,MAAM,CAACO,QAAQ,EAAE;IAC3B,IAAIC,GAAG,GAAG5B,IAAI,CAAC6B,YAAY,CAACH,GAAG,CAAC;IAChC,OAAOE,GAAG;EACZ;EAEA,IAAIU,YAAY,GAAGnC,UAAU,CAACoC,WAAW,CAAC,EAAE,CAAC;EAC7C,IAAIC,YAAY,GAAGrC,UAAU,CAACoC,WAAW,CAAC,EAAE,CAAC;EAC7C,IAAIE,WAAW,GAAGtC,UAAU,CAACoC,WAAW,CAAC,EAAE,CAAC;EAE5C,IAAI,EAAE7B,WAAW,GAAGhB,SAAS,CAACgD,oBAAoB,CAAC,EAAE;IACnDJ,YAAY,GAAGpB,cAAc,CAACT,WAAW,CAAC;EAC5C;EAEA,IAAI,EAAEC,WAAW,GAAGhB,SAAS,CAACgD,oBAAoB,CAAC,IACjD,CAAChC,WAAW,GAAG,EAAE,KAAKhB,SAAS,CAACiD,cAAc,IAC9C,CAACjC,WAAW,GAAG,EAAE,KAAKhB,SAAS,CAACkD,YAAY,EAAE;IAC9CJ,YAAY,GAAGV,eAAe,CAACrB,WAAW,CAAC;EAC7C;EAEA,IAAI,CAACC,WAAW,GAAG,EAAE,KAAKhB,SAAS,CAACiD,cAAc,IAAI,CAACjC,WAAW,GAAG,EAAE,KAAKhB,SAAS,CAACkD,YAAY,EAAE;IAClGH,WAAW,GAAGT,cAAc,CAACvB,WAAW,CAAC;EAC3C,CAAC,MAAM,IAAI,CAACC,WAAW,GAAG,EAAE,KAAKhB,SAAS,CAACiD,cAAc,IAAIhC,WAAW,GAAGF,WAAW,CAAC0B,OAAO,CAACU,MAAM,EAAE;IACrGJ,WAAW,GAAGT,cAAc,CAACvB,WAAW,EAAEE,WAAW,CAAC;EACxD;EAGF,SAASmC,OAAO,CAAEC,CAAC,EAAE;IAEnB,IAAIrB,GAAG,GAAGqB,CAAC,CAACpB,QAAQ,EAAE;IACtB,IAAIC,GAAG,GAAG5B,IAAI,CAAC6B,YAAY,CAACH,GAAG,CAAC;IAChCE,GAAG,GAAG,IAAI/B,YAAY,CAAC+B,GAAG,CAAC,CAACoB,WAAW,EAAE;IACzC,OAAOpB,GAAG;EACZ;EAAC;EAIC,IAAIR,MAAM,GAAG,IAAItB,YAAY,EAAE;;EAE/B;EACAsB,MAAM,CAAC6B,YAAY,CAACxC,WAAW,CAACyC,OAAO,CAAC;;EAExC;EACA9B,MAAM,CAAC+B,KAAK,CAACb,YAAY,CAAC;EAC1BlB,MAAM,CAAC+B,KAAK,CAACX,YAAY,CAAC;;EAE1B;EACApB,MAAM,CAACE,YAAY,CAACR,KAAK,CAACS,QAAQ,CAAC;EACnCH,MAAM,CAACI,aAAa,CAACV,KAAK,CAACW,WAAW,CAAC;;EAEvC;EACAL,MAAM,CAACgC,UAAU,CAACxC,SAAS,CAACe,QAAQ,EAAE,CAACkB,MAAM,CAAC;EAC9CzB,MAAM,CAAC+B,KAAK,CAACvC,SAAS,CAACe,QAAQ,EAAE,CAAC;;EAElC;EACAP,MAAM,CAACiC,eAAe,CAACxC,UAAU,CAAC;;EAElC;EACA,IAAIkB,cAAc,GAAGjB,KAAK,CAACiB,cAAc;EACzCX,MAAM,CAACI,aAAa,CAACO,cAAc,CAAC;;EAEpC;EACAX,MAAM,CAAC+B,KAAK,CAACV,WAAW,CAAC;;EAEzB;EACArB,MAAM,CAACI,aAAa,CAACf,WAAW,CAAC6C,SAAS,CAAC;;EAE3C;EACAlC,MAAM,CAACI,aAAa,CAACd,WAAW,KAAI,CAAC,CAAC;EAEtC,IAAIgB,GAAG,GAAGN,MAAM,CAACO,QAAQ,EAAE;EAC3B,IAAIC,GAAG,GAAG5B,IAAI,CAAC6B,YAAY,CAACH,GAAG,CAAC;EAChCE,GAAG,GAAG,IAAI/B,YAAY,CAAC+B,GAAG,CAAC,CAACoB,WAAW,EAAE;EACzC,OAAOpB,GAAG;AACZ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI2B,OAAO,GAAG,SAASA,OAAO,CAAC9C,WAAW,EAAEC,WAAW,EAAEC,WAAW,EAAEC,SAAS,EAAEC,UAAU,EAAE;EAC3F,IAAI2C,WAAW,GAAG/D,OAAO,CAAC,eAAe,CAAC;EAC1C,IAAIgE,KAAK,GAAGhE,OAAO,CAAC,SAAS,CAAC;;EAE9B;EACA,IAAIiE,MAAM,GAAGF,WAAW,CAACG,WAAW,CAAClD,WAAW,CAAC;;EAEjD;EACAG,SAAS,GAAG,IAAIjB,MAAM,CAACiB,SAAS,CAAC;EAGjC,IAAOF,WAAW,GAAGhB,SAAS,CAACkE,cAAc,IAAKrD,qBAAqB,EAAE;IACvE,OAAOC,gBAAgB,CAACkD,MAAM,EAAEhD,WAAW,EAAEC,WAAW,EAAEC,SAAS,EAAEC,UAAU,CAAC;EAClF;;EAEA;EACAD,SAAS,CAACiD,oBAAoB,EAAE;EAEhC,IAAIC,CAAC;EAEL,KAAKA,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,MAAM,CAAC3C,MAAM,CAAC8B,MAAM,EAAEiB,CAAC,EAAE,EAAE;IACzC;IACAJ,MAAM,CAAC3C,MAAM,CAAC+C,CAAC,CAAC,GAAG,IAAIL,KAAK,CAACC,MAAM,CAAC3C,MAAM,CAAC+C,CAAC,CAAC,CAAC,CAACC,SAAS,CAACpE,MAAM,CAACqE,KAAK,EAAE,CAAC;EAC1E;EAEAN,MAAM,CAAC3C,MAAM,CAACJ,WAAW,CAAC,GAAG,IAAI8C,KAAK,CAACC,MAAM,CAAC3C,MAAM,CAACJ,WAAW,CAAC,CAAC,CAACoD,SAAS,CAACnD,SAAS,CAAC;EAEvF,IAAI,CAACF,WAAW,GAAG,EAAE,MAAMhB,SAAS,CAACkD,YAAY,IAC/C,CAAClC,WAAW,GAAG,EAAE,MAAMhB,SAAS,CAACiD,cAAc,EAAE;IAEjD;IACA,KAAKmB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,MAAM,CAAC3C,MAAM,CAAC8B,MAAM,EAAEiB,CAAC,EAAE,EAAE;MACzC,IAAIA,CAAC,KAAKnD,WAAW,EAAE;QACrB+C,MAAM,CAAC3C,MAAM,CAAC+C,CAAC,CAAC,CAAC/B,cAAc,GAAG,CAAC;MACrC;IACF;EACF;EAEA,IAAI,CAACrB,WAAW,GAAG,EAAE,MAAMhB,SAAS,CAACkD,YAAY,EAAE;IACjDc,MAAM,CAACvB,OAAO,GAAG,EAAE;EAErB,CAAC,MAAM,IAAI,CAACzB,WAAW,GAAG,EAAE,MAAMhB,SAAS,CAACiD,cAAc,EAAE;IAC1D;IACA;IACA,IAAIhC,WAAW,IAAI+C,MAAM,CAACvB,OAAO,CAACU,MAAM,EAAE;MACxC,OAAO,IAAIoB,MAAM,CAAC5D,kBAAkB,EAAE,KAAK,CAAC;IAC9C;IAEAqD,MAAM,CAACvB,OAAO,CAACU,MAAM,GAAGlC,WAAW,GAAG,CAAC;IAEvC,KAAKmD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGnD,WAAW,EAAEmD,CAAC,EAAE,EAAE;MAChCJ,MAAM,CAACvB,OAAO,CAAC2B,CAAC,CAAC,GAAG,IAAIlE,MAAM,CAAC;QAC7BsE,QAAQ,EAAEnE,EAAE,CAACoE,UAAU,CAAC,IAAI3E,MAAM,CAACyE,MAAM,CAAC3D,UAAU,EAAE,KAAK,CAAC,CAAC;QAC7D8D,MAAM,EAAEzE,MAAM,CAACqE,KAAK;MACtB,CAAC,CAAC;IACJ;EACF;EAEA,IAAItD,WAAW,GAAGhB,SAAS,CAACgD,oBAAoB,EAAE;IAChDgB,MAAM,CAAC3C,MAAM,GAAG,CAAC2C,MAAM,CAAC3C,MAAM,CAACJ,WAAW,CAAC,CAAC;EAC9C;EAEA,IAAIe,GAAG,GAAG,IAAI5B,YAAY,EAAE,CACzBqD,KAAK,CAACO,MAAM,CAAC/B,QAAQ,EAAE,CAAC,CACxBsB,YAAY,CAACvC,WAAW,CAAC,CACzBiB,QAAQ,EAAE;EACb,IAAIC,GAAG,GAAG5B,IAAI,CAAC6B,YAAY,CAACH,GAAG,CAAC;EAChCE,GAAG,GAAG,IAAI/B,YAAY,CAAC+B,GAAG,CAAC,CAACoB,WAAW,EAAE;EACzC,OAAOpB,GAAG;AACZ,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASyC,IAAI,CAAC5D,WAAW,EAAE6D,UAAU,EAAE5D,WAAW,EAAE6D,UAAU,EAAE3D,SAAS,EAAEC,UAAU,EAAE;EACrF,IAAI2D,OAAO,GAAGjB,OAAO,CAAC9C,WAAW,EAAEC,WAAW,EAAE6D,UAAU,EAAE3D,SAAS,EAAEC,UAAU,CAAC;EAClF,IAAI4D,GAAG,GAAGxE,KAAK,CAACoE,IAAI,CAACG,OAAO,EAAEF,UAAU,EAAE,QAAQ,CAAC,CAACI,GAAG,CAAC;IACtDC,SAAS,EAAEjE;EACb,CAAC,CAAC;EACF,OAAO+D,GAAG;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASG,MAAM,CAACnE,WAAW,EAAEoE,SAAS,EAAEC,SAAS,EAAEP,UAAU,EAAE3D,SAAS,EAAEC,UAAU,EAAE;EACpFX,CAAC,CAACc,aAAa,CAAC,CAACZ,CAAC,CAAC8B,WAAW,CAACzB,WAAW,CAAC,CAAC;EAC5CP,CAAC,CAACc,aAAa,CAAC,CAACZ,CAAC,CAAC8B,WAAW,CAAC2C,SAAS,CAAC,IAAI,CAACzE,CAAC,CAAC8B,WAAW,CAAC2C,SAAS,CAACF,SAAS,CAAC,CAAC;EACjF,IAAIH,OAAO,GAAGjB,OAAO,CAAC9C,WAAW,EAAEoE,SAAS,CAACF,SAAS,EAAEJ,UAAU,EAAE3D,SAAS,EAAEC,UAAU,CAAC;EAC1F,OAAOZ,KAAK,CAAC2E,MAAM,CAACJ,OAAO,EAAEK,SAAS,EAAEC,SAAS,EAAE,QAAQ,CAAC;AAC9D;;AAEA;AACA;AACA;AACAC,MAAM,CAACC,OAAO,GAAG;EACfzB,OAAO,EAAEA,OAAO;EAChBc,IAAI,EAAEA,IAAI;EACVO,MAAM,EAAEA;AACV,CAAC"},"metadata":{},"sourceType":"script"}