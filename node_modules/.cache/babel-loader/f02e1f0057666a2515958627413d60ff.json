{"ast":null,"code":"import _slicedToArray from \"C:\\\\Users\\\\Elton\\\\OneDrive\\\\Desktop\\\\baseapp-2024\\\\node_modules\\\\babel-preset-react-app\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nvar cryptoRegExps = {\n  btc: '[123][a-km-zA-HJ-NP-Z1-9]{26,35}',\n  bch: '((bitcoincash|bchreg|bchtest):)?(q|p)[a-z0-9]{41}',\n  eth: '0x[a-fA-F0-9]{40}',\n  ltc: '[LM3][a-km-zA-HJ-NP-Z1-9]{26,33}',\n  doge: 'D{1}[5-9A-HJ-NP-U]{1}[1-9A-HJ-NP-Za-km-z]{32}',\n  dash: 'X[1-9A-HJ-NP-Za-km-z]{33}',\n  xmr: '4[0-9AB][1-9A-HJ-NP-Za-km-z]{93}',\n  neo: 'A[0-9a-zA-Z]{33}',\n  xrp: 'r[0-9a-zA-Z]{24,34}?.{1,}'\n};\nvar chainTokens = {\n  eth: ['usdt', 'bnb', 'mesg', 'und', 'bdp', 'taas']\n};\nvar buildRegExp = function buildRegExp(bodyExp, exact) {\n  return exact ? new RegExp(\"^(\".concat(bodyExp, \")$\")) : new RegExp(\"\\\\b(?:\".concat(bodyExp, \")\\\\b\"), 'g');\n};\nvar cryptoAddress = function cryptoAddress(cryptoCurrency, exact) {\n  return buildRegExp(cryptoRegExps[cryptoCurrency], exact);\n};\nvar chainTokenMap = function chainTokenMap(tokenName) {\n  for (var _i = 0, _Object$entries = Object.entries(chainTokens); _i < _Object$entries.length; _i++) {\n    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n      chain = _Object$entries$_i[0],\n      tokens = _Object$entries$_i[1];\n    if (tokens.includes(tokenName)) {\n      return chain;\n    }\n  }\n  return '';\n};\ncryptoAddress.cryptocurrency = function (cryptoCurrency, exact) {\n  if (cryptoRegExps.hasOwnProperty(cryptoCurrency)) {\n    var bodyExp = cryptoRegExps[cryptoCurrency];\n    return buildRegExp(bodyExp, exact);\n  } else if (chainTokenMap(cryptoCurrency)) {\n    var _bodyExp = cryptoRegExps[chainTokenMap(cryptoCurrency)];\n    return buildRegExp(_bodyExp, exact);\n  } else {\n    // throw new Error('Unsupported cryptocurrency');\n\n    //TODO: will need to add more supported crypto coin later\n    return buildRegExp('', false);\n  }\n};\nexport var validateBeneficiaryAddress = cryptoAddress;","map":{"version":3,"names":["cryptoRegExps","btc","bch","eth","ltc","doge","dash","xmr","neo","xrp","chainTokens","buildRegExp","bodyExp","exact","RegExp","cryptoAddress","cryptoCurrency","chainTokenMap","tokenName","Object","entries","chain","tokens","includes","cryptocurrency","hasOwnProperty","validateBeneficiaryAddress"],"sources":["C:/Users/Elton/OneDrive/Desktop/baseapp-2024/src/helpers/validateBeneficiaryAddress.ts"],"sourcesContent":["const cryptoRegExps = {\n    btc: '[123][a-km-zA-HJ-NP-Z1-9]{26,35}',\n    bch: '((bitcoincash|bchreg|bchtest):)?(q|p)[a-z0-9]{41}',\n    eth: '0x[a-fA-F0-9]{40}',\n    ltc: '[LM3][a-km-zA-HJ-NP-Z1-9]{26,33}',\n    doge: 'D{1}[5-9A-HJ-NP-U]{1}[1-9A-HJ-NP-Za-km-z]{32}',\n    dash: 'X[1-9A-HJ-NP-Za-km-z]{33}',\n    xmr: '4[0-9AB][1-9A-HJ-NP-Za-km-z]{93}',\n    neo: 'A[0-9a-zA-Z]{33}',\n    xrp: 'r[0-9a-zA-Z]{24,34}?.{1,}',\n};\n\nconst chainTokens = {\n    eth: [\n        'usdt',\n        'bnb',\n        'mesg',\n        'und',\n        'bdp',\n        'taas',\n    ],\n};\n\nconst buildRegExp = (bodyExp: string, exact?: boolean) =>\n    exact ? new RegExp(`^(${bodyExp})$`) : new RegExp(`\\\\b(?:${bodyExp})\\\\b`, 'g');\n\nconst cryptoAddress = (cryptoCurrency, exact?: boolean) => {\n    return buildRegExp(cryptoRegExps[cryptoCurrency], exact);\n};\n\nconst chainTokenMap = (tokenName: string) => {\n    for (const [chain, tokens] of Object.entries(chainTokens)) {\n        if (tokens.includes(tokenName)) {\n            return chain;\n        }\n    }\n\n    return '';\n};\n\ncryptoAddress.cryptocurrency = (cryptoCurrency, exact) => {\n    if (cryptoRegExps.hasOwnProperty(cryptoCurrency)) {\n        const bodyExp = cryptoRegExps[cryptoCurrency];\n\n        return buildRegExp(bodyExp, exact);\n    } else if (chainTokenMap(cryptoCurrency)) {\n        const bodyExp = cryptoRegExps[chainTokenMap(cryptoCurrency)];\n\n        return buildRegExp(bodyExp, exact);\n    } else {\n        // throw new Error('Unsupported cryptocurrency');\n\n        //TODO: will need to add more supported crypto coin later\n        return buildRegExp('', false);\n    }\n};\n\nexport const validateBeneficiaryAddress = cryptoAddress;\n"],"mappings":";AAAA,IAAMA,aAAa,GAAG;EAClBC,GAAG,EAAE,kCAAkC;EACvCC,GAAG,EAAE,mDAAmD;EACxDC,GAAG,EAAE,mBAAmB;EACxBC,GAAG,EAAE,kCAAkC;EACvCC,IAAI,EAAE,+CAA+C;EACrDC,IAAI,EAAE,2BAA2B;EACjCC,GAAG,EAAE,kCAAkC;EACvCC,GAAG,EAAE,kBAAkB;EACvBC,GAAG,EAAE;AACT,CAAC;AAED,IAAMC,WAAW,GAAG;EAChBP,GAAG,EAAE,CACD,MAAM,EACN,KAAK,EACL,MAAM,EACN,KAAK,EACL,KAAK,EACL,MAAM;AAEd,CAAC;AAED,IAAMQ,WAAW,GAAG,SAAdA,WAAW,CAAIC,OAAe,EAAEC,KAAe;EAAA,OACjDA,KAAK,GAAG,IAAIC,MAAM,aAAMF,OAAO,QAAK,GAAG,IAAIE,MAAM,iBAAUF,OAAO,WAAQ,GAAG,CAAC;AAAA;AAElF,IAAMG,aAAa,GAAG,SAAhBA,aAAa,CAAIC,cAAc,EAAEH,KAAe,EAAK;EACvD,OAAOF,WAAW,CAACX,aAAa,CAACgB,cAAc,CAAC,EAAEH,KAAK,CAAC;AAC5D,CAAC;AAED,IAAMI,aAAa,GAAG,SAAhBA,aAAa,CAAIC,SAAiB,EAAK;EACzC,mCAA8BC,MAAM,CAACC,OAAO,CAACV,WAAW,CAAC,qCAAE;IAAtD;MAAOW,KAAK;MAAEC,MAAM;IACrB,IAAIA,MAAM,CAACC,QAAQ,CAACL,SAAS,CAAC,EAAE;MAC5B,OAAOG,KAAK;IAChB;EACJ;EAEA,OAAO,EAAE;AACb,CAAC;AAEDN,aAAa,CAACS,cAAc,GAAG,UAACR,cAAc,EAAEH,KAAK,EAAK;EACtD,IAAIb,aAAa,CAACyB,cAAc,CAACT,cAAc,CAAC,EAAE;IAC9C,IAAMJ,OAAO,GAAGZ,aAAa,CAACgB,cAAc,CAAC;IAE7C,OAAOL,WAAW,CAACC,OAAO,EAAEC,KAAK,CAAC;EACtC,CAAC,MAAM,IAAII,aAAa,CAACD,cAAc,CAAC,EAAE;IACtC,IAAMJ,QAAO,GAAGZ,aAAa,CAACiB,aAAa,CAACD,cAAc,CAAC,CAAC;IAE5D,OAAOL,WAAW,CAACC,QAAO,EAAEC,KAAK,CAAC;EACtC,CAAC,MAAM;IACH;;IAEA;IACA,OAAOF,WAAW,CAAC,EAAE,EAAE,KAAK,CAAC;EACjC;AACJ,CAAC;AAED,OAAO,IAAMe,0BAA0B,GAAGX,aAAa"},"metadata":{},"sourceType":"module"}