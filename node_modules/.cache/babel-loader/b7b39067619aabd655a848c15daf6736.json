{"ast":null,"code":"'use strict';\n\nvar _ = require('lodash');\nvar $ = require('./util/preconditions');\nvar Address = require('./address');\nvar PublicKey = require('./publickey');\nvar PrivateKey = require('./privatekey');\nvar BufferWriter = require('./encoding/bufferwriter');\nvar ECDSA = require('./crypto/ecdsa');\nvar Signature = require('./crypto/signature');\nvar sha256sha256 = require('./crypto/hash').sha256sha256;\nvar JSUtil = require('./util/js');\n\n/**\n * constructs a new message to sign and verify.\n *\n * @param {String} message\n * @returns {Message}\n */\nvar Message = function Message(message) {\n  if (!(this instanceof Message)) {\n    return new Message(message);\n  }\n  $.checkArgument(_.isString(message), 'First argument should be a string');\n  this.message = message;\n  return this;\n};\nMessage.MAGIC_BYTES = new Buffer('Bitcoin Signed Message:\\n');\nMessage.prototype.magicHash = function magicHash() {\n  var prefix1 = BufferWriter.varintBufNum(Message.MAGIC_BYTES.length);\n  var messageBuffer = new Buffer(this.message);\n  var prefix2 = BufferWriter.varintBufNum(messageBuffer.length);\n  var buf = Buffer.concat([prefix1, Message.MAGIC_BYTES, prefix2, messageBuffer]);\n  var hash = sha256sha256(buf);\n  return hash;\n};\nMessage.prototype._sign = function _sign(privateKey) {\n  console.log(privateKey);\n  $.checkArgument(privateKey instanceof PrivateKey, 'First argument should be an instance of PrivateKey');\n  var hash = this.magicHash();\n  var ecdsa = new ECDSA();\n  ecdsa.hashbuf = hash;\n  ecdsa.privkey = privateKey;\n  ecdsa.pubkey = privateKey.toPublicKey();\n  ecdsa.signRandomK();\n  ecdsa.calci();\n  return ecdsa.sig;\n};\n\n/**\n * Will sign a message with a given bitcoin private key.\n *\n * @param {PrivateKey} privateKey - An instance of PrivateKey\n * @returns {String} A base64 encoded compact signature\n */\nMessage.prototype.sign = function sign(privateKey) {\n  var signature = this._sign(privateKey);\n  return signature.toCompact().toString('base64');\n};\nMessage.prototype._verify = function _verify(publicKey, signature) {\n  $.checkArgument(publicKey instanceof PublicKey, 'First argument should be an instance of PublicKey');\n  $.checkArgument(signature instanceof Signature, 'Second argument should be an instance of Signature');\n  var hash = this.magicHash();\n  var verified = ECDSA.verify(hash, signature, publicKey);\n  if (!verified) {\n    this.error = 'The signature was invalid';\n  }\n  return verified;\n};\n\n/**\n * Will return a boolean of the signature is valid for a given bitcoin address.\n * If it isn't the specific reason is accessible via the \"error\" member.\n *\n * @param {Address|String} bitcoinAddress - A bitcoin address\n * @param {String} signatureString - A base64 encoded compact signature\n * @returns {Boolean}\n */\nMessage.prototype.verify = function verify(bitcoinAddress, signatureString) {\n  $.checkArgument(bitcoinAddress);\n  $.checkArgument(signatureString && _.isString(signatureString));\n  if (_.isString(bitcoinAddress)) {\n    bitcoinAddress = Address.fromString(bitcoinAddress);\n  }\n  var signature = Signature.fromCompact(new Buffer(signatureString, 'base64'));\n\n  // recover the public key\n  var ecdsa = new ECDSA();\n  ecdsa.hashbuf = this.magicHash();\n  ecdsa.sig = signature;\n  var publicKey = ecdsa.toPublicKey();\n  var signatureAddress = Address.fromPublicKey(publicKey, bitcoinAddress.network);\n\n  // check that the recovered address and specified address match\n  if (bitcoinAddress.toString() !== signatureAddress.toString()) {\n    this.error = 'The signature did not match the message digest';\n    return false;\n  }\n  return this._verify(publicKey, signature);\n};\n\n/**\n * Instantiate a message from a message string\n *\n * @param {String} str - A string of the message\n * @returns {Message} A new instance of a Message\n */\nMessage.fromString = function (str) {\n  return new Message(str);\n};\n\n/**\n * Instantiate a message from JSON\n *\n * @param {String} json - An JSON string or Object with keys: message\n * @returns {Message} A new instance of a Message\n */\nMessage.fromJSON = function fromJSON(json) {\n  if (JSUtil.isValidJSON(json)) {\n    json = JSON.parse(json);\n  }\n  return new Message(json.message);\n};\n\n/**\n * @returns {Object} A plain object with the message information\n */\nMessage.prototype.toObject = function toObject() {\n  return {\n    message: this.message\n  };\n};\n\n/**\n * @returns {String} A JSON representation of the message information\n */\nMessage.prototype.toJSON = function toJSON() {\n  return JSON.stringify(this.toObject());\n};\n\n/**\n * Will return a the string representation of the message\n *\n * @returns {String} Message\n */\nMessage.prototype.toString = function () {\n  return this.message;\n};\n\n/**\n * Will return a string formatted for the console\n *\n * @returns {String} Message\n */\nMessage.prototype.inspect = function () {\n  return '<Message: ' + this.toString() + '>';\n};\nmodule.exports = Message;","map":{"version":3,"names":["_","require","$","Address","PublicKey","PrivateKey","BufferWriter","ECDSA","Signature","sha256sha256","JSUtil","Message","message","checkArgument","isString","MAGIC_BYTES","Buffer","prototype","magicHash","prefix1","varintBufNum","length","messageBuffer","prefix2","buf","concat","hash","_sign","privateKey","console","log","ecdsa","hashbuf","privkey","pubkey","toPublicKey","signRandomK","calci","sig","sign","signature","toCompact","toString","_verify","publicKey","verified","verify","error","bitcoinAddress","signatureString","fromString","fromCompact","signatureAddress","fromPublicKey","network","str","fromJSON","json","isValidJSON","JSON","parse","toObject","toJSON","stringify","inspect","module","exports"],"sources":["C:/Users/Elton/OneDrive/Desktop/baseapp-2024/node_modules/bitcoincashjs/src/message.js"],"sourcesContent":["'use strict';\n\nvar _ = require('lodash');\nvar $ = require('./util/preconditions');\nvar Address = require('./address');\nvar PublicKey = require('./publickey');\nvar PrivateKey = require('./privatekey');\nvar BufferWriter = require('./encoding/bufferwriter');\nvar ECDSA = require('./crypto/ecdsa');\nvar Signature = require('./crypto/signature');\nvar sha256sha256 = require('./crypto/hash').sha256sha256;\nvar JSUtil = require('./util/js');\n\n/**\n * constructs a new message to sign and verify.\n *\n * @param {String} message\n * @returns {Message}\n */\nvar Message = function Message(message) {\n  if (!(this instanceof Message)) {\n    return new Message(message);\n  }\n  $.checkArgument(_.isString(message), 'First argument should be a string');\n  this.message = message;\n\n  return this;\n};\n\nMessage.MAGIC_BYTES = new Buffer('Bitcoin Signed Message:\\n');\n\nMessage.prototype.magicHash = function magicHash() {\n  var prefix1 = BufferWriter.varintBufNum(Message.MAGIC_BYTES.length);\n  var messageBuffer = new Buffer(this.message);\n  var prefix2 = BufferWriter.varintBufNum(messageBuffer.length);\n  var buf = Buffer.concat([prefix1, Message.MAGIC_BYTES, prefix2, messageBuffer]);\n  var hash = sha256sha256(buf);\n  return hash;\n};\n\nMessage.prototype._sign = function _sign(privateKey) {\n  console.log(privateKey);\n  $.checkArgument(privateKey instanceof PrivateKey,\n    'First argument should be an instance of PrivateKey');\n  var hash = this.magicHash();\n  var ecdsa = new ECDSA();\n  ecdsa.hashbuf = hash;\n  ecdsa.privkey = privateKey;\n  ecdsa.pubkey = privateKey.toPublicKey();\n  ecdsa.signRandomK();\n  ecdsa.calci();\n  return ecdsa.sig;\n};\n\n/**\n * Will sign a message with a given bitcoin private key.\n *\n * @param {PrivateKey} privateKey - An instance of PrivateKey\n * @returns {String} A base64 encoded compact signature\n */\nMessage.prototype.sign = function sign(privateKey) {\n  var signature = this._sign(privateKey);\n  return signature.toCompact().toString('base64');\n};\n\nMessage.prototype._verify = function _verify(publicKey, signature) {\n  $.checkArgument(publicKey instanceof PublicKey, 'First argument should be an instance of PublicKey');\n  $.checkArgument(signature instanceof Signature, 'Second argument should be an instance of Signature');\n  var hash = this.magicHash();\n  var verified = ECDSA.verify(hash, signature, publicKey);\n  if (!verified) {\n    this.error = 'The signature was invalid';\n  }\n  return verified;\n};\n\n/**\n * Will return a boolean of the signature is valid for a given bitcoin address.\n * If it isn't the specific reason is accessible via the \"error\" member.\n *\n * @param {Address|String} bitcoinAddress - A bitcoin address\n * @param {String} signatureString - A base64 encoded compact signature\n * @returns {Boolean}\n */\nMessage.prototype.verify = function verify(bitcoinAddress, signatureString) {\n  $.checkArgument(bitcoinAddress);\n  $.checkArgument(signatureString && _.isString(signatureString));\n\n  if (_.isString(bitcoinAddress)) {\n    bitcoinAddress = Address.fromString(bitcoinAddress);\n  }\n  var signature = Signature.fromCompact(new Buffer(signatureString, 'base64'));\n\n  // recover the public key\n  var ecdsa = new ECDSA();\n  ecdsa.hashbuf = this.magicHash();\n  ecdsa.sig = signature;\n  var publicKey = ecdsa.toPublicKey();\n\n  var signatureAddress = Address.fromPublicKey(publicKey, bitcoinAddress.network);\n\n  // check that the recovered address and specified address match\n  if (bitcoinAddress.toString() !== signatureAddress.toString()) {\n    this.error = 'The signature did not match the message digest';\n    return false;\n  }\n\n  return this._verify(publicKey, signature);\n};\n\n/**\n * Instantiate a message from a message string\n *\n * @param {String} str - A string of the message\n * @returns {Message} A new instance of a Message\n */\nMessage.fromString = function(str) {\n  return new Message(str);\n};\n\n/**\n * Instantiate a message from JSON\n *\n * @param {String} json - An JSON string or Object with keys: message\n * @returns {Message} A new instance of a Message\n */\nMessage.fromJSON = function fromJSON(json) {\n  if (JSUtil.isValidJSON(json)) {\n    json = JSON.parse(json);\n  }\n  return new Message(json.message);\n};\n\n/**\n * @returns {Object} A plain object with the message information\n */\nMessage.prototype.toObject = function toObject() {\n  return {\n    message: this.message\n  };\n};\n\n/**\n * @returns {String} A JSON representation of the message information\n */\nMessage.prototype.toJSON = function toJSON() {\n  return JSON.stringify(this.toObject());\n};\n\n/**\n * Will return a the string representation of the message\n *\n * @returns {String} Message\n */\nMessage.prototype.toString = function() {\n  return this.message;\n};\n\n/**\n * Will return a string formatted for the console\n *\n * @returns {String} Message\n */\nMessage.prototype.inspect = function() {\n  return '<Message: ' + this.toString() + '>';\n};\n\nmodule.exports = Message;\n"],"mappings":"AAAA,YAAY;;AAEZ,IAAIA,CAAC,GAAGC,OAAO,CAAC,QAAQ,CAAC;AACzB,IAAIC,CAAC,GAAGD,OAAO,CAAC,sBAAsB,CAAC;AACvC,IAAIE,OAAO,GAAGF,OAAO,CAAC,WAAW,CAAC;AAClC,IAAIG,SAAS,GAAGH,OAAO,CAAC,aAAa,CAAC;AACtC,IAAII,UAAU,GAAGJ,OAAO,CAAC,cAAc,CAAC;AACxC,IAAIK,YAAY,GAAGL,OAAO,CAAC,yBAAyB,CAAC;AACrD,IAAIM,KAAK,GAAGN,OAAO,CAAC,gBAAgB,CAAC;AACrC,IAAIO,SAAS,GAAGP,OAAO,CAAC,oBAAoB,CAAC;AAC7C,IAAIQ,YAAY,GAAGR,OAAO,CAAC,eAAe,CAAC,CAACQ,YAAY;AACxD,IAAIC,MAAM,GAAGT,OAAO,CAAC,WAAW,CAAC;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA,IAAIU,OAAO,GAAG,SAASA,OAAO,CAACC,OAAO,EAAE;EACtC,IAAI,EAAE,IAAI,YAAYD,OAAO,CAAC,EAAE;IAC9B,OAAO,IAAIA,OAAO,CAACC,OAAO,CAAC;EAC7B;EACAV,CAAC,CAACW,aAAa,CAACb,CAAC,CAACc,QAAQ,CAACF,OAAO,CAAC,EAAE,mCAAmC,CAAC;EACzE,IAAI,CAACA,OAAO,GAAGA,OAAO;EAEtB,OAAO,IAAI;AACb,CAAC;AAEDD,OAAO,CAACI,WAAW,GAAG,IAAIC,MAAM,CAAC,2BAA2B,CAAC;AAE7DL,OAAO,CAACM,SAAS,CAACC,SAAS,GAAG,SAASA,SAAS,GAAG;EACjD,IAAIC,OAAO,GAAGb,YAAY,CAACc,YAAY,CAACT,OAAO,CAACI,WAAW,CAACM,MAAM,CAAC;EACnE,IAAIC,aAAa,GAAG,IAAIN,MAAM,CAAC,IAAI,CAACJ,OAAO,CAAC;EAC5C,IAAIW,OAAO,GAAGjB,YAAY,CAACc,YAAY,CAACE,aAAa,CAACD,MAAM,CAAC;EAC7D,IAAIG,GAAG,GAAGR,MAAM,CAACS,MAAM,CAAC,CAACN,OAAO,EAAER,OAAO,CAACI,WAAW,EAAEQ,OAAO,EAAED,aAAa,CAAC,CAAC;EAC/E,IAAII,IAAI,GAAGjB,YAAY,CAACe,GAAG,CAAC;EAC5B,OAAOE,IAAI;AACb,CAAC;AAEDf,OAAO,CAACM,SAAS,CAACU,KAAK,GAAG,SAASA,KAAK,CAACC,UAAU,EAAE;EACnDC,OAAO,CAACC,GAAG,CAACF,UAAU,CAAC;EACvB1B,CAAC,CAACW,aAAa,CAACe,UAAU,YAAYvB,UAAU,EAC9C,oDAAoD,CAAC;EACvD,IAAIqB,IAAI,GAAG,IAAI,CAACR,SAAS,EAAE;EAC3B,IAAIa,KAAK,GAAG,IAAIxB,KAAK,EAAE;EACvBwB,KAAK,CAACC,OAAO,GAAGN,IAAI;EACpBK,KAAK,CAACE,OAAO,GAAGL,UAAU;EAC1BG,KAAK,CAACG,MAAM,GAAGN,UAAU,CAACO,WAAW,EAAE;EACvCJ,KAAK,CAACK,WAAW,EAAE;EACnBL,KAAK,CAACM,KAAK,EAAE;EACb,OAAON,KAAK,CAACO,GAAG;AAClB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA3B,OAAO,CAACM,SAAS,CAACsB,IAAI,GAAG,SAASA,IAAI,CAACX,UAAU,EAAE;EACjD,IAAIY,SAAS,GAAG,IAAI,CAACb,KAAK,CAACC,UAAU,CAAC;EACtC,OAAOY,SAAS,CAACC,SAAS,EAAE,CAACC,QAAQ,CAAC,QAAQ,CAAC;AACjD,CAAC;AAED/B,OAAO,CAACM,SAAS,CAAC0B,OAAO,GAAG,SAASA,OAAO,CAACC,SAAS,EAAEJ,SAAS,EAAE;EACjEtC,CAAC,CAACW,aAAa,CAAC+B,SAAS,YAAYxC,SAAS,EAAE,mDAAmD,CAAC;EACpGF,CAAC,CAACW,aAAa,CAAC2B,SAAS,YAAYhC,SAAS,EAAE,oDAAoD,CAAC;EACrG,IAAIkB,IAAI,GAAG,IAAI,CAACR,SAAS,EAAE;EAC3B,IAAI2B,QAAQ,GAAGtC,KAAK,CAACuC,MAAM,CAACpB,IAAI,EAAEc,SAAS,EAAEI,SAAS,CAAC;EACvD,IAAI,CAACC,QAAQ,EAAE;IACb,IAAI,CAACE,KAAK,GAAG,2BAA2B;EAC1C;EACA,OAAOF,QAAQ;AACjB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAlC,OAAO,CAACM,SAAS,CAAC6B,MAAM,GAAG,SAASA,MAAM,CAACE,cAAc,EAAEC,eAAe,EAAE;EAC1E/C,CAAC,CAACW,aAAa,CAACmC,cAAc,CAAC;EAC/B9C,CAAC,CAACW,aAAa,CAACoC,eAAe,IAAIjD,CAAC,CAACc,QAAQ,CAACmC,eAAe,CAAC,CAAC;EAE/D,IAAIjD,CAAC,CAACc,QAAQ,CAACkC,cAAc,CAAC,EAAE;IAC9BA,cAAc,GAAG7C,OAAO,CAAC+C,UAAU,CAACF,cAAc,CAAC;EACrD;EACA,IAAIR,SAAS,GAAGhC,SAAS,CAAC2C,WAAW,CAAC,IAAInC,MAAM,CAACiC,eAAe,EAAE,QAAQ,CAAC,CAAC;;EAE5E;EACA,IAAIlB,KAAK,GAAG,IAAIxB,KAAK,EAAE;EACvBwB,KAAK,CAACC,OAAO,GAAG,IAAI,CAACd,SAAS,EAAE;EAChCa,KAAK,CAACO,GAAG,GAAGE,SAAS;EACrB,IAAII,SAAS,GAAGb,KAAK,CAACI,WAAW,EAAE;EAEnC,IAAIiB,gBAAgB,GAAGjD,OAAO,CAACkD,aAAa,CAACT,SAAS,EAAEI,cAAc,CAACM,OAAO,CAAC;;EAE/E;EACA,IAAIN,cAAc,CAACN,QAAQ,EAAE,KAAKU,gBAAgB,CAACV,QAAQ,EAAE,EAAE;IAC7D,IAAI,CAACK,KAAK,GAAG,gDAAgD;IAC7D,OAAO,KAAK;EACd;EAEA,OAAO,IAAI,CAACJ,OAAO,CAACC,SAAS,EAAEJ,SAAS,CAAC;AAC3C,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA7B,OAAO,CAACuC,UAAU,GAAG,UAASK,GAAG,EAAE;EACjC,OAAO,IAAI5C,OAAO,CAAC4C,GAAG,CAAC;AACzB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA5C,OAAO,CAAC6C,QAAQ,GAAG,SAASA,QAAQ,CAACC,IAAI,EAAE;EACzC,IAAI/C,MAAM,CAACgD,WAAW,CAACD,IAAI,CAAC,EAAE;IAC5BA,IAAI,GAAGE,IAAI,CAACC,KAAK,CAACH,IAAI,CAAC;EACzB;EACA,OAAO,IAAI9C,OAAO,CAAC8C,IAAI,CAAC7C,OAAO,CAAC;AAClC,CAAC;;AAED;AACA;AACA;AACAD,OAAO,CAACM,SAAS,CAAC4C,QAAQ,GAAG,SAASA,QAAQ,GAAG;EAC/C,OAAO;IACLjD,OAAO,EAAE,IAAI,CAACA;EAChB,CAAC;AACH,CAAC;;AAED;AACA;AACA;AACAD,OAAO,CAACM,SAAS,CAAC6C,MAAM,GAAG,SAASA,MAAM,GAAG;EAC3C,OAAOH,IAAI,CAACI,SAAS,CAAC,IAAI,CAACF,QAAQ,EAAE,CAAC;AACxC,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAlD,OAAO,CAACM,SAAS,CAACyB,QAAQ,GAAG,YAAW;EACtC,OAAO,IAAI,CAAC9B,OAAO;AACrB,CAAC;;AAED;AACA;AACA;AACA;AACA;AACAD,OAAO,CAACM,SAAS,CAAC+C,OAAO,GAAG,YAAW;EACrC,OAAO,YAAY,GAAG,IAAI,CAACtB,QAAQ,EAAE,GAAG,GAAG;AAC7C,CAAC;AAEDuB,MAAM,CAACC,OAAO,GAAGvD,OAAO"},"metadata":{},"sourceType":"script"}