{"ast":null,"code":"'use strict';\n\nvar BN = require('./bn');\nvar Point = require('./point');\nvar Signature = require('./signature');\nvar PublicKey = require('../publickey');\nvar Random = require('./random');\nvar Hash = require('./hash');\nvar BufferUtil = require('../util/buffer');\nvar _ = require('lodash');\nvar $ = require('../util/preconditions');\nvar ECDSA = function ECDSA(obj) {\n  if (!(this instanceof ECDSA)) {\n    return new ECDSA(obj);\n  }\n  if (obj) {\n    this.set(obj);\n  }\n};\n\n/* jshint maxcomplexity: 9 */\nECDSA.prototype.set = function (obj) {\n  this.hashbuf = obj.hashbuf || this.hashbuf;\n  this.endian = obj.endian || this.endian; //the endianness of hashbuf\n  this.privkey = obj.privkey || this.privkey;\n  this.pubkey = obj.pubkey || (this.privkey ? this.privkey.publicKey : this.pubkey);\n  this.sig = obj.sig || this.sig;\n  this.k = obj.k || this.k;\n  this.verified = obj.verified || this.verified;\n  return this;\n};\nECDSA.prototype.privkey2pubkey = function () {\n  this.pubkey = this.privkey.toPublicKey();\n};\nECDSA.prototype.calci = function () {\n  for (var i = 0; i < 4; i++) {\n    this.sig.i = i;\n    var Qprime;\n    try {\n      Qprime = this.toPublicKey();\n    } catch (e) {\n      console.error(e);\n      continue;\n    }\n    if (Qprime.point.eq(this.pubkey.point)) {\n      this.sig.compressed = this.pubkey.compressed;\n      return this;\n    }\n  }\n  this.sig.i = undefined;\n  throw new Error('Unable to find valid recovery factor');\n};\nECDSA.fromString = function (str) {\n  var obj = JSON.parse(str);\n  return new ECDSA(obj);\n};\nECDSA.prototype.randomK = function () {\n  var N = Point.getN();\n  var k;\n  do {\n    k = BN.fromBuffer(Random.getRandomBuffer(32));\n  } while (!(k.lt(N) && k.gt(BN.Zero)));\n  this.k = k;\n  return this;\n};\n\n// https://tools.ietf.org/html/rfc6979#section-3.2\nECDSA.prototype.deterministicK = function (badrs) {\n  /* jshint maxstatements: 25 */\n  // if r or s were invalid when this function was used in signing,\n  // we do not want to actually compute r, s here for efficiency, so,\n  // we can increment badrs. explained at end of RFC 6979 section 3.2\n  if (_.isUndefined(badrs)) {\n    badrs = 0;\n  }\n  var v = new Buffer(32);\n  v.fill(0x01);\n  var k = new Buffer(32);\n  k.fill(0x00);\n  var x = this.privkey.bn.toBuffer({\n    size: 32\n  });\n  var hashbuf = this.endian === 'little' ? BufferUtil.reverse(this.hashbuf) : this.hashbuf;\n  k = Hash.sha256hmac(Buffer.concat([v, new Buffer([0x00]), x, hashbuf]), k);\n  v = Hash.sha256hmac(v, k);\n  k = Hash.sha256hmac(Buffer.concat([v, new Buffer([0x01]), x, hashbuf]), k);\n  v = Hash.sha256hmac(v, k);\n  v = Hash.sha256hmac(v, k);\n  var T = BN.fromBuffer(v);\n  var N = Point.getN();\n\n  // also explained in 3.2, we must ensure T is in the proper range (0, N)\n  for (var i = 0; i < badrs || !(T.lt(N) && T.gt(BN.Zero)); i++) {\n    k = Hash.sha256hmac(Buffer.concat([v, new Buffer([0x00])]), k);\n    v = Hash.sha256hmac(v, k);\n    v = Hash.sha256hmac(v, k);\n    T = BN.fromBuffer(v);\n  }\n  this.k = T;\n  return this;\n};\n\n// Information about public key recovery:\n// https://bitcointalk.org/index.php?topic=6430.0\n// http://stackoverflow.com/questions/19665491/how-do-i-get-an-ecdsa-public-key-from-just-a-bitcoin-signature-sec1-4-1-6-k\nECDSA.prototype.toPublicKey = function () {\n  /* jshint maxstatements: 25 */\n  var i = this.sig.i;\n  $.checkArgument(i === 0 || i === 1 || i === 2 || i === 3, new Error('i must be equal to 0, 1, 2, or 3'));\n  var e = BN.fromBuffer(this.hashbuf);\n  var r = this.sig.r;\n  var s = this.sig.s;\n\n  // A set LSB signifies that the y-coordinate is odd\n  var isYOdd = i & 1;\n\n  // The more significant bit specifies whether we should use the\n  // first or second candidate key.\n  var isSecondKey = i >> 1;\n  var n = Point.getN();\n  var G = Point.getG();\n\n  // 1.1 Let x = r + jn\n  var x = isSecondKey ? r.add(n) : r;\n  var R = Point.fromX(isYOdd, x);\n\n  // 1.4 Check that nR is at infinity\n  var nR = R.mul(n);\n  if (!nR.isInfinity()) {\n    throw new Error('nR is not a valid curve point');\n  }\n\n  // Compute -e from e\n  var eNeg = e.neg().mod(n);\n\n  // 1.6.1 Compute Q = r^-1 (sR - eG)\n  // Q = r^-1 (sR + -eG)\n  var rInv = r.invm(n);\n\n  //var Q = R.multiplyTwo(s, G, eNeg).mul(rInv);\n  var Q = R.mul(s).add(G.mul(eNeg)).mul(rInv);\n  var pubkey = PublicKey.fromPoint(Q, this.sig.compressed);\n  return pubkey;\n};\nECDSA.prototype.sigError = function () {\n  /* jshint maxstatements: 25 */\n  if (!BufferUtil.isBuffer(this.hashbuf) || this.hashbuf.length !== 32) {\n    return 'hashbuf must be a 32 byte buffer';\n  }\n  var r = this.sig.r;\n  var s = this.sig.s;\n  if (!(r.gt(BN.Zero) && r.lt(Point.getN())) || !(s.gt(BN.Zero) && s.lt(Point.getN()))) {\n    return 'r and s not in range';\n  }\n  var e = BN.fromBuffer(this.hashbuf, this.endian ? {\n    endian: this.endian\n  } : undefined);\n  var n = Point.getN();\n  var sinv = s.invm(n);\n  var u1 = sinv.mul(e).mod(n);\n  var u2 = sinv.mul(r).mod(n);\n  var p = Point.getG().mulAdd(u1, this.pubkey.point, u2);\n  if (p.isInfinity()) {\n    return 'p is infinity';\n  }\n  if (p.getX().mod(n).cmp(r) !== 0) {\n    return 'Invalid signature';\n  } else {\n    return false;\n  }\n};\nECDSA.toLowS = function (s) {\n  //enforce low s\n  //see BIP 62, \"low S values in signatures\"\n  if (s.gt(BN.fromBuffer(new Buffer('7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0', 'hex')))) {\n    s = Point.getN().sub(s);\n  }\n  return s;\n};\nECDSA.prototype._findSignature = function (d, e) {\n  var N = Point.getN();\n  var G = Point.getG();\n  // try different values of k until r, s are valid\n  var badrs = 0;\n  var k, Q, r, s;\n  do {\n    if (!this.k || badrs > 0) {\n      this.deterministicK(badrs);\n    }\n    badrs++;\n    k = this.k;\n    Q = G.mul(k);\n    r = Q.x.mod(N);\n    s = k.invm(N).mul(e.add(d.mul(r))).mod(N);\n  } while (r.cmp(BN.Zero) <= 0 || s.cmp(BN.Zero) <= 0);\n  s = ECDSA.toLowS(s);\n  return {\n    s: s,\n    r: r\n  };\n};\nECDSA.prototype.sign = function () {\n  var hashbuf = this.hashbuf;\n  var privkey = this.privkey;\n  var d = privkey.bn;\n  $.checkState(hashbuf && privkey && d, new Error('invalid parameters'));\n  $.checkState(BufferUtil.isBuffer(hashbuf) && hashbuf.length === 32, new Error('hashbuf must be a 32 byte buffer'));\n  var e = BN.fromBuffer(hashbuf, this.endian ? {\n    endian: this.endian\n  } : undefined);\n  var obj = this._findSignature(d, e);\n  obj.compressed = this.pubkey.compressed;\n  this.sig = new Signature(obj);\n  return this;\n};\nECDSA.prototype.signRandomK = function () {\n  this.randomK();\n  return this.sign();\n};\nECDSA.prototype.toString = function () {\n  var obj = {};\n  if (this.hashbuf) {\n    obj.hashbuf = this.hashbuf.toString('hex');\n  }\n  if (this.privkey) {\n    obj.privkey = this.privkey.toString();\n  }\n  if (this.pubkey) {\n    obj.pubkey = this.pubkey.toString();\n  }\n  if (this.sig) {\n    obj.sig = this.sig.toString();\n  }\n  if (this.k) {\n    obj.k = this.k.toString();\n  }\n  return JSON.stringify(obj);\n};\nECDSA.prototype.verify = function () {\n  if (!this.sigError()) {\n    this.verified = true;\n  } else {\n    this.verified = false;\n  }\n  return this;\n};\nECDSA.sign = function (hashbuf, privkey, endian) {\n  return ECDSA().set({\n    hashbuf: hashbuf,\n    endian: endian,\n    privkey: privkey\n  }).sign().sig;\n};\nECDSA.verify = function (hashbuf, sig, pubkey, endian) {\n  return ECDSA().set({\n    hashbuf: hashbuf,\n    endian: endian,\n    sig: sig,\n    pubkey: pubkey\n  }).verify().verified;\n};\nmodule.exports = ECDSA;","map":{"version":3,"names":["BN","require","Point","Signature","PublicKey","Random","Hash","BufferUtil","_","$","ECDSA","obj","set","prototype","hashbuf","endian","privkey","pubkey","publicKey","sig","k","verified","privkey2pubkey","toPublicKey","calci","i","Qprime","e","console","error","point","eq","compressed","undefined","Error","fromString","str","JSON","parse","randomK","N","getN","fromBuffer","getRandomBuffer","lt","gt","Zero","deterministicK","badrs","isUndefined","v","Buffer","fill","x","bn","toBuffer","size","reverse","sha256hmac","concat","T","checkArgument","r","s","isYOdd","isSecondKey","n","G","getG","add","R","fromX","nR","mul","isInfinity","eNeg","neg","mod","rInv","invm","Q","fromPoint","sigError","isBuffer","length","sinv","u1","u2","p","mulAdd","getX","cmp","toLowS","sub","_findSignature","d","sign","checkState","signRandomK","toString","stringify","verify","module","exports"],"sources":["C:/Users/Elton/OneDrive/Desktop/baseapp-2024/node_modules/bitcoincashjs/src/crypto/ecdsa.js"],"sourcesContent":["'use strict';\n\nvar BN = require('./bn');\nvar Point = require('./point');\nvar Signature = require('./signature');\nvar PublicKey = require('../publickey');\nvar Random = require('./random');\nvar Hash = require('./hash');\nvar BufferUtil = require('../util/buffer');\nvar _ = require('lodash');\nvar $ = require('../util/preconditions');\n\nvar ECDSA = function ECDSA(obj) {\n  if (!(this instanceof ECDSA)) {\n    return new ECDSA(obj);\n  }\n  if (obj) {\n    this.set(obj);\n  }\n};\n\n/* jshint maxcomplexity: 9 */\nECDSA.prototype.set = function(obj) {\n  this.hashbuf = obj.hashbuf || this.hashbuf;\n  this.endian = obj.endian || this.endian; //the endianness of hashbuf\n  this.privkey = obj.privkey || this.privkey;\n  this.pubkey = obj.pubkey || (this.privkey ? this.privkey.publicKey : this.pubkey);\n  this.sig = obj.sig || this.sig;\n  this.k = obj.k || this.k;\n  this.verified = obj.verified || this.verified;\n  return this;\n};\n\nECDSA.prototype.privkey2pubkey = function() {\n  this.pubkey = this.privkey.toPublicKey();\n};\n\nECDSA.prototype.calci = function() {\n  for (var i = 0; i < 4; i++) {\n    this.sig.i = i;\n    var Qprime;\n    try {\n      Qprime = this.toPublicKey();\n    } catch (e) {\n      console.error(e);\n      continue;\n    }\n\n    if (Qprime.point.eq(this.pubkey.point)) {\n      this.sig.compressed = this.pubkey.compressed;\n      return this;\n    }\n  }\n\n  this.sig.i = undefined;\n  throw new Error('Unable to find valid recovery factor');\n};\n\nECDSA.fromString = function(str) {\n  var obj = JSON.parse(str);\n  return new ECDSA(obj);\n};\n\nECDSA.prototype.randomK = function() {\n  var N = Point.getN();\n  var k;\n  do {\n    k = BN.fromBuffer(Random.getRandomBuffer(32));\n  } while (!(k.lt(N) && k.gt(BN.Zero)));\n  this.k = k;\n  return this;\n};\n\n\n// https://tools.ietf.org/html/rfc6979#section-3.2\nECDSA.prototype.deterministicK = function(badrs) {\n  /* jshint maxstatements: 25 */\n  // if r or s were invalid when this function was used in signing,\n  // we do not want to actually compute r, s here for efficiency, so,\n  // we can increment badrs. explained at end of RFC 6979 section 3.2\n  if (_.isUndefined(badrs)) {\n    badrs = 0;\n  }\n  var v = new Buffer(32);\n  v.fill(0x01);\n  var k = new Buffer(32);\n  k.fill(0x00);\n  var x = this.privkey.bn.toBuffer({\n    size: 32\n  });\n  var hashbuf = this.endian === 'little' ? BufferUtil.reverse(this.hashbuf) : this.hashbuf\n  k = Hash.sha256hmac(Buffer.concat([v, new Buffer([0x00]), x, hashbuf]), k);\n  v = Hash.sha256hmac(v, k);\n  k = Hash.sha256hmac(Buffer.concat([v, new Buffer([0x01]), x, hashbuf]), k);\n  v = Hash.sha256hmac(v, k);\n  v = Hash.sha256hmac(v, k);\n  var T = BN.fromBuffer(v);\n  var N = Point.getN();\n\n  // also explained in 3.2, we must ensure T is in the proper range (0, N)\n  for (var i = 0; i < badrs || !(T.lt(N) && T.gt(BN.Zero)); i++) {\n    k = Hash.sha256hmac(Buffer.concat([v, new Buffer([0x00])]), k);\n    v = Hash.sha256hmac(v, k);\n    v = Hash.sha256hmac(v, k);\n    T = BN.fromBuffer(v);\n  }\n\n  this.k = T;\n  return this;\n};\n\n// Information about public key recovery:\n// https://bitcointalk.org/index.php?topic=6430.0\n// http://stackoverflow.com/questions/19665491/how-do-i-get-an-ecdsa-public-key-from-just-a-bitcoin-signature-sec1-4-1-6-k\nECDSA.prototype.toPublicKey = function() {\n  /* jshint maxstatements: 25 */\n  var i = this.sig.i;\n  $.checkArgument(i === 0 || i === 1 || i === 2 || i === 3, new Error('i must be equal to 0, 1, 2, or 3'));\n\n  var e = BN.fromBuffer(this.hashbuf);\n  var r = this.sig.r;\n  var s = this.sig.s;\n\n  // A set LSB signifies that the y-coordinate is odd\n  var isYOdd = i & 1;\n\n  // The more significant bit specifies whether we should use the\n  // first or second candidate key.\n  var isSecondKey = i >> 1;\n\n  var n = Point.getN();\n  var G = Point.getG();\n\n  // 1.1 Let x = r + jn\n  var x = isSecondKey ? r.add(n) : r;\n  var R = Point.fromX(isYOdd, x);\n\n  // 1.4 Check that nR is at infinity\n  var nR = R.mul(n);\n\n  if (!nR.isInfinity()) {\n    throw new Error('nR is not a valid curve point');\n  }\n\n  // Compute -e from e\n  var eNeg = e.neg().mod(n);\n\n  // 1.6.1 Compute Q = r^-1 (sR - eG)\n  // Q = r^-1 (sR + -eG)\n  var rInv = r.invm(n);\n\n  //var Q = R.multiplyTwo(s, G, eNeg).mul(rInv);\n  var Q = R.mul(s).add(G.mul(eNeg)).mul(rInv);\n\n  var pubkey = PublicKey.fromPoint(Q, this.sig.compressed);\n\n  return pubkey;\n};\n\nECDSA.prototype.sigError = function() {\n  /* jshint maxstatements: 25 */\n  if (!BufferUtil.isBuffer(this.hashbuf) || this.hashbuf.length !== 32) {\n    return 'hashbuf must be a 32 byte buffer';\n  }\n\n  var r = this.sig.r;\n  var s = this.sig.s;\n  if (!(r.gt(BN.Zero) && r.lt(Point.getN())) || !(s.gt(BN.Zero) && s.lt(Point.getN()))) {\n    return 'r and s not in range';\n  }\n\n  var e = BN.fromBuffer(this.hashbuf, this.endian ? {\n    endian: this.endian\n  } : undefined);\n  var n = Point.getN();\n  var sinv = s.invm(n);\n  var u1 = sinv.mul(e).mod(n);\n  var u2 = sinv.mul(r).mod(n);\n\n  var p = Point.getG().mulAdd(u1, this.pubkey.point, u2);\n  if (p.isInfinity()) {\n    return 'p is infinity';\n  }\n\n  if (p.getX().mod(n).cmp(r) !== 0) {\n    return 'Invalid signature';\n  } else {\n    return false;\n  }\n};\n\nECDSA.toLowS = function(s) {\n  //enforce low s\n  //see BIP 62, \"low S values in signatures\"\n  if (s.gt(BN.fromBuffer(new Buffer('7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0', 'hex')))) {\n    s = Point.getN().sub(s);\n  }\n  return s;\n};\n\nECDSA.prototype._findSignature = function(d, e) {\n  var N = Point.getN();\n  var G = Point.getG();\n  // try different values of k until r, s are valid\n  var badrs = 0;\n  var k, Q, r, s;\n  do {\n    if (!this.k || badrs > 0) {\n      this.deterministicK(badrs);\n    }\n    badrs++;\n    k = this.k;\n    Q = G.mul(k);\n    r = Q.x.mod(N);\n    s = k.invm(N).mul(e.add(d.mul(r))).mod(N);\n  } while (r.cmp(BN.Zero) <= 0 || s.cmp(BN.Zero) <= 0);\n\n  s = ECDSA.toLowS(s);\n  return {\n    s: s,\n    r: r\n  };\n\n};\n\nECDSA.prototype.sign = function() {\n  var hashbuf = this.hashbuf;\n  var privkey = this.privkey;\n  var d = privkey.bn;\n\n  $.checkState(hashbuf && privkey && d, new Error('invalid parameters'));\n  $.checkState(BufferUtil.isBuffer(hashbuf) && hashbuf.length === 32, new Error('hashbuf must be a 32 byte buffer'));\n\n  var e = BN.fromBuffer(hashbuf, this.endian ? {\n    endian: this.endian\n  } : undefined);\n\n  var obj = this._findSignature(d, e);\n  obj.compressed = this.pubkey.compressed;\n\n  this.sig = new Signature(obj);\n  return this;\n};\n\nECDSA.prototype.signRandomK = function() {\n  this.randomK();\n  return this.sign();\n};\n\nECDSA.prototype.toString = function() {\n  var obj = {};\n  if (this.hashbuf) {\n    obj.hashbuf = this.hashbuf.toString('hex');\n  }\n  if (this.privkey) {\n    obj.privkey = this.privkey.toString();\n  }\n  if (this.pubkey) {\n    obj.pubkey = this.pubkey.toString();\n  }\n  if (this.sig) {\n    obj.sig = this.sig.toString();\n  }\n  if (this.k) {\n    obj.k = this.k.toString();\n  }\n  return JSON.stringify(obj);\n};\n\nECDSA.prototype.verify = function() {\n  if (!this.sigError()) {\n    this.verified = true;\n  } else {\n    this.verified = false;\n  }\n  return this;\n};\n\nECDSA.sign = function(hashbuf, privkey, endian) {\n  return ECDSA().set({\n    hashbuf: hashbuf,\n    endian: endian,\n    privkey: privkey\n  }).sign().sig;\n};\n\nECDSA.verify = function(hashbuf, sig, pubkey, endian) {\n  return ECDSA().set({\n    hashbuf: hashbuf,\n    endian: endian,\n    sig: sig,\n    pubkey: pubkey\n  }).verify().verified;\n};\n\nmodule.exports = ECDSA;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}